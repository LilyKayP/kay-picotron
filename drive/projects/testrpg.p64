picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: vgfx/
:: lib/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI1OjE1Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSIscmV2aXNpb249MjA5OF1dbHo0AK8AAADcMQAA8xR7WzBdPXtibXA9cHh1
AEMgEBAE8PAsZmxhZ3M9MCxwYW5feAgAynk9MCx6b29tPTl9LDEAL-8VMgAdpxAPEwAOAA6QDgAC
AD8QDgAQAAk_HgAOHgAPLAAECxAAPjAOABwADw4AAg9YACcQcAQADwcBHC-w8DEA------------
----------------------------------------------------dVBtPTl9fQ==
:: gfx/characters.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjMwOjU3Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSIscmV2aXNpb249MjExNF1dbHo0AKYAAABDMQAA8hZ7WzBdPXtibXA9cHh1
AEMgEBAEQBY3cBZ3QAY3BScFFzAGJwUHAgAwMAanDgD3BmdAFhcVN3BXgCZHYBZ3UBZ3QBaXMAMA
8wAQLGZsYWdzPTAscGFuX3gIAMp5PTAsem9vbT04fSxvAC-w8DEA------------------------
----------------------------------------11BtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI1OjE0Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSJdXWx6NAAEAAAAAwAAADBuaWw=
:: lib/error_explorer/
:: lib/error_explorer/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTA2IDAxOjM4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSJdXWx6NAAEAAAAAwAAADBuaWw=
:: lib/error_explorer/error_explorer.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wNS0wNiAwMzoyNDo1NiIsbW9k
aWZpZWQ9IjIwMjQtMDUtMDYgMDM6MjU6MzEiLHJldmlzaW9uPTddXQotLSAjIHBpY290cm9uIGVy
cm9yIGV4cGxvcmVyCi0tCi0tIGJ5IGtpcmEKLS0KLS0gdmVyc2lvbiAwLjAuNAotLQotLSBhbiBp
bnRlcmFjdGl2ZSBlcnJvciBzY3JlZW4gZm9yIHBpY290cm9uLgotLSBvbiBlcnJvciwgc2hvd3Mg
dGhlIHN0YWNrLCBsb2NhbCB2YXJpYWJsZXMsCi0tIGFuZCB0aGUgc291cmNlIGNvZGUgd2hlbiBh
dmFpbGFibGUuCi0tCi0tICMjIHVzYWdlCi0tCi0tIGBpbmNsdWRlYCBvciBgcmVxdWlyZWAgYGVy
cm9yX2V4cGxvcmVyLmx1YWAKLS0gaW4geW91ciBwcm9ncmFtIF9hZnRlcl8gZGVmaW5pbmcgeW91
ciBgX2luaXRgLAotLSBgX3VwZGF0ZWAsIGFuZCBgX2RyYXdgIGZ1bmN0aW9ucy4KLS0KLS0gcHJl
c3MgYHVwYCBhbmQgYGRvd25gIHRvIG1vdmUgdXAgYW5kIGRvd24gb24KLS0gdGhlIHN0YWNrLCBw
cmVzcyBgeGAgb3IgYHNwYWNlYCB0byB0b2dnbGUgZm9udAotLSBzaXplLiBjbGljayBvbiB0YWJs
ZXMgaW4gdGhlIHZhcmlhYmxlIHZpZXcgdG8KLS0gZXhwYW5kIHRoZW0uCi0tCi0tICMjIGhvdyBp
dCB3b3JrcwotLQotLSBpbiBvcmRlciB0byBjYXRjaCBlcnJvcnMgYW5kIGluc3BlY3QgcnVudGlt
ZQotLSBzdGF0ZSwgdGhpcyBzY3JpcHQgcmVwbGFjZXMgYF9pbml0YCwgYF91cGRhdGVgCi0tIGFu
ZCBgX2RyYXdgIGZ1bmN0aW9ucyB3aXRoIG9uZXMgdGhhdCBjYWxsIHRoZQotLSBvcmlnaW5hbCBv
bmVzIGluc2lkZSBhIGNvcm91dGluZS4KLS0KLS0gd2hlbiB0aGVyZSdzIGFuIGVycm9yLCBpdCB1
c2VzIGx1YSdzIGRlYnVnCi0tIGxpYnJhcnkgdG8gaW5zcGVjdCB0aGUgY29yb3V0aW5lLiBhIGNv
cHkKLS0gb2YgdGhlIGVycm9yIGlzIGFsc28gcHJpbnRlZCB0byB0aGUgY29uc29sZQotLSB3aXRo
IHByaW50aCBpZiB5b3UncmUgcnVubmluZyBwaWNvdHJvbiBmcm9tCi0tIHRoZSBjb21tYW5kIGxp
bmUuCi0tCi0tIHRoZSBmb2xsb3dpbmcgZGVidWcgYXBpcyBhcmUgdXNlZDoKLS0KLS0gLSBgZGVi
dWcuZ2V0aW5mb2AKLS0gLSBgZGVidWcuZ2V0bG9jYWxgCi0tIC0gYGRlYnVnLmdldHVwdmFsdWVg
Ci0tIC0gYGRlYnVnLnRyYWNlYmFja2AKLS0KLS0gIyMgdmVyc2lvbiBoaXN0b3J5IAotLQotLSB2
ZXJzaW9uIDAuMC40Ci0tCi0tIC0gYWxzbyBjYXRjaCBlcnJvcnMgaW4gYF9pbml0YAotLQotLSB2
ZXJzaW9uIDAuMC4zCi0tCi0tIC0gYXV0b21hdGljYWxseSBjaG9vc2UgdGhlIHJpZ2h0IHN0YWNr
IGZyYW1lCi0tICAgYmFzZWQgb24gdGhlIGVycm9yIG1lc3NhZ2UKLS0gLSBtb3JlIHRob3JvdWdo
bHkgcHJvdGVjdCBmcm9tIGVycm9ycyBpbiBlcnJvcgotLSAgIGV4cGxvcmVyIGl0c2VsZgotLQot
LSB2ZXJzaW9uIDAuMC4yCi0tCi0tIC0gZG9uJ3QgcmVnZW5lcmF0ZSBzdGFjayBpbmZvIGV2ZXJ5
IGRyYXcKLS0gLSBzY3JvbGwgc3RhY2sgYW5kIHZhcmlhYmxlcyBsaXN0IHdpdGggbW91c2V3aGVl
bAotLSAtIGNsaWNrIG9uIHN0YWNrIHRvIHN3aXRjaCBzdGFjayBmcmFtZXMKLS0gLSBjbGljayBv
biB0YWJsZXMgaW4gdmFyaWFibGVzIHZpZXcgdG8gZXhwYW5kIHRoZW0KLS0gLSBlc2NhcGUgc3Ry
aW5ncyB3aGVuIHByaW50aW5nIHRoZW0KLS0KLS0gdmVyc2lvbiAwLjAuMQotLQotLSAtIGFkanVz
dCBjb2xvcnMKLS0gLSBjb2RlIGNsZWFudXAKLS0gLSB1c2UgYGJ0bnBgIGluc3RlYWQgb2YgYGtl
eXBgCi0tIC0gc2xpZ2h0bHkgbW9yZSB0aG9yb3VnaCBgcmVzZXRgCi0tIC0gZG9uJ3Qgc2hvdyB0
ZW1wb3JhcmllcwotLQotLSB2ZXJzaW9uIDAuMC4wIChwcmVyZWxlYXNlKQotLQotLSAtIGluaXRp
YWwgZGlzY29yZCBiZXRhCgotLSAjIyBsaWNlbnNlCi0tCi0tIENvcHlyaWdodCAyMDI0IEtpcmEg
Qm9vbQotLSAKLS0gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2Us
IHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weQotLSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBh
c3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSDigJxTb2Z0d2FyZeKAnSksIHRvCi0t
IGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRo
b3V0IGxpbWl0YXRpb24gdGhlCi0tIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2Us
IHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vcgotLSBzZWxsIGNvcGllcyBv
ZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2Fy
ZSBpcwotLSBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25k
aXRpb25zOgotLQotLSBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNz
aW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbgotLSBhbGwgY29waWVzIG9yIHN1YnN0YW50
aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLS0gCi0tIFRIRSBTT0ZUV0FSRSBJUyBQUk9W
SURFRCDigJxBUyBJU_KAnSwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwot
LSBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVT
IE9GIE1FUkNIQU5UQUJJTElUWSwKLS0gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0Ug
QU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwKLS0gVEhFIEFVVEhPUlMgT1Ig
Q09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RI
RVIKLS0gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBP
UiBPVEhFUldJU0UsIEFSSVNJTkcKLS0gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lU
SCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUgotLSBERUFMSU5HUyBJTiBUSEUgU09G
VFdBUkUuCgotLS0tIHV0aWwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LQoKbG9jYWwgZnVuY3Rpb24gZmlsZW5hbWVfb2YgKHBhdGgpCiAgcmV0dXJuIHBhdGg6bWF0Y2gg
KCdbXi9dKiQnKQplbmQKCmxvY2FsIGZ1bmN0aW9uIHNhZmVfdG9zdHJpbmcgKHZhbHVlKQogIGlm
IHR5cGUgKHZhbHVlKSA9PSAnc3RyaW5nJyB0aGVuCiAgICByZXR1cm4gc3RyaW5nLmZvcm1hdCAo
JyVxJywgdmFsdWUpCiAgZWxzZQogICAgbG9jYWwgc3VjY2VzcywgdmFsdWVfc3RyaW5nID0gcGNh
bGwgKHRvc3RyaW5nLCB2YWx1ZSkKICAgIHJldHVybiBzdWNjZXNzIGFuZCB2YWx1ZV9zdHJpbmcK
ICAgICAgICAgICAgICAgICAgIG9yICgnZXJyb3IgZHVyaW5nIHRvc3RyaW5nOiAnIC4uIHRvc3Ry
aW5nICh2YWx1ZV9zdHJpbmcpKQogIGVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIGdldF9saW5lcyAo
dGV4dCkKICBsb2NhbCBsaW5lcyA9IHt9CiAgZm9yIGxpbmUgaW4gdGV4dDpnbWF0Y2ggKCIoLi0p
XHI-XG4iKSBkbwogICAgdGFibGUuaW5zZXJ0IChsaW5lcywgbGluZSkKICBlbmQKICBsb2NhbCBs
YXN0X2xpbmUgPSB0ZXh0Om1hdGNoICgnKFteXG5dKikkJykKICBpZiBsYXN0X2xpbmUgYW5kIGxh
c3RfbGluZSB_PSAnJyB0aGVuCiAgICB0YWJsZS5pbnNlcnQgKGxpbmVzLCBsYXN0X2xpbmUpCiAg
ZW5kCiAgcmV0dXJuIGxpbmVzCmVuZAoKbG9jYWwgZnVuY3Rpb24gY29tcGFyZV9rZXlzIChhLCBi
KQogIGxvY2FsIHRhID0gdHlwZSAoYS5rZXkpCiAgbG9jYWwgdGIgPSB0eXBlIChiLmtleSkKICBp
ZiB0YSB_PSB0YiB0aGVuCiAgICByZXR1cm4gdGEgPCB0YgogIGVuZAogIGlmIHRhID09ICdudW1i
ZXInIG9yIHRhID09ICdzdHJpbmcnIHRoZW4KICAgIHJldHVybiBhLmtleSA8IGIua2V5CiAgZWxz
ZQogICAgcmV0dXJuIHNhZmVfdG9zdHJpbmcgKGEua2V5KSA8IHNhZmVfdG9zdHJpbmcgKGIua2V5
KQogIGVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIHNvcnQgKHQsIGYpCiAgLS0gaW5zZXJ0aW9uIHNv
cnQKICBmID0gZiBvciBmdW5jdGlvbiAoYSwgYikgcmV0dXJuIGEgPCBiIGVuZAogIGZvciBpID0g
MSwgI3QtMSBkbwogICAgbG9jYWwgdmFsID0gdFtpKzFdCiAgICBsb2NhbCBqID0gaQogICAgd2hp
bGUgaiA_PSAxIGFuZCBub3QgZih0W2pdLCB2YWwpIGRvCiAgICAgIHRbaisxXSA9IHRbal0KICAg
ICAgaiA9IGogLSAxCiAgICBlbmQKICAgIHRbaisxXSA9IHZhbAogIGVuZAplbmQKCmxvY2FsIGZ1
bmN0aW9uIGFwcHJvYWNoIChmcm9tLCB0bykKICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICog
MC4yNQplbmQKCmxvY2FsIGZ1bmN0aW9uIHJvdW5kICh2YWx1ZSkKICByZXR1cm4gbWF0aC5mbG9v
ciAodmFsdWUgKyAwLjUpCmVuZAoKbG9jYWwgZnVuY3Rpb24gcGFyc2VfbWVzc2FnZV9mb3JfbG9j
YXRpb24gKG1zZykKICBsb2NhbCBwYXRoLCBsaW5lLCBlcnIgPSBtc2c6bWF0Y2ggKCdeKFteOl0r
KTooJWQrKTooLiopJCcpCiAgcmV0dXJuIHBhdGgsIHRvbnVtYmVyIChsaW5lKSwgZXJyCmVuZAoK
LS0tLSBzdGF0ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCmxvY2Fs
IF9HID0gX0cKbG9jYWwgZXJyb3JfbWVzc2FnZQpsb2NhbCBlcnJvcl90aHJlYWQKbG9jYWwgZXJy
b3JfdHJhY2ViYWNrCmxvY2FsIGluaXRfZG9uZSA9IGZhbHNlCmxvY2FsIHVzZV9zbWFsbF9mb250
ID0gZmFsc2UKbG9jYWwgbW91c2Vfd2FzX2NsaWNrZWQgPSBmYWxzZQoKLS0gc3RhY2sgdmlldwps
b2NhbCBzdGFja19mcmFtZXMgPSB7fQpsb2NhbCBjdXJyZW50X3N0YWNrX2luZGV4ID0gMQpsb2Nh
bCBob3ZlcmVkX3N0YWNrX2luZGV4ID0gZmFsc2UKbG9jYWwgbW91c2Vfb3Zlcl9zdGFjayA9IGZh
bHNlCmxvY2FsIHN0YWNrX21heF9zY3JvbGwgPSAwCmxvY2FsIHN0YWNrX3Njcm9sbCA9IDAKbG9j
YWwgc3RhY2tfc2Nyb2xsX3Ntb290aCA9IDAKCi0tIHZhcmlhYmxlcyB2aWV3CmxvY2FsIHZhcmlh
YmxlcyA9IHt9CmxvY2FsIGhvdmVyZWRfdmFyaWFibGUgPSBmYWxzZQpsb2NhbCB2YXJpYWJsZXNf
bWF4X3Njcm9sbCA9IDAKbG9jYWwgdmFyaWFibGVzX3Njcm9sbCA9IDAKbG9jYWwgdmFyaWFibGVz
X3Njcm9sbF9zbW9vdGggPSAwCmxvY2FsIG1vdXNlX292ZXJfdmFyaWFibGVzID0gZmFsc2UKCi0t
IHNvdXJjZSB2aWV3CmxvY2FsIHNvdXJjZV9saW5lcyA9IHt9CgoKLS0tLSBtYWluIGV2ZW50cyAt
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCmxvY2FsIFcgPSA0ODAKbG9jYWwgSCA9
IDI3MAoKbG9jYWwgZnVuY3Rpb24gcmVidWlsZCAoKQogIC0tIHJlYnVpbGQgc3RhY2sgZnJhbWUg
aW5mbwogIHN0YWNrX2ZyYW1lcyA9IHt9CiAgdmFyaWFibGVzID0ge30KICBzb3VyY2VfbGluZXMg
PSB7fQogIHZhcmlhYmxlc19zY3JvbGwgPSAwCiAgdmFyaWFibGVzX3Njcm9sbF9zbW9vdGggPSAw
CgogIGZvciBpID0gMCwgMjAgZG8KICAgIGxvY2FsIGluZm8gPSBkZWJ1Zy5nZXRpbmZvIChlcnJv
cl90aHJlYWQsIGkpCiAgICBpZiBub3QgaW5mbyB0aGVuCiAgICAgIGJyZWFrCiAgICBlbmQKCiAg
ICBpZiBpbmZvLnNob3J0X3NyYyB0aGVuCiAgICAgIHRhYmxlLmluc2VydCAoc3RhY2tfZnJhbWVz
LCB7CiAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZV9vZiAoaW5mby5zaG9ydF9zcmMpLAogICAg
ICAgIHBhdGggPSBpbmZvLnNob3J0X3NyYywKICAgICAgICBsaW5lID0gaW5mby5jdXJyZW50bGlu
ZSwKICAgICAgICBkZXB0aCA9IGksCiAgICAgICAgZm5fbmFtZSA9IChpbmZvLm5hbWUgb3IgKGZp
bGVuYW1lX29mIChpbmZvLnNob3J0X3NyYykgLi4gJzonIC4uIHRvc3RyaW5nIChpbmZvLmxpbmVk
ZWZpbmVkKSkpLAogICAgICAgIHNvdXJjZSA9IGluZm8uc291cmNlLAogICAgICB9KQogICAgZW5k
CiAgZW5kCgogIGxvY2FsIGZyYW1lID0gc3RhY2tfZnJhbWVzIFtjdXJyZW50X3N0YWNrX2luZGV4
XQoKICBpZiBub3QgZnJhbWUgdGhlbgogICAgcmV0dXJuCiAgZW5kCgogIC0tIHJlYnVpbGQgdmFy
aWFibGVzCiAgZG8KICAgIGxvY2FsIGxvY2FsX2luZGV4ID0gMQogICAgcmVwZWF0CiAgICAgIGxv
Y2FsIG5hbWUsIHZhbHVlID0gZGVidWcuZ2V0bG9jYWwgKGVycm9yX3RocmVhZCwgZnJhbWUuZGVw
dGgsIGxvY2FsX2luZGV4KQogICAgICBpZiBuYW1lIHRoZW4KICAgICAgICBpZiBuYW1lIH49ICco
dGVtcG9yYXJ5KScgdGhlbgogICAgICAgICAgdGFibGUuaW5zZXJ0ICh2YXJpYWJsZXMsIHsKICAg
ICAgICAgICAga2V5ID0gbmFtZSwKICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSwKICAgICAgICAg
IH0pCiAgICAgICAgZW5kCiAgICAgICAgbG9jYWxfaW5kZXggPSBsb2NhbF9pbmRleCArIDEKICAg
ICAgZW5kCiAgICB1bnRpbCBub3QgbmFtZQoKICAgIGxvY2FsIGluZm8gPSBkZWJ1Zy5nZXRpbmZv
IChlcnJvcl90aHJlYWQsIGZyYW1lLmRlcHRoKQogICAgaWYgaW5mbyBhbmQgaW5mby5mdW5jIHRo
ZW4KICAgICAgbG9jYWwgdXB2YWx1ZV9pbmRleCA9IDEKICAgICAgcmVwZWF0CiAgICAgICAgbG9j
YWwgbmFtZSwgdmFsdWUgPSBkZWJ1Zy5nZXR1cHZhbHVlIChpbmZvLmZ1bmMsIHVwdmFsdWVfaW5k
ZXgpCiAgICAgICAgaWYgbmFtZSB0aGVuCiAgICAgICAgICB0YWJsZS5pbnNlcnQgKHZhcmlhYmxl
cywgewogICAgICAgICAgICBrZXkgPSBuYW1lLAogICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLAog
ICAgICAgICAgfSkKICAgICAgICAgIHVwdmFsdWVfaW5kZXggPSB1cHZhbHVlX2luZGV4ICsgMQog
ICAgICAgIGVuZAogICAgICB1bnRpbCBub3QgbmFtZQogICAgZW5kCiAgZW5kCgogIC0tIHJlYnVp
bGQgc291cmNlIGxpbmVzCiAgbG9jYWwgc291cmNlID0gZnJhbWUuc291cmNlCiAgaWYgc291cmNl
IHRoZW4KICAgIGlmIHN0cmluZy5zdWIgKHNvdXJjZSwgMSwgMSkgPT0gJ0AnIHRoZW4KICAgICAg
bG9jYWwgZmlsZW5hbWUgPSBzdHJpbmcuc3ViIChzb3VyY2UsIDIsICNzb3VyY2UpCiAgICAgIHNv
dXJjZSA9IGZldGNoIChmaWxlbmFtZSkKICAgIGVuZAogICAgaWYgc291cmNlIGFuZCB0eXBlIChz
b3VyY2UpID09ICdzdHJpbmcnIHRoZW4KICAgICAgc291cmNlX2xpbmVzID0gZ2V0X2xpbmVzIChz
b3VyY2UpCiAgICBlbmQKICBlbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBlcnJvcl91cGRhdGUgKCkK
ICBsb2NhbCBsYXN0X2luZGV4ID0gY3VycmVudF9zdGFja19pbmRleAogIGlmIGJ0bnAgKDUpIG9y
IGtleXAgJ3NwYWNlJyB0aGVuCiAgICB1c2Vfc21hbGxfZm9udCA9IG5vdCB1c2Vfc21hbGxfZm9u
dAogIGVuZAogIGlmIGJ0bnAgKDIpIHRoZW4KICAgIGN1cnJlbnRfc3RhY2tfaW5kZXggPSBtYXRo
Lm1heCAoMSwgY3VycmVudF9zdGFja19pbmRleCAtIDEpCiAgICBzdGFja19zY3JvbGwgPSBtYXRo
Lm1pbiAoY3VycmVudF9zdGFja19pbmRleC0xLCBzdGFja19zY3JvbGwpCiAgZW5kCiAgaWYgYnRu
cCAoMykgdGhlbgogICAgY3VycmVudF9zdGFja19pbmRleCA9IG1hdGgubWluICgjc3RhY2tfZnJh
bWVzLCBjdXJyZW50X3N0YWNrX2luZGV4ICsgMSkKICAgIHN0YWNrX3Njcm9sbCA9IG1hdGgubWF4
ICgoY3VycmVudF9zdGFja19pbmRleCkgLSAoI3N0YWNrX2ZyYW1lcyAtIHN0YWNrX21heF9zY3Jv
bGwpLCBzdGFja19zY3JvbGwpCiAgZW5kCgogIGxvY2FsIF8sIF8sIGNsaWNrLCBfLCB3aGVlbCA9
IG1vdXNlICgpCiAgaWYgbW91c2Vfb3Zlcl9zdGFjayB0aGVuCiAgICBzdGFja19zY3JvbGwgPSBt
YXRoLm1heCAoMCwgbWF0aC5taW4gKHN0YWNrX3Njcm9sbCAtIHdoZWVsICogMiwgc3RhY2tfbWF4
X3Njcm9sbCkpCiAgZW5kCiAgc3RhY2tfc2Nyb2xsX3Ntb290aCA9IGFwcHJvYWNoIChzdGFja19z
Y3JvbGxfc21vb3RoLCBzdGFja19zY3JvbGwpCiAgaWYgbW91c2Vfb3Zlcl92YXJpYWJsZXMgdGhl
bgogICAgdmFyaWFibGVzX3Njcm9sbCA9IG1hdGgubWF4ICgwLCBtYXRoLm1pbiAodmFyaWFibGVz
X3Njcm9sbCAtIHdoZWVsICogMiwgdmFyaWFibGVzX21heF9zY3JvbGwpKQogIGVuZAogIHZhcmlh
Ymxlc19zY3JvbGxfc21vb3RoID0gYXBwcm9hY2ggKHZhcmlhYmxlc19zY3JvbGxfc21vb3RoLCB2
YXJpYWJsZXNfc2Nyb2xsKQoKICBjbGljayA9IGNsaWNrIH49IDAKICBpZiBjbGljayBhbmQgbm90
IG1vdXNlX3dhc19jbGlja2VkIHRoZW4KICAgIGlmIGhvdmVyZWRfc3RhY2tfaW5kZXggdGhlbgog
ICAgICBjdXJyZW50X3N0YWNrX2luZGV4ID0gaG92ZXJlZF9zdGFja19pbmRleAogICAgZW5kCiAg
ICBpZiBob3ZlcmVkX3ZhcmlhYmxlIGFuZCB0eXBlIChob3ZlcmVkX3ZhcmlhYmxlLnZhbHVlKSA9
PSAndGFibGUnIHRoZW4KICAgICAgaWYgaG92ZXJlZF92YXJpYWJsZS5jb250ZW50cyB0aGVuCiAg
ICAgICAgaG92ZXJlZF92YXJpYWJsZS5jb250ZW50cyA9IG5pbAogICAgICBlbHNlCiAgICAgICAg
bG9jYWwgY29udGVudHMgPSB7fQogICAgICAgIGhvdmVyZWRfdmFyaWFibGUuY29udGVudHMgPSBj
b250ZW50cwogICAgICAgIGZvciBrLHYgaW4gcGFpcnMgKGhvdmVyZWRfdmFyaWFibGUudmFsdWUp
IGRvCiAgICAgICAgICB0YWJsZS5pbnNlcnQgKGNvbnRlbnRzLCB7CiAgICAgICAgICAgIGtleSA9
IGssCiAgICAgICAgICAgIHZhbHVlID0gdiwKICAgICAgICAgIH0pCiAgICAgICAgZW5kCiAgICAg
ICAgc29ydCAoY29udGVudHMsIGNvbXBhcmVfa2V5cykKICAgICAgZW5kCiAgICBlbmQKICBlbmQK
ICBtb3VzZV93YXNfY2xpY2tlZCA9IGNsaWNrCgogIGlmIGN1cnJlbnRfc3RhY2tfaW5kZXggfj0g
bGFzdF9pbmRleCB0aGVuCiAgICByZWJ1aWxkKCkKICBlbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBl
cnJvcl9kcmF3ICgpCiAgbG9jYWwgcHJlZml4ID0gdXNlX3NtYWxsX2ZvbnQgYW5kICdcMDE0JyBv
ciAnJwogIGxvY2FsIGZvbnRfaGVpZ2h0ID0gKHVzZV9zbWFsbF9mb250IGFuZCA2IG9yIDExKQog
IGxvY2FsIG14LCBteSA9IG1vdXNlKCkKICBsb2NhbCBvdmVyX3NlY3Rpb24gPSBmYWxzZQogIGxv
Y2FsIHgwLCB5MCwgeCwgeQoKICBsb2NhbCBmdW5jdGlvbiBnb190byAobmV3X3gsIG5ld195KQog
ICAgeDAsIHkwID0gbmV3X3gsIG5ld195CiAgICB4LCB5ID0geDAsIHkwCiAgZW5kCgogIGxvY2Fs
IGZ1bmN0aW9uIHNlY3Rpb24gKHN4LCBzeSwgc3csIHNoKQogICAgb3Zlcl9zZWN0aW9uID0KICAg
ICAgbXggPj0gc3ggYW5kIG14IDwgc3ggKyBzdyBhbmQKICAgICAgbXkgPj0gc3kgYW5kIG15IDwg
c3kgKyBzaAogICAgY2xpcCAoc3gsIHN5LCBzdywgc2gpCiAgICBnb190byhzeCsyLCBzeSsyKQog
IGVuZAoKICBsb2NhbCBmdW5jdGlvbiBwcmludF9ob3Jpem9udGFsICh0ZXh0LCBjb2xvcikKICAg
IGxvY2FsIG5ld194LCBfbmV3X3kgPSBwcmludCAocHJlZml4IC4uIHRleHQsIHgsIHksIGNvbG9y
KQogICAgeCA9IG5ld194CiAgZW5kCgogIGxvY2FsIGZ1bmN0aW9uIHByaW50X2xpbmUgKHRleHQs
IGNvbG9yKQogICAgbG9jYWwgX25ld194LCBuZXdfeSA9IHByaW50IChwcmVmaXggLi4gdGV4dCwg
eCwgeSwgY29sb3IpCiAgICB4ID0geDAKICAgIHkgPSBuZXdfeQogIGVuZAoKICAtLSBkcmF3IHNl
dHVwCiAgY2xzICgwKQogIC0tIGxpZ2h0ZXIgZGFyayBncmF5IGZvciByZWFkYWJpbGl0eQogIHBh
bCAoNSwgMHhmZjcwNzA3MCwgMikKICBjb2xvciAoNSkKCiAgLS0gZXJyb3IgbWVzc2FnZQogIHNl
Y3Rpb24gKDAsIDAsIFcsIEgvMikKICBtb3VzZV9vdmVyX3N0YWNrID0gb3Zlcl9zZWN0aW9uCgog
IGxvY2FsIGxvY19wYXRoLCBsb2NfbGluZSwgZXJyID0gcGFyc2VfbWVzc2FnZV9mb3JfbG9jYXRp
b24gKGVycm9yX21lc3NhZ2UpCiAgaWYgbG9jX3BhdGggdGhlbgogICAgcHJpbnRfbGluZSAoJ2Vy
cm9yIGF0ICcgLi4gbG9jX3BhdGggLi4gJzonIC4uIGxvY19saW5lIC4uICc6JywgNikKICAgIHBy
aW50X2xpbmUgKCcgICcgLi4gZXJyLCA4KQogIGVsc2UKICAgIHByaW50X2xpbmUgKCdlcnJvcjon
LCA2KQogICAgcHJpbnRfbGluZSAoJyAgJyAuLiBlcnJvcl9tZXNzYWdlLCA4KQogIGVuZAoKICAt
LSBzdGFjayBmcmFtZXMKICBwcmludF9saW5lICgnc3RhY2s6JywgNikKICBzZWN0aW9uICgwLCB5
LCBXLCBILzIteSkKICBsb2NhbCBzdGFja190b3BfeSA9IHkKICB5ID0geSAtIHJvdW5kIChzdGFj
a19zY3JvbGxfc21vb3RoICogZm9udF9oZWlnaHQpCiAgbG9jYWwgbGFzdF9ob3ZlcmVkX3N0YWNr
X2luZGV4ID0gaG92ZXJlZF9zdGFja19pbmRleAogIGhvdmVyZWRfc3RhY2tfaW5kZXggPSBmYWxz
ZQogIGZvciBpLCBmcmFtZSBpbiBpcGFpcnMgKHN0YWNrX2ZyYW1lcykgZG8KICAgIGNvbG9yIChs
YXN0X2hvdmVyZWRfc3RhY2tfaW5kZXggPT0gaSBhbmQgNyBvcgogICAgICAgICAgIGN1cnJlbnRf
c3RhY2tfaW5kZXggPT0gaSBhbmQgNiBvciA1KQoKICAgbG9jYWwgeV9iZWZvcmUgPSB5CiAgICBw
cmludF9saW5lIChzdHJpbmcuZm9ybWF0ICgnICAlczolZCBpbiBmdW5jdGlvbiAlcycsCiAgICAg
IGZyYW1lLmZpbGVuYW1lLCBmcmFtZS5saW5lLCBmcmFtZS5mbl9uYW1lICkpCiAgICBpZiBvdmVy
X3NlY3Rpb24gdGhlbgogICAgICBpZiBteSA_PSB5X2JlZm9yZSBhbmQgbXkgPCB5IHRoZW4KICAg
ICAgICBob3ZlcmVkX3N0YWNrX2luZGV4ID0gaQogICAgICBlbmQKICAgIGVuZAogIGVuZAogIHN0
YWNrX21heF9zY3JvbGwgPSAjc3RhY2tfZnJhbWVzIC0gKEgvMiAtIHN0YWNrX3RvcF95KSAvIGZv
bnRfaGVpZ2h0CgogIGxvY2FsIGZyYW1lID0gc3RhY2tfZnJhbWVzIFtjdXJyZW50X3N0YWNrX2lu
ZGV4XQogIGlmIG5vdCBmcmFtZSB0aGVuCiAgICByZXR1cm4KICBlbmQKCiAgLS0gdmFyaWFibGVz
CiAgc2VjdGlvbiAoMCwgSC8yLCBXLzIsIEgvMikKICBtb3VzZV9vdmVyX3ZhcmlhYmxlcyA9IG92
ZXJfc2VjdGlvbgogIHByaW50X2xpbmUgKCd2YXJpYWJsZXM6JywgNikKICBzZWN0aW9uICgwLCB5
LCBXLzIsIEgteSkKICBsb2NhbCB2YXJpYWJsZXNfdG9wX3kgPSB5CiAgeSA9IHkgLSByb3VuZCAo
dmFyaWFibGVzX3Njcm9sbF9zbW9vdGggKiBmb250X2hlaWdodCkKICBsb2NhbCBsYXN0X2hvdmVy
ZWRfdmFyaWFibGUgPSBob3ZlcmVkX3ZhcmlhYmxlCiAgaG92ZXJlZF92YXJpYWJsZSA9IGZhbHNl
CiAgbG9jYWwgdmFyaWFibGVfY291bnQgPSAwCiAgbG9jYWwgZnVuY3Rpb24gZHJhd192YXJpYWJs
ZSAodmFyaWFibGUsIGluZGVudCkKICAgIHZhcmlhYmxlX2NvdW50ID0gdmFyaWFibGVfY291bnQg
KyAxCiAgICBsb2NhbCBob3ZlcmVkID0gdmFyaWFibGUgPT0gbGFzdF9ob3ZlcmVkX3ZhcmlhYmxl
CiAgICBsb2NhbCB5X2JlZm9yZSA9IHkKICAgIHByaW50X2hvcml6b250YWwgKGluZGVudCAuLiB2
YXJpYWJsZS5rZXksIGhvdmVyZWQgYW5kIDcgb3IgNikKICAgIHByaW50X2hvcml6b250YWwgKCc6
ICcsIHZhcmlhYmxlID09IGxhc3RfaG92ZXJlZF92YXJpYWJsZSBhbmQgNyBvciA1KQogICAgcHJp
bnRfbGluZSAoc2FmZV90b3N0cmluZyh2YXJpYWJsZS52YWx1ZSkpCgogICAgaWYgb3Zlcl9zZWN0
aW9uIGFuZCB0eXBlICh2YXJpYWJsZS52YWx1ZSkgPT0gJ3RhYmxlJyB0aGVuCiAgICAgIGlmIG14
ID49IDAgYW5kIG14IDwgVy8yIGFuZCBteSA_PSB5X2JlZm9yZSBhbmQgbXkgPCB5IHRoZW4KICAg
ICAgICBob3ZlcmVkX3ZhcmlhYmxlID0gdmFyaWFibGUKICAgICAgZW5kCiAgICBlbmQKCiAgICBp
ZiB2YXJpYWJsZS5jb250ZW50cyB0aGVuCiAgICAgIGZvciBfLCB2IGluIGlwYWlycyAodmFyaWFi
bGUuY29udGVudHMpIGRvCiAgICAgICAgZHJhd192YXJpYWJsZSAodiwgaW5kZW50IC4uICcgICcp
CiAgICAgIGVuZAogICAgZW5kCiAgZW5kCiAgZm9yIF8sIHZhcmlhYmxlIGluIGlwYWlycyAodmFy
aWFibGVzKSBkbwogICAgZHJhd192YXJpYWJsZSAodmFyaWFibGUsICcgICcpCiAgZW5kCiAgdmFy
aWFibGVzX21heF9zY3JvbGwgPSB2YXJpYWJsZV9jb3VudCAtIChIIC0gdmFyaWFibGVzX3RvcF95
KSAvIGZvbnRfaGVpZ2h0CgogIC0tIHNvdXJjZQogIHNlY3Rpb24gKFcvMiwgSC8yLCBXLzIsIEgv
MikKICBwcmludF9saW5lICgnc291cmNlIG9mICcgLi4gZnJhbWUucGF0aCAuLiAnOicsIDYpCiAg
bG9jYWwgY29udGV4dCA9IHVzZV9zbWFsbF9mb250IGFuZCAxMCBvciA1CiAgbG9jYWwgaV9taW4g
PSBtYXRoLm1heCAoMSwgZnJhbWUubGluZSAtIGNvbnRleHQpCiAgbG9jYWwgaV9tYXggPSBtYXRo
Lm1pbiAoI3NvdXJjZV9saW5lcywgZnJhbWUubGluZSArIGNvbnRleHQpCiAgZm9yIGkgPSBpX21p
biwgaV9tYXggZG8KICAgIGNvbG9yIChpID09IGZyYW1lLmxpbmUgYW5kIDYgb3IgNSkKICAgIHBy
aW50X2hvcml6b250YWwgKHN0cmluZy5mb3JtYXQgKCclNGQgJywgaSkpCiAgICBwcmludF9saW5l
IChzb3VyY2VfbGluZXMgW2ldKQogIGVuZAoKICBjbGlwICgpCmVuZAoKLS0tLSB0YWtpbmcgb3Zl
ciBkdXJpbmcgZXJyb3JzIC0tLS0tLS0tLS0tLS0tLS0tLS0KCmxvY2FsIGZ1bmN0aW9uIHJlc2V0
ICgpCiAgLS0gYmFzZWQgb24gcmVzZXQoKSBmcm9tIC9zeXN0ZW0vbGliL2hlYWQubHVhCiAgLS0g
c2VlIHRoYXQgZm4gZm9yIGluZm8KICBub3RlICgpCiAgLS0gcGljb3Ryb24gc2VnZmF1bHRzIGlm
IHdlIGNhbGwgY2xpcCgpIGR1cmluZyBpbml0CiAgaWYgaW5pdF9kb25lIHRoZW4KICAgIGNsaXAg
KCkKICBlbmQKICBjYW1lcmEgKCkKICBwYWwgKCkKICBwYWx0ICgpCiAgbWVtc2V0ICgweDU1MWYs
IDAsIDkpCiAgcG9rZSAoMHg1NTA4LCAweDNmKQogIHBva2UgKDB4NTUwOSwgMHgzZikKICBwb2tl
ICgweDU1MGEsIDB4M2YpCiAgcG9rZSAoMHg1NTBiLCAweDAwKQogIGNvbG9yICg2KQogIGZpbGxw
ICgpCiAgcG9rZSAoMHg1ZjU2LCAweDQwKQogIHBva2UgKDB4NWY1NywgMHg1NikKICBwb2tlICgw
eDQwMDAsIGdldCAoZmV0Y2giL3N5c3RlbS9mb250cy9saWwuZm9udCIpKQogIHBva2UgKDB4NTYw
MCwgZ2V0IChmZXRjaCIvc3lzdGVtL2ZvbnRzL3A4LmZvbnQiKSkKICBwb2tlICgweDU2MDYsIHBl
ZWsgKDB4NTYwMCkgKiA0KQogIHBva2UgKDB4NTYwNSwgMHgyKQogIHBva2UgKDB4NWYyOCwgNjQp
CiAgcG9rZSAoMHg1ZjI5LCA2NCkKZW5kCgpsb2NhbCBmdW5jdGlvbiBvbl9lcnJvciAodGhyZWFk
LCBtZXNzYWdlKQogIC0tIGRvIHRoaXMgZmlyc3QgaW4gY2FzZSB3ZSBoaXQgYW5vdGhlciBlcnJv
cgogIGVycm9yX3RyYWNlYmFjayA9IGRlYnVnLnRyYWNlYmFjayAodGhyZWFkLCBtZXNzYWdlKQog
IHByaW50aCAoZXJyb3JfdHJhY2ViYWNrKQoKICBlcnJvcl90aHJlYWQgPSB0aHJlYWQKICBlcnJv
cl9tZXNzYWdlID0gdG9zdHJpbmcgKG1lc3NhZ2UpCiAgcmVzZXQgKCkKICByZWJ1aWxkICgpCiAg
LS0ganVtcCB0byB0aGUgcHJvcGVyIHN0YWNrIGZyYW1lIGlmIHdlIGNhbgogIGxvY2FsIGxvY19w
YXRoLCBsb2NfbGluZSA9IHBhcnNlX21lc3NhZ2VfZm9yX2xvY2F0aW9uIChlcnJvcl9tZXNzYWdl
KQogIGZvciBpLCBmcmFtZSBpbiBpcGFpcnMgKHN0YWNrX2ZyYW1lcykgZG8KICAgIGlmIGZyYW1l
LnBhdGggPT0gbG9jX3BhdGggYW5kIGZyYW1lLmxpbmUgPT0gbG9jX2xpbmUgdGhlbgogICAgICBj
dXJyZW50X3N0YWNrX2luZGV4ID0gaQogICAgICByZWJ1aWxkICgpCiAgICAgIGJyZWFrCiAgICBl
bmQKICBlbmQKZW5kCgotLS0tIGluc3RhbGwgbWFpbiBldmVudHMgdGhhdCBjYXRjaCBlcnJvcnMg
LS0tLS0tLQoKbG9jYWwgdXNlcl9pbml0ID0gcmF3Z2V0IChfRywgJ19pbml0JykKbG9jYWwgdXNl
cl91cGRhdGUgPSByYXdnZXQgKF9HLCAnX3VwZGF0ZScpCmxvY2FsIHVzZXJfZHJhdyA9IHJhd2dl
dCAoX0csICdfZHJhdycpCgphc3NlcnQgKHVzZXJfZHJhdyBhbmQgdXNlcl91cGRhdGUsCiAgJ3Bs
ZWFzZSBpbmNsdWRlIGluc3RhbGxfZXJyb3JfaGFuZGxlciBhZnRlciBkZWZpbmluZyBib3RoIF91
cGRhdGUgYW5kIF9kcmF3JykKCmxvY2FsIGZ1bmN0aW9uIGNhbGxfZXJyb3JfZXZlbnQgKGZuLCAu
Li4pCiAgLS0gaWYgdGhlcmUncyBhbiBlcnJvciBpbiBvdXIgdXBkYXRlIG9yIGRyYXcsIHRocm93
IHRoZQogIC0tIG9yaWdpbmFsIGVycm9yIGFzIHdlbGwgYXMgdGhlIG5ldyBlcnJvcgogIGxvY2Fs
IHN1Y2Nlc3MsIGVyciA9IHBjYWxsIChmbiwgLi4uKQogIGlmIG5vdCBzdWNjZXNzIHRoZW4KICAg
IGVycm9yIChlcnJvcl90cmFjZWJhY2sgLi4gJ1xuXG5lcnJvciBkdXJpbmcgZXJyb3IgaGFuZGxp
bmc6ICcgLi4gdG9zdHJpbmcgKGVycikpCiAgZW5kCmVuZAoKbG9jYWwgZnVuY3Rpb24gY2FsbF9w
cm90ZWN0ZWQgKGZuKQogIC0tIG5lZWQgdG8gdXNlIGNvcmVzdW1lIGV0Yy4gYW5kIG5vdCBjb3Jv
dXRpbmUucmVzdW1lIGV0Yy4KICAtLSBmb3IgcGljb3Ryb24gY29tcGF0aWJpbGl0eQogIGxvY2Fs
IHRocmVhZCA9IGNvY3JlYXRlIChmbikKICBsb2NhbCBzdWNjZXNzLCBtZXNzYWdlID0gY29yZXN1
bWUodGhyZWFkKQogIGlmIGNvc3RhdHVzICh0aHJlYWQpIH49ICdkZWFkJyB0aGVuCiAgICBjYWxs
X2Vycm9yX2V2ZW50IChvbl9lcnJvciwgdGhyZWFkLCAnc2V0dXBfZXJyb3JfZGlzcGxheS5sdWE6
IF91cGRhdGUgYW5kIF9kcmF3IHNob3VsZG5cJ3QgeWllbGQnKQogIGVuZAogIGlmIG5vdCBzdWNj
ZXNzIHRoZW4KICAgIGNhbGxfZXJyb3JfZXZlbnQgKG9uX2Vycm9yLCB0aHJlYWQsIG1lc3NhZ2Up
CiAgZW5kCmVuZAoKaWYgdXNlcl9pbml0IHRoZW4KICBmdW5jdGlvbiBfaW5pdCAoKQogICAgY2Fs
bF9wcm90ZWN0ZWQgKHVzZXJfaW5pdCkKICAgIGluaXRfZG9uZSA9IHRydWUKICBlbmQKZWxzZQog
IGluaXRfZG9uZSA9IHRydWUKZW5kCgpmdW5jdGlvbiBfdXBkYXRlICgpCiAgaWYgZXJyb3JfdGhy
ZWFkIHRoZW4KICAgIGNhbGxfZXJyb3JfZXZlbnQgKGVycm9yX3VwZGF0ZSkKICBlbHNlCiAgICBj
YWxsX3Byb3RlY3RlZCAodXNlcl91cGRhdGUpCiAgZW5kCmVuZAoKZnVuY3Rpb24gX2RyYXcgKCkK
ICBpZiBlcnJvcl90aHJlYWQgdGhlbgogICAgY2FsbF9lcnJvcl9ldmVudCAoZXJyb3JfZHJhdykK
ICBlbHNlCiAgICBjYWxsX3Byb3RlY3RlZCAodXNlcl9kcmF3KQogIGVuZAplbmQ=
:: lib/gavel/
:: lib/gavel/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTA2IDAxOjM4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSJdXWx6NAAEAAAAAwAAADBuaWw=
:: lib/gavel/algebra.lua
b64$LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQotLSBHQVZFTDogR0VPTUVUUklDIEFMR0VCUkEgVkVDVE9SIExJQlJBUlkK
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLQotLSBUaGlzIHdvcmsgwqkgMjAyNCBieSBKYXNvbiBEZUxhYXQgaXMgbGljZW5z
ZWQgdW5kZXIgQ0MgQlkgNC4wLiBUbwotLSB2aWV3IGEgY29weSBvZiB0aGlzIGxpY2Vuc2UsIHZp
c2l0Ci0tIGh0dHBzOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS80LjAvCgotLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0K
LS0gVXRpbGl0eSBmdW5jdGlvbnMgCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKLS0gJ3N1YicgZnVuY3Rpb24gd2hpY2ggd29ya3Mg
b24gYXJyYXlzIGFzIHdlbGwgYXMgc3RyaW5ncy4KZG8KICAgbG9jYWwgX3N1YiA9IHN1YgogICBm
dW5jdGlvbiBzdWIobHN0LCBpLCBqKQogICAgICBpZiB0eXBlKGxzdCkgPT0gJ3N0cmluZycgdGhl
bgogICAgICAgICByZXR1cm4gX3N1Yihsc3QsIGksIGopCiAgICAgIGVsc2UKICAgICAgICAgbG9j
YWwgciA9IHt9CiAgICAgICAgIGZvciBuPWksaiBvciAjbHN0IGRvCiAgICAgICAgICAgIGFkZChy
LCBsc3Rbbl0pCiAgICAgICAgIGVuZAogICAgICAgICByZXR1cm4gcgogICAgICBlbmQKICAgZW5k
CmVuZAoKLS0gUGFkIHRoZSBlbmQgb2Ygc3RyaW5nICdzJyB3aXRoIHNwYWNlcyB0byBhIHRvdGFs
IGxlbmd0aCAnbGVuJy4gSWYKLS0gJ3MnIGlmIGxvbmdlciB0aGFuICdsZW4nIGl0IHdpbGwgYmUg
c2hvcnRlbmVkLgpmdW5jdGlvbiBwYWQocywgbGVuKQogICBmb3IgaT0xLGxlbiBkbwogICAgICBz
IC4uPSAnICcKICAgZW5kCiAgIHJldHVybiBzdWIocywgMSwgbGVuKQplbmQKCi0tIFJlcGVhdCBz
dHJpbmcgJ3MnLCAncmVwcycgdGltZXMuCmZ1bmN0aW9uIHN0cl9yZXBlYXQocywgcmVwcykKICAg
bG9jYWwgciA9ICcnCiAgIGZvciBpPTEscmVwcyBkbwogICAgICByIC4uPSBzCiAgIGVuZAogICBy
ZXR1cm4gcgplbmQKCi0tIENvbWJpbmF0b3JpYWwgY2hvb3NlIGZ1bmN0aW9uLgpmdW5jdGlvbiBj
aG9vc2UobiwgaykKICAgbG9jYWwgdG9wLCBib3R0b20gPSAxLCAxCiAgIGxvY2FsIGxpbSA9IG1h
eChrLCBuLWspCiAgIGZvciBpPTEsbiBkbwogICAgICBpZiBpIDw9IG4gLSBsaW0gdGhlbgogICAg
ICAgICBib3R0b20gKj0gaQogICAgICBlbHNlaWYgaSA_IGxpbSB0aGVuCiAgICAgICAgIHRvcCAq
PSBpCiAgICAgIGVuZAogICBlbmQKICAgcmV0dXJuIHRvcCAvIGJvdHRvbQplbmQKCi0tIENvbWJp
bmVzIHR3byBhcnJheXMgaW50byBhIHNpbmdsZSBhcnJheS4KZnVuY3Rpb24gY29uY2F0KGwxLCBs
MikKICAgbG9jYWwgciA9IHt9CiAgIGZvcmVhY2gobDEsIGZ1bmN0aW9uKGwpIGFkZChyLCBsKSBl
bmQpCiAgIGZvcmVhY2gobDIsIGZ1bmN0aW9uKGwpIGFkZChyLCBsKSBlbmQpCiAgIHJldHVybiBy
CmVuZAoKLS0gUmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgdGFibGUgJ3RibCcgYW5kIGluZGV4
ICdrZXknIGlmIGl0Ci0tIGV4aXN0cy4gSWYgJ3RibFtrZXldJyBkb2VzIG5vdCBleGlzdCwgcmV0
dXJucyAnZGVmYXVsdCcgaW5zdGVhZC4KZnVuY3Rpb24gZ2V0KHRibCwga2V5LCBkZWZhdWx0KQog
ICBsb2NhbCB2YWx1ZSA9IHRibFtrZXldCiAgIGlmIG5vdCB2YWx1ZSB0aGVuCiAgICAgIHJldHVy
biBkZWZhdWx0CiAgIGVuZAogICByZXR1cm4gdmFsdWUKZW5kCgotLSBDb252ZXJ0cyB0aGUgYXJy
YXkgJ2xzdCcgdG8gYSBzdHJpbmcgaW5zZXJ0aW5nIHRoZSBzdHJpbmcgJ3NlcCcKLS0gYmV0d2Vl
biBlYWNoIGVsZW1lbnQuCmZ1bmN0aW9uIGpvaW4obHN0LCBzZXApCiAgIHNlcCA9IHNlcCBvciAn
JwogICBsb2NhbCBzID0gdG9zdHIobHN0WzFdKQogICBmb3IgaT0yLCNsc3QgZG8KICAgICAgcyAu
Lj0gc2VwLi50b3N0cihsc3RbaV0pCiAgIGVuZAogICByZXR1cm4gcwplbmQKCi0tIFJldHVybnMg
YWxsIHBvc3NpYmxlIHN1YnNldHMgb2YgdGhlIGdpdmVuIGFycmF5ICdsc3QnLgpmdW5jdGlvbiBw
b3dlcl9zZXQobHN0KQogICBsb2NhbCBwb3dfc2V0ID0ge3t9fQogICBsb2NhbCBuID0gI2xzdAog
ICBsb2NhbCBtID0gMl5uIC0gMQogICBmb3IgaT0xLG0gZG8KICAgICAgbG9jYWwgcyA9IHt9CiAg
ICAgIGZvciBqPTAsbi0xIGRvCiAgICAgICAgIGlmIChpPj5qKSYxID09IDEgdGhlbgogICAgICAg
ICAgICBhZGQocywgbHN0W2orMV0pCiAgICAgICAgIGVuZAogICAgICBlbmQKICAgICAgYWRkKHBv
d19zZXQsIHMpCiAgIGVuZAogICByZXR1cm4gcG93X3NldAplbmQKCi0tIEVORCBVdGlsaXR5IGZ1
bmN0aW9ucyAKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tCgoKCgoKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLSBHZW9tZXRyaWMgQWxnZWJyYQotLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KZG8KICAgLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICAtLSBIZWxwZXIgZnVuY3Rp
b25zIAogICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgogICAtLSBO
b3QgYSBnZW5lcmFsIHNvcnRpbmcgYWxnb3JpdGhtLiBJdCdzIHNwZWNpZmljYWxseSB0byBwcm9w
ZXJseQogICAtLSBzb3J0IHRoZSBtdWx0aXZlY3RvciBiYXNpcyBjb21wb25lbnRzLgogICBsb2Nh
bCBmdW5jdGlvbiBzb3J0KGxzdCkKICAgICAgZm9yIGk9MSwjbHN0IGRvCiAgICAgICAgIGZvciBq
PTEsI2xzdC1pIGRvCiAgICAgICAgICAgIGlmICNsc3Rbal0gPiAjbHN0W2orMV0gb3IKICAgICAg
ICAgICAgICAgKCNsc3Rbal0gPT0gI2xzdFtqKzFdIGFuZCBsc3Rbal0gPiBsc3RbaisxXSkKICAg
ICAgICAgICAgdGhlbgogICAgICAgICAgICAgICBsc3Rbal0sIGxzdFtqKzFdID0gbHN0W2orMV0s
IGxzdFtqXQogICAgICAgICAgICBlbmQKICAgICAgICAgZW5kCiAgICAgIGVuZAogICAgICByZXR1
cm4gbHN0CiAgIGVuZAoKICAgLS0gR2VuZXJhdGVzIHRoZSBiYXNpcyBjb21wb25lbnQgbmFtZXM6
IGUxLCBlMiwgZTEyLCBldGMuCiAgIGxvY2FsIGZ1bmN0aW9uIHRvX2Jhc2lzX25hbWUobHN0KQog
ICAgICBpZiAjbHN0ID09IDAgdGhlbgogICAgICAgICByZXR1cm4gJ3NjYWxhcicKICAgICAgZWxz
ZQogICAgICAgICByZXR1cm4gJ2UnLi5qb2luKGxzdCwgJycpCiAgICAgIGVuZAogICBlbmQKCiAg
IC0tW1sKICAgICAgTXVsdGlwbGllcyB0d28gbXVsdGl2ZWN0b3IgYmFzaXMgY29tcG9uZW50cy4g
VGhpcyBpcyBvbmx5IGRvbmUKICAgICAgb25jZSBmb3IgZXZlcnkgcGFpciBvZiBiYXNpcyBjb21w
b25lbnRzIHdoZW4gZ2VuZXJhdGluZyB0aGUKICAgICAgYWxnZWJyYS4gQWZ0ZXIgdGhhdCBtdWx0
aXZlY3RvciBtdWx0aXBsaWNhdGlvbiBpcyBoYW5kbGVkIGJ5CiAgICAgIGRpcmVjdGx5IGxvb2tp
bmcgdXAgdGhlIG11dGlwbGljYXRpb24gdGFibGUuCgogICBdXQogICBsb2NhbCBmdW5jdGlvbiBt
dWx0aXBseV9iYXNpcyhhLCBiLCBzcXVhcmVzKQogICAgICBsb2NhbCB2YWwgPSAxCiAgICAgIGxv
Y2FsIGVsID0gY29uY2F0KGEsIGIpCiAgICAgIGxvY2FsIG51bV9zd2FwcyA9IDAKICAgICAgZm9y
IGk9MSwjZWwgZG8KICAgICAgICAgZm9yIGo9I2VsLGkrMSwtMSBkbwogICAgICAgICAgICBpZiBl
bFtqXSA8IGVsW2otMV0gdGhlbgogICAgICAgICAgICAgICBlbFtqXSwgZWxbai0xXSA9IGVsW2ot
MV0sIGVsW2pdCiAgICAgICAgICAgICAgIG51bV9zd2FwcyArPSAxCiAgICAgICAgICAgIGVuZAog
ICAgICAgICBlbmQKICAgICAgZW5kCiAgICAgIGxvY2FsIG5ld19lbCA9IHt9CiAgICAgIGxvY2Fs
IGkgPSAxCiAgICAgIHdoaWxlIGkgPD0gI2VsIGRvCiAgICAgICAgIGlmIGkgPT0gI2VsIG9yIGVs
W2ldIH49IGVsW2krMV0gdGhlbgogICAgICAgICAgICBhZGQobmV3X2VsLCBlbFtpXSkKICAgICAg
ICAgICAgaSArPSAxCiAgICAgICAgIGVsc2UKICAgICAgICAgICAgdmFsICo9IHNxdWFyZXNbZWxb
aV1dCiAgICAgICAgICAgIGkgKz0gMgogICAgICAgICBlbmQKICAgICAgZW5kCiAgICAgIC0tIHt2
YWx1ZSwgY29tcG9uZW50LCBncmFkZX0KICAgICAgcmV0dXJuIHt2YWwqKC0xKV5udW1fc3dhcHMs
IHRvX2Jhc2lzX25hbWUobmV3X2VsKSwgI25ld19lbH0KICAgZW5kCgogICAtLSBHZW5lcmF0ZXMg
dGhlIGFsZ2VicmEncyBtdWx0aXBsaWNhdGlvbiB0YWJsZSBiYXNlZCBvbiB0aGUgZ2l2ZW4KICAg
LS0gYmFzaXMgdmVjdG9ycyBhbmQgdGhlaXIgc3F1YXJlcy4KICAgbG9jYWwgZnVuY3Rpb24gZ2Vu
ZXJhdGVfbXVsdGlwbGljYXRpb25fdGFibGUoYmFzaXMsIHNxdWFyZXMpCiAgICAgIGxvY2FsIHRi
bCA9IHt9CiAgICAgIGZvciBhIGluIGFsbChiYXNpcykgZG8KICAgICAgICAgbG9jYWwgbmFtZV9h
ID0gdG9fYmFzaXNfbmFtZShhKQogICAgICAgICBmb3IgYiBpbiBhbGwoYmFzaXMpIGRvCiAgICAg
ICAgICAgIGxvY2FsIG5hbWVfYiA9IHRvX2Jhc2lzX25hbWUoYikKICAgICAgICAgICAgbG9jYWwg
cm93ID0gZ2V0KHRibCwgbmFtZV9hLCB7fSkKICAgICAgICAgICAgcm93W25hbWVfYl0gPSBtdWx0
aXBseV9iYXNpcyhhLCBiLCBzcXVhcmVzKQogICAgICAgICAgICB0YmxbbmFtZV9hXSA9IHJvdwog
ICAgICAgICBlbmQKICAgICAgZW5kCiAgICAgIHJldHVybiB0YmwKICAgZW5kCgogICAtLSBFeHRy
YWN0cyBhbmQgc29ydHMgdGhlIHVuaXF1ZSBiYXNpcyBjb21wb25lbnRzIGZyb20gdGhlCiAgIC0t
IGdlbmVyYXRlZCBtdWx0aXBsaWNhdGlvbiB0YWJsZS4KICAgbG9jYWwgZnVuY3Rpb24gZXh0cmFj
dF9iYXNpcyh0YmwpCiAgICAgIGxvY2FsIGIgPSB7fQogICAgICBmb3IgayxfIGluIHBhaXJzKHRi
bCkgZG8KICAgICAgICAgYWRkKGIsIGspCiAgICAgIGVuZAogICAgICBkZWwoYiwgJ3NjYWxhcicp
CiAgICAgIHJldHVybiBjb25jYXQoeydzY2FsYXInfSwgc29ydChiKSkKICAgZW5kCgogICAtLSBU
aGlzIG1heSBuZWVkIHRvIGJlIGNoYW5nZWQgYXQgc29tZSBwb2ludC4gSXQgYXNzdW1lcyBmZXdl
ciB0aGFuCiAgIC0tIDEwIGRpbWVuc2lvbnMgd2hpY2ggc2VlbXMgcmVhc29uYWJsZSBidXQgcGVv
cGxlIGRvIHdlaXJkIHRoaW5ncwogICAtLSBzby4uLgogICBsb2NhbCBmdW5jdGlvbiBncmFkZShi
YXNlKQogICAgICBpZiBiYXNlID09ICdzY2FsYXInIHRoZW4KICAgICAgICAgcmV0dXJuIDAKICAg
ICAgZWxzZQogICAgICAgICByZXR1cm4gI2Jhc2UgLSAxCiAgICAgIGVuZAogICBlbmQKCiAgIC0t
IEVORCBIZWxwZXIgZnVuY3Rpb25zIAogICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tCgoKCgoKCiAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KICAgLS0gRnVuY3Rpb25zIG9uIG11bHRpdmVjdG9ycwogICAtLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgIGxvY2FsIG12X2Z1bmN0aW9ucyA9IHsKICAgICAgLS1b
WwoKICAgICAgICAgQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBtYWduaXR1ZGUgb2YgYQogICAgICAg
ICBtdWx0aXZlY3Rvci4gCgogICAgICAgICBSZXR1cm5zIGEgTHVhICdudW1iZXInIG5vdCBhIG11
bHRpdmVjdG9yLgoKICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICAgICAgICBOb3RlOiAnbWFnbml0dWRlJyBpcyBwcm9i
YWJseSB0aGUgd3JvbmcgbmFtZSBmb3IgdGhlc2UgdHdvCiAgICAgICAgIGZ1bmN0aW9ucyBidXQg
SSdtIG5vdCBzdXJlIHdoYXQgYSBiZXR0ZXIgb25lIHdvdWxkIGJlLiBGb3IKICAgICAgICAgdmVj
dG9ycyBpbiBFdWNsaWRlYW4gc3BhY2UgdGhleSBkbyBjYWxjdWxhdGUgdGhlIG1hZ25pdHVkZQog
ICAgICAgICBidXQgSSdtIG5vdCBzdXJlIHRoYXQncyB0ZWNobmljYWxseSB0aGUgY29ycmVjdCB0
ZXJtIGZvcgogICAgICAgICBnZW5lcmFsIG11bHRpZWN0b3JzIGFuZCBtYXliZSBub3QgZXZlbiBm
b3IgdmVjdG9ycyBpbgogICAgICAgICBub24tRXVjbGlkZWFuIHNwYWNlcy4KICAgICAgICAgLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoK
ICAgICAgXV0KICAgICAgbWFnbml0dWRlMiA9IGZ1bmN0aW9uKHNlbGYpCiAgICAgICAgIHJldHVy
biAoc2VsZipzZWxmOnJldmVyc2UoKSkuc2NhbGFyCiAgICAgIGVuZCwKICAgICAgCiAgICAgIG1h
Z25pdHVkZSA9IGZ1bmN0aW9uKHNlbGYpCiAgICAgICAgIHJldHVybiBzcXJ0KHNlbGY6bWFnbml0
dWRlMigpKQogICAgICBlbmQsCiAgICAgIAogICAgICBub3JtYWxpemUgPSBmdW5jdGlvbihzZWxm
KQogICAgICAgICByZXR1cm4gc2VsZiAvIHNlbGY6bWFnbml0dWRlKCkKICAgICAgZW5kLAoKCgog
ICAgICAtLVtbCiAgICAgICAgIFRoZSByZXZlcnNlIG9mIGEgbXVsdGl2ZWN0b3IgaXMgdGhlIG11
bHRpdmVjdG9yIG9idGFpbmVkIGJ5CiAgICAgICAgIHJldmVyc2luZyB0aGUgY29tcG9zaXRpb24g
b3JkZXIgb2YgaXRzIGNvbXBvbmVudHMuIEZvcgogICAgICAgICBpbnN0YW5jZSwgZ2l2ZW4gdGhl
IG11bHRpdmVjdG9yIHYgPSAxICsgMmUxICsgM2UyICsgNGUxMiwgaXRzCiAgICAgICAgIHJldmVy
c2UgaXMKCiAgICAgICAgICAgIHZfciA9IDEgKyAyZTEgKyAzZTIgKyA0ZTIxLgoKICAgICAgICAg
VGhlIGJpdmVjdG9yIGNvbXBvbmVudCBlMTIgaXMgdGhlIG9ubHkgcmV2ZXJzaWJsZSBvbmUgYW5k
IGR1ZQogICAgICAgICB0byB0aGUgYW50aS1jb21tdXRhdGl2aXR5IG9mIHRoZSB3ZWRnZSBwcm9k
dWN0IG1lYW5zIHRoYXQKCiAgICAgICAgICAgIHZfciA9IDEgKyAyZTEgKyAzZTIgLSA0ZTEyLgog
ICAgICAgICAKICAgICAgXV0KICAgICAgcmV2ZXJzZSA9IGZ1bmN0aW9uKHNlbGYpCiAgICAgICAg
IGxvY2FsIG12ID0ge30KICAgICAgICAgZm9yIGssdiBpbiBwYWlycyhzZWxmKSBkbwogICAgICAg
ICAgICBpZiAoZ3JhZGUoaykgJSA0KSBcIDIgPT0gMSB0aGVuCiAgICAgICAgICAgICAgIG12W2td
ID0gLTEqdgogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgIG12W2tdID0gdgogICAgICAg
ICAgICBlbmQKICAgICAgICAgZW5kCiAgICAgICAgIHJldHVybiBzZXRtZXRhdGFibGUobXYsIGdl
dG1ldGF0YWJsZShzZWxmKSkKICAgICAgZW5kLAoKCgogICAgICAtLVtbCiAgICAgICAgIENhbGN1
bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBtdWx0aXZlY3Rvci4gTm90ZSB0aGF0LCBpbiBzb21lCiAg
ICAgICAgIGFsZ2VicmFzLCBpbnZlcnNlcyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gZXhpc3QuCgog
ICAgICAgICBJZiAndScgYW5kICd2JyBhcmUgbXVsdGl2ZWN0b3JzIHRoZW4gJ3UnIGlzIHRoZSBp
bnZlcnNlIG9mCiAgICAgICAgICd2JywgYW5kIHZpY2UgdmVyc2EsIGlmCgogICAgICAgICB1KnYg
PT0gdip1ID09IDEuCgogICAgICBdXQogICAgICBpbnZlcnNlID0gZnVuY3Rpb24oc2VsZikKICAg
ICAgICAgcmV0dXJuIHNlbGY6cmV2ZXJzZSgpIC8gc2VsZjptYWduaXR1ZGUyKCkKICAgICAgZW5k
LAoKICAgICAgLS1bWwoKICAgICAgICAgQXBwbGllcyB0aGUgdHJhbnNmb3JtYXRpb24gJ3QnIHRv
IHRoZSBtdWx0aXZlY3Rvci4gIElmICdyZXYnCiAgICAgICAgIGlzIHRydWUsIGFwcGxpZXMgdGhl
IHRyYW5zZm9ybWF0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlciwKICAgICAgICAgcmV2ZXJzaW5n
IHRoZSB0cmFuc2Zvcm1hdGlvbjogQ2xvY2t3aXNlIHJvdGF0aW9ucyBiZWNvbWUKICAgICAgICAg
Y291bnRlci1jbG9ja3dpc2Ugcm90YXRpb25zLCBldGMuCgogICAgICBdXQogICAgICB0cmFuc2Zv
cm0gPSBmdW5jdGlvbihzZWxmLCB0LCByZXYpCiAgICAgICAgIGlmIHJldiB0aGVuCiAgICAgICAg
ICAgIHJldHVybiB0OnJldmVyc2UoKSpzZWxmKnQKICAgICAgICAgZWxzZQogICAgICAgICAgICBy
ZXR1cm4gdCpzZWxmKnQ6cmV2ZXJzZSgpCiAgICAgICAgIGVuZAogICAgICBlbmQsCgogICAgICBn
cmFkZSA9IGZ1bmN0aW9uKHNlbGYsIG4pCiAgICAgICAgIGxvY2FsIG12ID0ge30KICAgICAgICAg
Zm9yIGssdiBpbiBwYWlycyhzZWxmKSBkbwogICAgICAgICAgICBpZiBncmFkZShrKSA9PSBuIHRo
ZW4KICAgICAgICAgICAgICAgbXZba10gPSB2CiAgICAgICAgICAgIGVuZAogICAgICAgICBlbmQK
ICAgICAgICAgcmV0dXJuIHNldG1ldGF0YWJsZShtdiwgZ2V0bWV0YXRhYmxlKHNlbGYpKQogICAg
ICBlbmQsCgogICAgICBpc196ZXJvID0gZnVuY3Rpb24oc2VsZikKICAgICAgICAgZm9yIGssdiBp
biBwYWlycyhzZWxmKSBkbwogICAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICAgZW5kCiAg
ICAgICAgIHJldHVybiB0cnVlCiAgICAgIGVuZAogICB9CgogICAtLSBFTkQgRnVuY3Rpb25zIG9u
IG11bHRpdmVjdG9ycwogICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
CgoKCgoKCgogICAtLVtbCiAgICAgIFRoZSBhbGdlYnJhIG9iamVjdCBjb250YWlucyBmdW5jdGlv
bnMgZm9yIGNyZWF0aW5nIG11bHRpdmVjdG9ycywKICAgICAgdmVjdG9ycywgcm90b3JzLCBldGMu
IEl0IGFsc28gYWN0cyBhcyB0aGUgbWV0YXRhYmxlIGZvciB0aGF0CiAgICAgIGFsZ2VicmEncyBt
dWx0aXZlY3RvcnMuCgogICBdXQogICBsb2NhbCBmdW5jdGlvbiBjcmVhdGVfYWxnZWJyYV9vYmpl
Y3QoZGltLCBzaWcsIHRibCkKICAgICAgbG9jYWwgYmFzaXMgPSBleHRyYWN0X2Jhc2lzKHRibCkK
ICAgICAgbG9jYWwgYWxnOyBhbGcgPSB7CiAgICAgICAgIF90YmwgPSB0YmwsCgogICAgICAgICAt
LSBQcmludHMgdGhlIGJhc2lzIGVsZW1lbnRzIG9mIHRoZSBhbGJlYnJhJ3MgbXVsdGl2ZWN0b3Jz
IGluCiAgICAgICAgIC0tIHRoZSBvcmRlciBleHBlY3RlZCBieSB0aGUgJ211bHRpdmVjdG9yJyBm
dW5jdGlvbi4KICAgICAgICAgYmFzaXMgPSBmdW5jdGlvbigpCiAgICAgICAgICAgIGxvY2FsIHMg
PSAnJwogICAgICAgICAgICBmb3IgYiBpbiBhbGwoYmFzaXMpIGRvCiAgICAgICAgICAgICAgIGxv
Y2FsIHBvc3QgPSAnJwogICAgICAgICAgICAgICBpZiBiID09ICdlMScgdGhlbgogICAgICAgICAg
ICAgICAgICBwb3N0ID0gJyAoeCknCiAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICBp
ZiBzaWdbM10gPT0gMSB0aGVuCiAgICAgICAgICAgICAgICAgIGlmIGIgPT0gJ2UyJyBhbmQgZGlt
ID4gMiB0aGVuCiAgICAgICAgICAgICAgICAgICAgIHBvc3QgPSAnICh5KScKICAgICAgICAgICAg
ICAgICAgZWxzZWlmIGIgPT0gJ2UzJyBhbmQgZGltID4gMyB0aGVuCiAgICAgICAgICAgICAgICAg
ICAgIHBvc3QgPSAnICh6KScKICAgICAgICAgICAgICAgICAgZWxzZWlmIGIgPT0gJ2UnLi5kaW0g
dGhlbgogICAgICAgICAgICAgICAgICAgICBwb3N0ID0gJyAodyknCiAgICAgICAgICAgICAgICAg
IGVuZAogICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgIGlmIGIgPT0gJ2UyJyBh
bmQgZGltID49IDIgdGhlbgogICAgICAgICAgICAgICAgICAgICBwb3N0ID0gJyAoeSknCiAgICAg
ICAgICAgICAgICAgIGVsc2VpZiBiID09ICdlMycgYW5kIGRpbSA_PSAzIHRoZW4KICAgICAgICAg
ICAgICAgICAgICAgcG9zdCA9ICcgKHopJwogICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAg
ICAgICAgZW5kCiAgICAgICAgICAgICAgIHMgLi49IGIuLnBvc3QuLidcbicKICAgICAgICAgICAg
ICAgLS1wcmludChiLi5wb3N0KQogICAgICAgICAgICBlbmQKICAgICAgICAgICAgcmV0dXJuIHMK
ICAgICAgICAgZW5kLAoKICAgICAgICAgLS0gUHJpbnRzIHRoZSBhbGdlYnJhJ3Mgc2lnbmF0dXJl
LgogICAgICAgICBzaWduYXR1cmUgPSBmdW5jdGlvbigpCiAgICAgICAgICAgIHJldHVybiAnYWxn
ZWJyYSgnLi5qb2luKHNpZywgJywnKS4uJyknCiAgICAgICAgICAgIC0tcHJpbnQoJ2FsZ2VicmEo
Jy4uam9pbihzaWcsICcsJykuLicpJykKICAgICAgICAgZW5kLAoKCgogICAgICAgICAtLSBQcmlu
dHMgdGhlIGFsZ2VicmEncyBtdWx0aXBsaWNhdGlvbiB0YWJsZS4KICAgICAgICAgbXVsdGlwbGlj
YXRpb25fdGFibGUgPSBmdW5jdGlvbigpCiAgICAgICAgICAgIC0tIGhlYWRlcgogICAgICAgICAg
ICBsb2NhbCB0X3N0ciA9IHBhZCgnJywgMTApCiAgICAgICAgICAgIGZvciBiIGluIGFsbChiYXNp
cykgZG8KICAgICAgICAgICAgICAgaWYgYiA9PSAnc2NhbGFyJyB0aGVuCiAgICAgICAgICAgICAg
ICAgIHRfc3RyIC4uPSBwYWQoJ3wgMScsIDEyKQogICAgICAgICAgICAgICBlbHNlCiAgICAgICAg
ICAgICAgICAgIHRfc3RyIC4uPSBwYWQoJ3wgJy4uYiwgMTIpCiAgICAgICAgICAgICAgIGVuZAog
ICAgICAgICAgICBlbmQKICAgICAgICAgICAgdF9zdHIgLi49ICdcbicuLnN0cl9yZXBlYXQoJy0n
LCAjdF9zdHIpCgogICAgICAgICAgICAtLSB0YWJsZQogICAgICAgICAgICBmb3IgYjEgaW4gYWxs
KGJhc2lzKSBkbwogICAgICAgICAgICAgICBsb2NhbCByb3cgPSB0YmxbYjFdCiAgICAgICAgICAg
ICAgIGxvY2FsIHJfc3RyCiAgICAgICAgICAgICAgIGlmIGIxID09ICdzY2FsYXInIHRoZW4KICAg
ICAgICAgICAgICAgICAgcl9zdHIgPSAnXG4nLi5wYWQoJzEnLCAxMCkKICAgICAgICAgICAgICAg
ZWxzZQogICAgICAgICAgICAgICAgICByX3N0ciA9ICdcbicuLnBhZChiMSwgMTApCiAgICAgICAg
ICAgICAgIGVuZAogICAgICAgICAgICAgICBmb3IgYjIgaW4gYWxsKGJhc2lzKSBkbwogICAgICAg
ICAgICAgICAgICBsb2NhbCB2LCBjMiA9IHVucGFjayhyb3dbYjJdKQogICAgICAgICAgICAgICAg
ICBpZiB2ID09IDAgdGhlbgogICAgICAgICAgICAgICAgICAgICByX3N0ciAuLj0gcGFkKCd8IDAn
LCAxMikKICAgICAgICAgICAgICAgICAgZWxzZWlmIGMyIH49ICdzY2FsYXInIHRoZW4KICAgICAg
ICAgICAgICAgICAgICAgcl9zdHIgLi49IHBhZCgnfCAnLi4odiA8IDAgYW5kICctJyBvciAnJyku
LmMyLCAxMikKICAgICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICAgICByX3N0
ciAuLj0gcGFkKCd8ICcuLnYsIDEyKQogICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAg
ICAgZW5kCiAgICAgICAgICAgICAgIHRfc3RyIC4uPSByX3N0cgogICAgICAgICAgICBlbmQKICAg
ICAgICAgICAgcmV0dXJuIHRfc3RyCiAgICAgICAgIGVuZCwKCgoKICAgICAgICAgLS1bWwogICAg
ICAgICAgICBDcmVhdGVzIGEgbXVsdGl2ZWN0b3IuIEFsbCAyXm4gY29tcG9uZW50cyBhcmUgcmVx
dWlyZWQKICAgICAgICAgICAgd2hlcmUgJ24nIGlzIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucy4g
TXVsdGl2ZWN0b3JzIGluIDJECiAgICAgICAgICAgIGhhdmUgZm91ciBjb21wb25lbnRzLCBtdWx0
aXZlY3RvcnMgaW4gM0QgaGF2ZSA4CiAgICAgICAgICAgIGNvbXBvbmVudHMsIGV0Yy4KCiAgICAg
ICAgIF1dCiAgICAgICAgIG11bHRpdmVjdG9yID0gZnVuY3Rpb24oLi4uKQogICAgICAgICAgICBs
b2NhbCBhcmdzID0gey4uLn0KICAgICAgICAgICAgYXNzZXJ0KAogICAgICAgICAgICAgICAjYXJn
cyA9PSAyXmRpbSwKICAgICAgICAgICAgICAgJ211bHRpdmVjdG9yIHRha2VzICcuLigyXmRpbSku
LicgYXJndW1lbnRzLicKICAgICAgICAgICAgKQogICAgICAgICAgICBsb2NhbCBtdiA9IHt9CiAg
ICAgICAgICAgIGZvciBpLHYgaW4gaXBhaXJzKGFyZ3MpIGRvCiAgICAgICAgICAgICAgIGlmIHYg
fj0gMCB0aGVuCiAgICAgICAgICAgICAgICAgIG12W2Jhc2lzW2ldXSA9IHYKICAgICAgICAgICAg
ICAgZW5kCiAgICAgICAgICAgIGVuZAogICAgICAgICAgICByZXR1cm4gc2V0bWV0YXRhYmxlKG12
LCBhbGcpCiAgICAgICAgIGVuZCwKCgoKICAgICAgICAgLS0gUmV0dXJucyBhIGZ1bmN0aW9uIGZv
ciBjcmVhdGluZyBtdWx0aXZlY3RvcnMgY29uc2lzdGluZyBvZgogICAgICAgICAtLSBjb21wb25l
bnRzIG9mIGEgcGFydGljdWxhciBncmFkZS4KICAgICAgICAgbl9ibGFkZSA9IGZ1bmN0aW9uKG4p
CiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiguLi4pCiAgICAgICAgICAgICAgIGxvY2FsIG51
bV9hcmdzID0gY2hvb3NlKGRpbSwgbikKICAgICAgICAgICAgICAgbG9jYWwgYXJncyA9IHsuLi59
CiAgICAgICAgICAgICAgIGFzc2VydCgKICAgICAgICAgICAgICAgICAgI2FyZ3MgPT0gbnVtX2Fy
Z3MsCiAgICAgICAgICAgICAgICAgIG4gPT0gMSBhbmQKICAgICAgICAgICAgICAgICAgJ3ZlY3Rv
ciAoMS1ibGFkZSkgdGFrZXMgJy4uZGltLi4nIGFyZ3VtZW50cy4nIG9yCiAgICAgICAgICAgICAg
ICAgIG4uLictYmxhZGUgdGFrZXMgJy4ubnVtX2FyZ3MuLicgYXJndW1lbnRzLicKICAgICAgICAg
ICAgICAgKQogICAgICAgICAgICAgICBsb2NhbCBtdiA9IHt9CiAgICAgICAgICAgICAgIGxvY2Fs
IGkgPSAxCiAgICAgICAgICAgICAgIGZvciBiIGluIGFsbChiYXNpcykgZG8KICAgICAgICAgICAg
ICAgICAgaWYgZ3JhZGUoYikgPT0gbiB0aGVuCiAgICAgICAgICAgICAgICAgICAgIG12W2JdID0g
YXJnc1tpXQogICAgICAgICAgICAgICAgICAgICBpICs9IDEKICAgICAgICAgICAgICAgICAgZW5k
CiAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICByZXR1cm4gc2V0bWV0YXRhYmxlKG12
LCBhbGcpCiAgICAgICAgICAgIGVuZAogICAgICAgICBlbmQsCgoKCiAgICAgICAgIC0tIENyZWF0
ZXMgYSByb3RhdGlvbiBvcGVyYXRvci4KICAgICAgICAgLS0gJ2Zyb20nIGFuZCAndG8nIHNob3Vs
ZCBiZSBub3JtYWxpemVkIHZlY3RvcnMuCiAgICAgICAgIHJvdG9yX2Zyb21fdG8gPSBmdW5jdGlv
bihmcm9tLCB0bykKICAgICAgICAgICAgcmV0dXJuICgxICsgdG8qZnJvbSkgLyBzcXJ0KDIgKyAy
Kihmcm9tICUgdG8pKQogICAgICAgICBlbmQsCgoKCiAgICAgICAgIC0tIENyZWF0ZSBhIHJvdGF0
aW9uIG9wZXJhdG9yIGZyb20gYSBwbGFuZSBhbmQgYW4gYW5nbGUuCiAgICAgICAgIC0tICdwbGFu
ZScgc2hvdWxkIGJlIGEgbm9ybWFsaXplZCBwdXJlIGJpdmVjdG9yIGNyZWF0ZWQgZnJvbQogICAg
ICAgICAtLSB0d28gdmVjdG9ycyB3aXRoIHRoZSBeIG9wZXJhdG9yLiAgJ2FuZ2xlJyBpcyBhIG51
bWJlcgogICAgICAgICAtLSB3aGVyZSAtMSA8PSBhbmdsZSA8PSAxCiAgICAgICAgIHJvdG9yX3Bs
YW5lX2FuZ2xlID0gZnVuY3Rpb24ocGxhbmUsIGFuZ2xlKQogICAgICAgICAgICByZXR1cm4gY29z
KGFuZ2xlLzIpICsgc2luKGFuZ2xlLzIpKnBsYW5lCiAgICAgICAgIGVuZCwKCgoKCiAgICAgICAg
IC0tIENvcGllcyB0aGUgYWxnZWJyYSBvYmplY3QncyBmdW5jdGlvbnMgdG8gdGhlIGdsb2JhbAog
ICAgICAgICAtLSBuYW1lc3BhY2UuCiAgICAgICAgIG1ha2VfZ2xvYmFsID0gZnVuY3Rpb24oc2Vs
ZikKICAgICAgICAgICAgZm9yIGssIHYgaW4gcGFpcnMoc2VsZikgZG8KICAgICAgICAgICAgICAg
aWYga1sxXSB_PSAnXycgdGhlbgogICAgICAgICAgICAgICAgICBfRU5WW2tdID0gdgogICAgICAg
ICAgICAgICBlbmQKICAgICAgICAgICAgZW5kCiAgICAgICAgIGVuZCwKCgoKICAgICAgICAgLS1b
WwoKICAgICAgICAgICAgTGluZWFybHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gdGhlIHR3byBtdWx0
aXZlY3RvcnMgJ3YxJwogICAgICAgICAgICBhbmQgJ3YyJy4gVGhlIHZhbHVlICd0JyBpcyB0eXBp
Y2FsbHkgYmV0d2VlbiAwIGFuZCAxIGJ1dAogICAgICAgICAgICBpdCBjYW4gYmUgYW55IG51bWJl
ci4gV2hlbiB0PTAgdGhlIHJlc3VsdCBpZiAndjEnIGFuZCB3aGVuCiAgICAgICAgICAgIHQ9MSB0
aGUgcmVzdWx0IGlmICd2MicuCgogICAgICAgICBdXQogICAgICAgICBsZXJwID0gZnVuY3Rpb24o
djEsIHYyLCB0KQogICAgICAgICAgICByZXR1cm4gdjEgKyB0Kih2MiAtIHYxKQogICAgICAgICBl
bmQsCgogICAgICAgICBubGVycCA9IGZ1bmN0aW9uKHYxLCB2MiwgdCkKICAgICAgICAgICAgcmV0
dXJuIGxlcnAodjEsIHYyLCB0KTpub3JtYWxpemUoKQogICAgICAgICBlbmQsCgogICAgICAgICBz
bGVycCA9IGZ1bmN0aW9uKHYxLCB2MiwgdCkKICAgICAgICAgICAgbG9jYWwgcHJvZHVjdCA9IHYx
KnYyOnJldmVyc2UoKQogICAgICAgICAgICBsb2NhbCBjb3NfdGhldGEgPSBwcm9kdWN0LnNjYWxh
cgogICAgICAgICAgICBsb2NhbCB0aGV0YV90ID0gdCAqIChtYXRoLmFjb3MoY29zX3RoZXRhKSAv
ICgyICogbWF0aC5waSApKQogICAgICAgICAgICBsb2NhbCBwbGFuZSA9IHByb2R1Y3Q6Z3JhZGUo
Mik6bm9ybWFsaXplKCkKICAgICAgICAgICAgbG9jYWwgciA9IGNvcyh0aGV0YV90KSArIHNpbih0
aGV0YV90KSpwbGFuZQogICAgICAgICAgICByZXR1cm4gcip2MQoKICAgICAgICAgICAgCiAgICAg
ICAgICAgIC0tbG9jYWwgY29zX3RoZXRhID0gdjEldjIKICAgICAgICAgICAgLS1sb2NhbCBwID0g
KHYxKnYyKTpncmFkZSgyKTpub3JtYWxpemUoKQogICAgICAgICAgICAtLXJldHVybiAoKGNvcyh0
aGV0YSp0KSArIHNpbih0aGV0YSp0KSpwKSp2MSk6bm9ybWFsaXplKCk6cmV2ZXJzZSgpCiAgICAg
ICAgICAgIC0tcmV0dXJuIC0oKGNvcyh0aGV0YSp0KSArIHNpbih0aGV0YSp0KSpwKSp2MSk6bm9y
bWFsaXplKCk6cmV2ZXJzZSgpCiAgICAgICAgICAgIC0tbG9jYWwgdGhldGEgPSBtYXRoLmFjb3Mo
djEldjIpIC8gKDIgKiBtYXRoLnBpICkKICAgICAgICAgICAgLS1sb2NhbCBwID0gKHYxXnYyKTpu
b3JtYWxpemUoKQogICAgICAgICAgICAtLXJldHVybiB2MTp0cmFuc2Zvcm0ocm90b3JfcGxhbmVf
YW5nbGUocCwgdGhldGEqdCkpCiAgICAgICAgIGVuZCwKCgoKCiAgICAgICAgIC0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgLS0gTXVsdGl2ZWN0b3IgbWV0
YS1tZXRob2RzCiAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KICAgICAgICAgX190b3N0cmluZyA9IGZ1bmN0aW9uKHNlbGYpCiAgICAgICAgICAgIGxvY2Fs
IHMgPSAnJwogICAgICAgICAgICBmb3IgYiBpbiBhbGwoYmFzaXMpIGRvCiAgICAgICAgICAgICAg
IGxvY2FsIHYgPSBzZWxmW2JdCiAgICAgICAgICAgICAgIGlmIHYgYW5kIHYgfj0gMCBhbmQgYiA9
PSAnc2NhbGFyJyB0aGVuCiAgICAgICAgICAgICAgICAgIHMgLi49IHYKICAgICAgICAgICAgICAg
ZWxzZWlmIHYgYW5kIHYgPCAwIHRoZW4KICAgICAgICAgICAgICAgICAgcyAuLj0gdi4uYgogICAg
ICAgICAgICAgICBlbHNlaWYgdiBhbmQgdiA_IDAgdGhlbgogICAgICAgICAgICAgICAgICBzIC4u
PSAoI3MgPiAwIGFuZCAnKycgb3IgJycpLi52Li5iCiAgICAgICAgICAgICAgIGVuZAogICAgICAg
ICAgICBlbmQKICAgICAgICAgICAgcmV0dXJuIHMgPT0gJycgYW5kICcwJyBvciBzCiAgICAgICAg
IGVuZCwKCiAgICAgICAgIF9fZXEgPSBmdW5jdGlvbihhLCBiKQogICAgICAgICAgICBmb3Igayx2
IGluIHBhaXJzKGEpIGRvCiAgICAgICAgICAgICAgIGlmIGJba10gfj0gdiB0aGVuCiAgICAgICAg
ICAgICAgICAgIHJldHVybiBmYWxzZQogICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgZW5k
CiAgICAgICAgICAgIGZvciBrLHYgaW4gcGFpcnMoYikgZG8KICAgICAgICAgICAgICAgaWYgYVtr
XSB_PSB2IHRoZW4KICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgICAgICAg
IGVuZAogICAgICAgICAgICBlbmQKICAgICAgICAgICAgcmV0dXJuIHRydWUKICAgICAgICAgZW5k
LAogICAgICAgICAKICAgICAgICAgX191bm0gPSBmdW5jdGlvbihzZWxmKQogICAgICAgICAgICBy
ZXR1cm4gLTEgKiBzZWxmCiAgICAgICAgIGVuZCwKCiAgICAgICAgIF9fYWRkID0gZnVuY3Rpb24o
YSwgYikKICAgICAgICAgICAgbG9jYWwgbXYgPSB7fQogICAgICAgICAgICBpZiB0eXBlKGEpID09
ICdudW1iZXInIHRoZW4KICAgICAgICAgICAgICAgZm9yIGssdiBpbiBwYWlycyhiKSBkbwogICAg
ICAgICAgICAgICAgICBtdltrXSA9IHYKICAgICAgICAgICAgICAgZW5kCiAgICAgICAgICAgICAg
IG12LnNjYWxhciA9IGdldChtdiwgJ3NjYWxhcicsIDApICsgYQogICAgICAgICAgICBlbHNlaWYg
dHlwZShiKSA9PSAnbnVtYmVyJyB0aGVuCiAgICAgICAgICAgICAgIHJldHVybiBiICsgYQogICAg
ICAgICAgICBlbHNlCiAgICAgICAgICAgICAgIGZvciBjIGluIGFsbChiYXNpcykgZG8KICAgICAg
ICAgICAgICAgICAgbG9jYWwgdiA9IGdldChhLCBjLCAwKSArIGdldChiLCBjLCAwKQogICAgICAg
ICAgICAgICAgICBpZiB2IH49IDAgdGhlbgogICAgICAgICAgICAgICAgICAgICBtdltjXSA9IHYK
ICAgICAgICAgICAgICAgICAgZW5kCiAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICBlbmQK
ICAgICAgICAgICAgcmV0dXJuIHNldG1ldGF0YWJsZShtdiwgYWxnKQogICAgICAgICBlbmQsCgog
ICAgICAgICBfX3N1YiA9IGZ1bmN0aW9uKGEsIGIpCiAgICAgICAgICAgIHJldHVybiBhICsgKC1i
KQogICAgICAgICBlbmQsCiAgICAgICAgIAoKCgogICAgICAgICAtLVtbCiAgICAgICAgICAgIEdl
b21ldHJpYyBQcm9kdWN0LgoKICAgICAgICAgICAgVGhlIGdlb21ldHJpYyBwcm9kdWN0IGlzIHRo
ZSBzdW0gb2YgdGhlIGRvdCBwcm9kdWN0IGFuZAogICAgICAgICAgICB0aGUgd2VkZ2UgcHJvZHVj
dCBvZiB0d28gbXVsdGl2ZWN0b3JzLiBGb3IgbXVsdGl2ZWN0b3JzCiAgICAgICAgICAgICdhJyBh
bmQgJ2InLAoKICAgICAgICAgICAgICAgIGEqYiA9PSBhLi5iICsgYV5iLgoKICAgICAgICAgXV0K
ICAgICAgICAgX19tdWwgPSBmdW5jdGlvbihhLCBiKQogICAgICAgICAgICBsb2NhbCBtdiA9IHt9
CiAgICAgICAgICAgIGlmIHR5cGUoYSkgPT0gJ251bWJlcicgdGhlbgogICAgICAgICAgICAgICBm
b3Igayx2IGluIHBhaXJzKGIpIGRvCiAgICAgICAgICAgICAgICAgIG12W2tdID0gYSp2CiAgICAg
ICAgICAgICAgIGVuZAogICAgICAgICAgICAgICByZXR1cm4gc2V0bWV0YXRhYmxlKG12LCBhbGcp
CiAgICAgICAgICAgIGVsc2VpZiB0eXBlKGIpID09ICdudW1iZXInIHRoZW4KICAgICAgICAgICAg
ICAgcmV0dXJuIGIgKiBhCiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgZm9yIGIxLCB2
MSBpbiBwYWlycyhhKSBkbwogICAgICAgICAgICAgICAgICBmb3IgYjIsIHYyIGluIHBhaXJzKGIp
IGRvCiAgICAgICAgICAgICAgICAgICAgIGxvY2FsIG4sIGMgPSB1bnBhY2sodGJsW2IxXVtiMl0p
CiAgICAgICAgICAgICAgICAgICAgIGxvY2FsIGN1ciA9IGdldChtdiwgYywgMCkKICAgICAgICAg
ICAgICAgICAgICAgbXZbY10gPSBjdXIgKyB2MSp2MipuCiAgICAgICAgICAgICAgICAgICAgIGlm
IG12W2NdID09IDAgdGhlbgogICAgICAgICAgICAgICAgICAgICAgICBtdltjXSA9IG5pbAogICAg
ICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgICAgICAgZW5kCiAgICAgICAgICAgICAg
IGVuZAogICAgICAgICAgICAgICByZXR1cm4gc2V0bWV0YXRhYmxlKG12LCBhbGcpCiAgICAgICAg
ICAgIGVuZAogICAgICAgICBlbmQsCgoKCgogICAgICAgICAtLVtbCiAgICAgICAgICAgIFdlZGdl
IChPdXRlcikgUHJvZHVjdC4gKFRoZSAnYmV0dGVyJyBjcm9zcyBwcm9kdWN0LikKCiAgICAgICAg
ICAgIENvbWJpbmVzIHZlY3RvcnMgaW50byBoaWdoZXIgZGltZW5zaW9uYWwgc3ViLXNwYWNlcy4g
IEZvcgogICAgICAgICAgICBpbnN0YW5jZSB0YWtpbmcgdmVjdG9ycyB4PSgxLCAwLCAwKSBhbmQg
eT0oMCwgMSwgMCksIHheeQogICAgICAgICAgICBnaXZlcyBhbiAoaXJyZWR1Y2libGUpIHF1YW50
aXR5IHh5LCBjYWxsZWQgYSBiaXZlY3RvciBvcgogICAgICAgICAgICAyLWJsYWRlLCB3aGljaCBy
ZXByZXNlbnRzIGEgMkQgc3ViLXNwYWNlIChUaGF0IGlzOiBhCiAgICAgICAgICAgIHBsYW5lLiBT
cGVjaWZpY2FsbHkgdGhlIHh5LXBsYW5lIGluIHRoaXMgY2FzZS4pCgogICAgICAgICAgICBUaGUg
d2VkZ2UgcHJvZHVjdCBpcyBhbnRpLWNvbW11dGF0aXZlLiBUaGF0IGlzIGZvciB2ZWN0b3JzCiAg
ICAgICAgICAgICdhJyBhbmQgJ2InCgogICAgICAgICAgICAgICAgYV5iID0gLWJeYSwKCiAgICAg
ICAgICAgIHNvIHRoZSBvcmRlciBpbiB3aGljaCB5b3UgY29tYmluZSB0aGVtIG1hdHRlcnMuCgog
ICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tCiAgICAgICAgICAgIE5vdGUgb24gdGhlIGNyb3NzIHByb2R1Y3Q6Cgog
ICAgICAgICAgICBHaXZlbiB0aGUgdmVjdG9ycyBhID0gKGExLCBhMiwgYTMpIGFuZCBiID0gKGIx
LCBiMiwgYjMpLAoKICAgICAgICAgICAgICAgIGFeYiA9IChhMSpiMiAtIGEyKmIxLCBhMSpiMyAt
IGEzKmIxLCBhMipiMyAtIGEzKmIyKS4KCiAgICAgICAgICAgIEV4Y2VwdCBlYWNoIG9mIHRob3Nl
IGNvbXBvbmVudHMgaXMgYSBiaXZlY3RvciAvbm90LyBhCiAgICAgICAgICAgIHZlY3Rvci4gSWYg
eW91J3JlIGZhbWlsaWFyIHdpdGggc3RhbmRhcmQgdmVjdG9yIG9wZXJhdGlvbnMKICAgICAgICAg
ICAgeW91IG1heSBub3RpY2UgdGhhdCB0aGF0J3MgL2FsbW9zdC8gdGhlIGNyb3NzIHByb2R1Y3QK
ICAgICAgICAgICAgZm9ybXVsYToKCiAgICAgICAgICAgICAgICBhIHggYiA9IChhMipiMyAtIGEz
KmIyLCAtKGExKmIzIC0gYTMqYjEpLCBhMSpiMiAtIGEyKmIxKQoKICAgICAgICAgICAgVGhlIG9y
ZGVyIG9mIHRoZSB0ZXJtcyBpcyByZXZlcnNlZCBhbmQgdGhlIG1pZGRsZQogICAgICAgICAgICBj
b21wb25lbnQgaXMgbmVnYXRpdmUuIFNvIGluIDMgZGltZW5zaW9ucywgdGhlIHdlZGdlCiAgICAg
ICAgICAgIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMgYW5kIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3
bwogICAgICAgICAgICB2ZWN0b3JzIGNvbnRhaW4gdGhlIHNhbWUgaW5mb3JtYXRpb24gYnV0IHBy
ZXNlbnRlZAogICAgICAgICAgICBzbGlnaHRseSBkaWZmZXJlbnRseTogVGhlIGNyb3NzIHByb2R1
Y3QgZ2l2ZXMgeW91IGEgdmVjdG9yCiAgICAgICAgICAgIHBlcnBlbmRpY3VsYXIgdG8gc29tZSBw
bGFuZSB3aGlsZSB0aGUgd2VkZ2UgcHJvZHVjdCBnaXZlcwogICAgICAgICAgICB5b3UgdGhlIHBs
YW5lIGl0c2VsZi4KCiAgICAgICAgICAgIEEgdW5pcXVlIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRv
IGEgcGxhbmUgaXMgYSBwcm9wZXJ0eQogICAgICAgICAgICB1bmlxdWUgdG8gMyBkaW1lbnNpb25z
LiBQbGFuZXMgdGhlbXNlbHZlcywgb24gdGhlIG90aGVyCiAgICAgICAgICAgIGhhbmQsIGV4aXN0
IGluIGFsbCBkaW1lbnNpb25zIGdyZWF0ZXIgdGhhbiAyLiBTbyB3aGlsZSB0aGUKICAgICAgICAg
ICAgY3Jvc3MgcHJvZHVjdCBkb2Vzbid0IGdlbmVyYWxpemUgdG8gb3RoZXIgZGltZW5zaW9ucywg
dGhlCiAgICAgICAgICAgIHdlZGdlIHByb2R1Y3QgZG9lcy4gCgogICAgICAgICAgICBUaGUgY3Jv
c3MgcHJvZHVjdCBjYW4gYmUgaW1wbGVtZW50ZWQgaWYgeW91IHJlYWxseSB3YW50IG9yCiAgICAg
ICAgICAgIG5lZWQgaXQgYnV0IGluIGdlbmVyYWwgdGhpbmdzIHdpbGwgYmUgc2ltcGxlciBhbmQg
bW9yZQogICAgICAgICAgICBnZW5lcmFsIHdoZW4gd29ya2luZyB3aXRoIHdlZGdlIHByb2R1Y3Rz
IGluc3RlYWQuCiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiAgICAgICAgIF1dCiAgICAgICAgIF9fcG93ID0g
ZnVuY3Rpb24oYSwgYikKICAgICAgICAgICAgaWYgdHlwZShhKSA9PSAnbnVtYmVyJyBvciB0eXBl
KGIpID09ICdudW1iZXInIHRoZW4KICAgICAgICAgICAgICAgcmV0dXJuIGEqYgogICAgICAgICAg
ICBlbHNlCiAgICAgICAgICAgICAgIGxvY2FsIG12ID0ge30KICAgICAgICAgICAgICAgZm9yIGIx
LCB2MSBpbiBwYWlycyhhKSBkbwogICAgICAgICAgICAgICAgICBmb3IgYjIsIHYyIGluIHBhaXJz
KGIpIGRvCiAgICAgICAgICAgICAgICAgICAgIGxvY2FsIG4sIGMgPSB1bnBhY2sodGJsW2IxXVti
Ml0pCiAgICAgICAgICAgICAgICAgICAgIGlmIGdyYWRlKGIxKSArIGdyYWRlKGIyKSA9PSBncmFk
ZShjKSB0aGVuCiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsIGN1ciA9IGdldChtdiwgYywg
MCkKICAgICAgICAgICAgICAgICAgICAgICAgbXZbY10gPSBjdXIgKyB2MSp2MipuCiAgICAgICAg
ICAgICAgICAgICAgICAgIGlmIG12W2NdID09IDAgdGhlbgogICAgICAgICAgICAgICAgICAgICAg
ICAgICBtdltjXSA9IG5pbAogICAgICAgICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAg
ICAgICAgICAgZW5kCiAgICAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICBlbmQKICAg
ICAgICAgICAgICAgcmV0dXJuIHNldG1ldGF0YWJsZShtdiwgYWxnKQogICAgICAgICAgICBlbmQK
ICAgICAgICAgZW5kLAoKCgoKICAgICAgICAgLS1bWwogICAgICAgICAgICBEb3QgKElubmVyKSBQ
cm9kdWN0LgoKICAgICAgICAgICAgRm9yIHB1cmUgdmVjdG9ycyAnYScgYW5kICdiJywgJ2EuLmIn
IGlzIHRoZSBmYW1pbGlhciBkb3QKICAgICAgICAgICAgcHJvZHVjdCBidXQgdGhlIGZ1bmN0aW9u
IHdvcmtzIG9uIG1peGVkIG11bHRpdmVjdG9ycyBhcwogICAgICAgICAgICB3ZWxsLgoKICAgICAg
ICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLQogICAgICAgICAgICBOb3RlOiBUaGVyZSBhcmUgYWN0dWFsbHkgbXVsdGlwbGUgd2F5
cyB0byBnZW5lcmFsaXplIHRoZQogICAgICAgICAgICBkb3QgcHJvZHVjdCB0byBtdWx0aXZlY3Rv
cnMgYW5kIHRoaXMgaXMgb25seSBvbmUgb2YKICAgICAgICAgICAgdGhlbS4gRm9yIGFub3RoZXIs
IHNlZSB0aGUgc2NhbGFyIHByb2R1Y3QgKF9fbW9kLyUpCiAgICAgICAgICAgIGJlbG93LiBUaGV5
IGFsbCBnaXZlIHRoZSBzYW1lIHNvbHV0aW9uIGZvciBwdXJlIHZlY3RvcnMKICAgICAgICAgICAg
YnV0IGhhdmUgc2xpZ2h0bHkgZGlmZmVyZW50IG1lYW5pbmdzL3VzZXMgd2hlbiBhcHBsaWVkIHRv
CiAgICAgICAgICAgIG11bHRpdmVjdG9ycy4gSSd2ZSBjaG9zZW4gdGhpcyBpbXBsZW1lbnRhdGlv
biBiZWNhdXNlIGl0J3MKICAgICAgICAgICAgYm90aCBmYWlybHkgY29tbW9uIGFuZCByZWFzb25h
Ymx5IGNvbXB1dGF0aW9uYWxseQogICAgICAgICAgICBlZmZpY2llbnQuIFVubGVzcyB5b3UncmUg
ZG9pbmcgcmVhbGx5IGFkdmFuY2UgdGhpbmdzLCB5b3UKICAgICAgICAgICAgcHJvYmFibHkgZG9u
J3QgbmVlZCB0byBjYXJlLgogICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgogICAgICAgICBdXQogICAgICAgICBfX2Nv
bmNhdCA9IGZ1bmN0aW9uKGEsIGIpCiAgICAgICAgICAgIGlmIHR5cGUoYSkgPT0gJ251bWJlcicg
b3IgdHlwZShiKSA9PSAnbnVtYmVyJyB0aGVuCiAgICAgICAgICAgICAgIHJldHVybiBhKmIKICAg
ICAgICAgICAgZWxzZQogICAgICAgICAgICAgICBsb2NhbCBtdiA9IHt9CiAgICAgICAgICAgICAg
IGZvciBiMSwgdjEgaW4gcGFpcnMoYSkgZG8KICAgICAgICAgICAgICAgICAgZm9yIGIyLCB2MiBp
biBwYWlycyhiKSBkbwogICAgICAgICAgICAgICAgICAgICBsb2NhbCBuLCBjID0gdW5wYWNrKHRi
bFtiMV1bYjJdKQogICAgICAgICAgICAgICAgICAgICBpZiBiMSB_PSAnc2NhbGFyJyBhbmQgYjIg
fj0gJ3NjYWxhcicgYW5kCiAgICAgICAgICAgICAgICAgICAgICAgIGFicyhncmFkZShiMikgLSBn
cmFkZShiMSkpID09IGdyYWRlKGMpCiAgICAgICAgICAgICAgICAgICAgIHRoZW4KICAgICAgICAg
ICAgICAgICAgICAgICAgbG9jYWwgY3VyID0gZ2V0KG12LCBjLCAwKQogICAgICAgICAgICAgICAg
ICAgICAgICBtdltjXSA9IGN1ciArIHYxKnYyKm4KICAgICAgICAgICAgICAgICAgICAgICAgaWYg
bXZbY10gPT0gMCB0aGVuCiAgICAgICAgICAgICAgICAgICAgICAgICAgIG12W2NdID0gbmlsCiAg
ICAgICAgICAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICAgICAgICBlbmQKICAgICAg
ICAgICAgICAgICAgZW5kCiAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICByZXR1cm4g
c2V0bWV0YXRhYmxlKG12LCBhbGcpCiAgICAgICAgICAgIGVuZAogICAgICAgICBlbmQsCgoKCgog
ICAgICAgICAtLVtbCiAgICAgICAgICAgIFNjYWxhciBwcm9kdWN0LgoKICAgICAgICAgICAgQWx3
YXlzIHJldHVybnMgYSBudW1iZXIgL25vdC8gYSBtdWx0aXZlY3Rvci4gSWYgJ2EnIGFuZAogICAg
ICAgICAgICAnYicgYXJlIHZlY3RvcnMgdGhpcyBudW1iZXIgd2lsbCBhZ3JlZSB3aXRoIHRoZSBu
b3JtYWwgZG90CiAgICAgICAgICAgIHByb2R1Y3QgYnV0IG1heSBub3QgYWdyZWUgd2l0aCB0aGUg
ZG90IHByb2R1Y3QgZm9yIG1peGVkCiAgICAgICAgICAgIG11bHRpdmVjdG9yIGlucHV0cy4KCiAg
ICAgICAgIF1dCiAgICAgICAgIF9fbW9kID0gZnVuY3Rpb24oYSwgYikKICAgICAgICAgICAgaWYg
dHlwZShhKSA9PSAnbnVtYmVyJyB0aGVuCiAgICAgICAgICAgICAgIHJldHVybiBhbGcubXVsdGl2
ZWN0b3IoYSAqIGdldChiLCAnc2NhbGFyJywgMCkpCiAgICAgICAgICAgIGVsc2VpZiB0eXBlKGIp
ID09ICdudW1iZXInIHRoZW4KICAgICAgICAgICAgICAgcmV0dXJuIGFsZy5tdWx0aXZlY3Rvcihi
ICogZ2V0KGEsICdzY2FsYXInLCAwKSkKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICBs
b2NhbCBzID0gMAogICAgICAgICAgICAgICBmb3IgYjEsIHYxIGluIHBhaXJzKGEpIGRvCiAgICAg
ICAgICAgICAgICAgIGZvciBiMiwgdjIgaW4gcGFpcnMoYikgZG8KICAgICAgICAgICAgICAgICAg
ICAgbG9jYWwgbiwgYyA9IHVucGFjayh0YmxbYjFdW2IyXSkKICAgICAgICAgICAgICAgICAgICAg
aWYgZ3JhZGUoYykgPT0gMCB0aGVuCiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gdjEqdjIq
bgogICAgICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgICAgICAgZW5kCiAgICAgICAg
ICAgICAgIGVuZAogICAgICAgICAgICAgICByZXR1cm4gcwogICAgICAgICAgICBlbmQKICAgICAg
ICAgZW5kLAoKCgoKICAgICAgICAgLS0gU2NhbGFyIGRpdmlzaW9uIG9mIGEgbXVsdGl2ZWN0b3Iu
ICdiJyBtdXN0IGJlIGEgbnVtYmVyLgogICAgICAgICBfX2RpdiA9IGZ1bmN0aW9uKGEsIGIpCiAg
ICAgICAgICAgIGFzc2VydCh0eXBlKGIpID09ICdudW1iZXInLCAnY2Fubm90IGRpdmlkZSBieSBu
b24tbnVtYmVyLicpCiAgICAgICAgICAgIHJldHVybiBhKigxL2IpCiAgICAgICAgIGVuZCwKCgoK
CgogICAgICAgICBfX2luZGV4ID0gZnVuY3Rpb24oc2VsZiwgaykKICAgICAgICAgICAgaWYgayA9
PSAneCcgdGhlbgogICAgICAgICAgICAgICByZXR1cm4gcmF3Z2V0KHNlbGYsICdlMScpIG9yIDAK
ICAgICAgICAgICAgZW5kCiAgICAgICAgICAgIGlmIHNpZ1szXSA9PSAxIHRoZW4KICAgICAgICAg
ICAgICAgaWYgayA9PSAneScgYW5kIGRpbSA_IDIgdGhlbgogICAgICAgICAgICAgICAgICByZXR1
cm4gcmF3Z2V0KHNlbGYsICdlMicpIG9yIDAKICAgICAgICAgICAgICAgZWxzZWlmIGsgPT0gJ3on
IGFuZCBkaW0gPiAzIHRoZW4KICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhd2dldChzZWxmLCAn
ZTMnKSBvciAwCiAgICAgICAgICAgICAgIGVsc2VpZiBrID09ICd3JyB0aGVuCiAgICAgICAgICAg
ICAgICAgIHJldHVybiByYXdnZXQoc2VsZiwgJ2UnLi5kaW0pIG9yIDAKICAgICAgICAgICAgICAg
ZW5kCiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgaWYgayA9PSAneScgYW5kIGRpbSA_
PSAyIHRoZW4KICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhd2dldChzZWxmLCAnZTInKSBvciAw
CiAgICAgICAgICAgICAgIGVsc2VpZiBrID09ICd6JyBhbmQgZGltID49IDMgdGhlbgogICAgICAg
ICAgICAgICAgICByZXR1cm4gcmF3Z2V0KHNlbGYsICdlMycpIG9yIDAKICAgICAgICAgICAgICAg
ZW5kCiAgICAgICAgICAgIGVuZAogICAgICAgICAgICByZXR1cm4gcmF3Z2V0KHNlbGYsIGspIG9y
IG12X2Z1bmN0aW9uc1trXSBvciAwCiAgICAgICAgIGVuZCwKCiAgICAgICAgIC0tIEVORCBNdWx0
aXZlY3RvciBtZXRhLW1ldGhvZHMKICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQogICAgICB9CiAgICAgIGFsZy52ZWN0b3IgPSBhbGcubl9ibGFkZSgxKQog
ICAgICByZXR1cm4gYWxnCiAgIGVuZAoKCgoKICAgLS1bWwogICAgICBHZW5lcmF0ZXMgYW4gYWxn
ZWJyYSB3aXRoICdwJyBwb3NpdGl2ZSBkaW1lbnNpb25zLCAnbicgbmVnYXRpdmUKICAgICAgZGlt
ZW5zaW9ucyBhbmQgJ3onIGRlZ2VuZXJhdGUgZGltZW5zaW9ucy4gQXJndW1lbnRzICduJyBhbmQg
J3onCiAgICAgIGFyZSBvcHRpb25hbC4KCiAgICAgIEFsZ2VicmFzIHdpdGggb25seSBwb3NpdGl2
ZSBkaW1lbnNpb25zIGNvcnJlc3BvbmQgdG8gc3RhbmRhcmQKICAgICAgRXVjbGlkZWFuIGdlb21l
dHJpZXMgd2hpbGUgYWxnZWJyYXMgd2l0aCBuZWdhdGl2ZSBhbmQvb3IKICAgICAgZGVnZW5lcmF0
ZSBkaW1lbnNpb25zIGNvcnJlc3BvbmQgdG8gbW9yZSBleG90aWMgZ2VvbWV0cmllcy4KCiAgICAg
IFNvbWUgbm90ZXdvcnRoeSBnZW9tZXRyaWVzOgoKICAgICAgICB8IFNpZ25hdHVyZSAgICAgICAg
fCBHZW9tZXRyeSAgICAgICAgICAgICAgIHwKICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tKy0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwKICAgICAgICB8IGFsZ2VicmEoMikgICAgICAgfCAyRCBF
dWNsaWRlYW4gICAgICAgICAgIHwKICAgICAgICB8IGFsZ2VicmEoMykgICAgICAgfCAzRCBFdWNs
aWRlYW4gICAgICAgICAgIHwKICAgICAgICB8IGFsZ2VicmEoMiwgMCwgMSkgfCAyRCBQcm9qZWN0
aXZlICgyRCBQR0EpIHwKICAgICAgICB8IGFsZ2VicmEoMywgMCwgMSkgfCAzRCBQcm9qZWN0aXZl
ICgzRCBQR0EpIHwKICAgICAgICB8IGFsZ2VicmEoMSwgMykgICAgfCBTcGFjZXRpbWUgICAgICAg
ICAgICAgIHwKCiAgICAgIFRoZSAnYWxnZWJyYScgZnVuY3Rpb24gcmV0dXJucyBhbiBvYmplY3Qg
Y29udGFpbmluZyBhbGwKICAgICAgZnVuY3Rpb25zIGZvciB0aGF0IGFsZ2VicmEuIFRoaXMgYWxs
b3dzIHlvdSB0byB1c2UgbXVsdGlwbGUKICAgICAgZGlmZmVyZW50IGFsZ2VicmFzIGluIGEgc2lu
Z2xlIHByb2plY3QuIEhvd2V2ZXIsIGlmIHlvdSdyZSB1c2luZwogICAgICBhIHNpbmdsZSBhbGdl
YnJhIHlvdSBjYW4gbWFrZSB0aGUgZnVuY3Rpb25zIGdsb2JhbCBmb3IgbW9yZQogICAgICBjb252
ZW5pZW50IHVzZToKCiAgICAgIGFsZ2VicmEoMyk6bWFrZV9nbG9iYWwoKQoKICAgXV0KICAgZnVu
Y3Rpb24gYWxnZWJyYShwLCBuLCB6KQogICAgICBuID0gbiBvciAwCiAgICAgIHogPSB6IG9yIDAK
ICAgICAgbG9jYWwgZGltID0gcCArIG4gKyB6CiAgICAgIGxvY2FsIGJhc2lzID0ge30KICAgICAg
bG9jYWwgc3F1YXJlcyA9IHt9CiAgICAgIGZvciBpPTEsZGltIGRvCiAgICAgICAgIGFkZChiYXNp
cywgaSkKICAgICAgICAgc3F1YXJlc1tpXSA9IGkgPD0gcCBhbmQgMSBvciAoaSA8PSBwK24gYW5k
IC0xIG9yIDApCiAgICAgIGVuZAogICAgICBiYXNpcyA9IHBvd2VyX3NldChiYXNpcykKICAgICAg
bG9jYWwgbXVsdF90YmwgPSBnZW5lcmF0ZV9tdWx0aXBsaWNhdGlvbl90YWJsZShiYXNpcywgc3F1
YXJlcykKICAgICAgcmV0dXJuIGNyZWF0ZV9hbGdlYnJhX29iamVjdChkaW0sIHtwLCBuLCB6fSwg
bXVsdF90YmwpCiAgIGVuZAplbmQKCi0tIEVORCBHZW9tZXRyaWMgQWxnZWJyYQotLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCi0tIEVO
RCBHQVZFTDogR0VPTUVUUklDIEFMR0VCUkEgVkVDVE9SIExJQlJBUlkKLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ==
:: lib/pgui/
:: lib/pgui/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTA2IDAxOjM4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSJdXWx6NAAEAAAAAwAAADBuaWw=
:: lib/pgui/pgui.lua
--[[pod_format="raw",author="Sergio Rodriguez Gomez",created="2024-04-17 13:28:56",icon=userdata("u8",16,16,"000000010101010101010101010000000000010d0d0d0d0d0d0d0d0d0d01000000010d0d0d060606060606060d0d0100010d0d0d0606060606060606060d0d01010d0d06060607070707070706060d01010d0d06060707070101070707060d01010d0d06060707070101070707060d01010d0d06060707070101070707060d01010d0d06060607070707070706060d01010d0d06060606060606060606060d01010d0d0d0606060606060606060d0d0101010d0d0d060606060606060d0d0d010101010d0d0d0d0d0d0d0d0d0d0d0101000101010d0d0d0d0d0d0d0d0d0101000000010101010101010101010101000000000001010101010101010101000000"),modified="2024-05-06 01:05:21",notes="An Immediate Mode GUI Library",revision=11342,title="pgui",version="1.0.1"]]
--[[
	pgui - an Immediate Mode GUI library for Picotron
	v1.0.2
	By Sergio Rodriguez Gomez
	https://srsergior.itch.io/ | https://srsergiorodriguez.github.io/code?lang=en
	MIT License
	Donate:
	https://ko-fi.com/srsergior | https://buymeacoffee.com/srsergior
]]--

pgui_components = {}

pgui_components.unknown = {fns={}, data={text="?",_id="unknown"}}
pgui_components.unknown.fns.draw = function(self) print("[?]", self.pos.x, self.pos.y, 8) end

pgui_components.placeholder = {fns={}, data={_id="placeholder",visible=false}}
pgui_components.placeholder.fns.draw = function(self) if (self.visible) print("[x]", self.pos.x, self.pos.y, 8) end

pgui_components.text = {fns={}, data={_id="text",text="TEXT",size=vec(0,7)}}
pgui_components.text.fns.update = function(self)
	return self.text
end
pgui_components.text.fns.draw = function(self)
	pgui:_text(self.text,self,self.color[4])
end

pgui_components.rect = {fns={}, data={_id="rect",size=vec(16,16)}}
pgui_components.rect.fns.draw = function(self)
	pgui:_rect(self.pos.x+self.offset.x,self.pos.y+self.offset.y,self.size.x,self.size.y,self.color[4],false)
end

pgui_components.line = {fns={}, data={_id="rect",size=vec(16,16)}}
pgui_components.line.fns.draw = function(self)
	local x = self.pos.x+self.offset.x
	local y = self.pos.y+self.offset.y
	line(x,y,x+self.size.x,y+self.size.y,self.color[4])
end

pgui_components.radiocircle = {fns={}, data={_id="radiocircle",r=4,on=false}}
pgui_components.radiocircle.fns.update = function(self)
	self.size = vec(self.r*2,self.r*2)
end
pgui_components.radiocircle.fns.draw = function(self)
	local fill = self.color[3]
	local stroke = self.color[4]
	pgui:_radiocirc(self,self.r,fill,stroke,self.on)
end

pgui_components.multibox = {fns={}, data={_id="multibox",size=vec(8,8),on=false}}
pgui_components.multibox.fns.draw = function(self)
	--this is a single box, but used for multiple selection components!
	local fill = self.color[3]
	local stroke = self.color[4]
	local pos = self.pos+self.offset
	if (self.on) pgui:_rect(pos.x,pos.y,self.size.x,self.size.y,fill,true)
	pgui:_rect(pos.x,pos.y,self.size.x,self.size.y,stroke,false)
end

pgui_components.box = {fns={}, data={_id="box",size=vec(16,16),stroke=true,active=false,hover=false}}
pgui_components.box.fns.draw = function(self)
	local fill = self.color[1]
	if (self.mouse.over and self.hover) fill = self.color[2]
	if (self.mouse.left_btn and self.active) fill = self.color[3]
	local stroke = self.stroke and self.color[4] or fill
	pgui:_box(self, self.size.x, self.size.y, fill, stroke)
end

pgui_components.text_box = {fns={}, data={_id="text_box",text="TEXTBOX",margin=2,stroke=true,active=false,hover=false}}
pgui_components.text_box.fns.update = function(self,offset)
	if pgui.stats.memos.text_width[self.text] == nil then
		pgui.stats.memos.text_width[self.text] = pgui:get_text_width(self.text)
	end
	local text_width = pgui.stats.memos.text_width[self.text]
	local lines = #split(self.text,"\n")
	local text_height = lines == 1 and 6 or lines * 9
	self.size = vec(text_width+(self.margin*2),(self.margin*2)+text_height)
	pgui:component("box",{offset=offset,clip=self.clip,layer=self.layer,size=self.size,hover=self.hover,active=self.active,stroke=self.stroke,color=self.color})
	pgui:component("text",{offset=offset,clip=self.clip,layer=self.layer,pos=vec(self.margin,self.margin),active=self.active,text=self.text,color=self.color})
	return self.text
end

pgui_components.sprite = {fns={}, data={_id="sprite",sprite=0,size=vec(0,7),fn=function() end}}
pgui_components.sprite.fns.draw = function(self)
	self.fn()
	pgui:_sprite(self.sprite,self)
	palt()
end

pgui_components.sprite_box = {fns={}, data={_id="sprite_box",sprite=0,margin=2,stroke=true,active=false,hover=false,fn=function() end}}
pgui_components.sprite_box.fns.update = function(self,offset)
	local sprite_width = get_spr(self.sprite):width() - 1
	local sprite_height = get_spr(self.sprite):height() - 1
	self.size = vec(sprite_width+(self.margin*2),(self.margin*2)+sprite_height)
	pgui:component("box",{offset=offset,clip=self.clip,layer=self.layer,size=self.size,hover=self.hover,active=self.active,stroke=self.stroke,color=self.color})
	pgui:component("sprite",{offset=offset,clip=self.clip,layer=self.layer,pos=vec(self.margin,self.margin),active=self.active,sprite=self.sprite,p=self.p})
	return self.sprite
end

pgui_components.input = {fns={}, data={label="input",_id="input",text="INPUT",charlen=16,margin=2}}
pgui_components.input.fns.update = function(self,offset)
	if (pgui:get_store(self.label,true) == nil) then
		local text_width = pgui:get_text_width(self.text)
		pgui:set_store(self.label,{
			cursor_pos = self.margin+text_width,
			cursor_idx = 0,
			active = false,
		},true)
	end
	
	local text_box = pgui:component("text_box",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,text=self.text,margin=self.margin},true)
	text_box:_update()
	text_box.size.x = (6 * self.charlen) + (self.margin * 2)
	self.size = text_box.size:copy()
	
	local mouse_events = pgui:mouse_events(text_box)
	local store = pgui:get_store(self.label,true)
	if mouse_events.clicked then
		local relx = mouse_events.rel_pos.x
		local cursor_pos = pgui:get_cursor_pos(self.margin,self.text,relx)
		store.cursor_pos = cursor_pos[1]
		store.cursor_idx = cursor_pos[2]
		store.cursor_line = 0
		store.active = true
	elseif pgui:get_mouse().mb == 1 and not mouse_events.left_btn then
		store.active = false
	end
	
	if store.active then
		local lines = #split(self.text,"\n")
		local col = self.color[3]
		if pgui.stats.blink then
			pgui:component("box",{offset=offset,clip=self.clip,layer=self.layer,
				pos=vec(pgui:get_store(self.label,true).cursor_pos,2+(store.cursor_line*9)),
				size=vec(1,3+(self.margin*2)),color={col,col,col,col,col,col}
			})
		end
		if keyp("backspace") and store.cursor_idx > 0 then
			local removed = sub(self.text,store.cursor_idx,store.cursor_idx)
			self.text = sub(self.text,0,store.cursor_idx-1)..sub(self.text,store.cursor_idx+1)
			store.cursor_pos -= pgui:get_text_width(removed)
			store.cursor_idx -= 1
		elseif keyp("left") and store.cursor_idx > 0 then
			local prevchar = sub(self.text,store.cursor_idx,store.cursor_idx)
			store.cursor_pos -= pgui:get_text_width(prevchar)
			store.cursor_idx -= 1
		elseif keyp("right") and store.cursor_idx < #self.text then
			local nextchar = sub(self.text,store.cursor_idx+1,store.cursor_idx+1)
			store.cursor_pos += pgui:get_text_width(nextchar)
			store.cursor_idx += 1
		end
		local is_shift = false
		if (key("shift")) is_shift = true --TODO
		for scancode in all(pgui.stats.scancodes) do
			if keyp(scancode) and self.charlen > #self.text then
				local str = scancode == "space" and " " or scancode
				--str = str == "enter" and "\n" or str --for future text field
				str = str == "enter" and "" or str
				str = is_shift and str:upper() or str
				self.text = sub(self.text,0,store.cursor_idx)..str..sub(self.text,store.cursor_idx+1)
				store.cursor_pos += pgui:get_text_width(str)
				store.cursor_idx += 1
			end
		end
		
		--this will help to create a text field component in the future
		store.cursor_line += #split(self.text,"\n") - lines
		
		store.cursor_pos = max(0,store.cursor_pos)
		store.cursor_idx = max(0,store.cursor_idx)
	end
	
	return self.text
end

pgui_components.button = {fns={}, data={_id="button",text="BUTTON",margin=2,stroke=true,disable=false}}
pgui_components.button.fns.update = function(self,offset,mouse)
	local text_box = pgui:component("text_box",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,text=self.text,hover=true and not self.disable,active=true and not self.disable,stroke=self.stroke,margin=self.margin},true)
	text_box:_update()
	self.size = text_box.size:copy()
	return pgui:mouse_events(text_box).clicked
end

pgui_components.vstack = {fns={}, data={_id="vstack",stroke=true,height=0,margin=3,gap=3,contents={},box=true}}
pgui_components.vstack.fns.update = function(self,offset)
	self.size = vec(0,self.margin*2)
	local y = self.margin
	if (self.box) pgui:component("box",{offset=offset,clip=self.clip,layer=self.layer,color=self.color,size=self.size,stroke=self.stroke})
	local upds = {}
	for content in all(self.contents) do
		local com = pgui:component(content[1],content[2],true)
		com.offset = offset
		com.clip = self.clip
		com.layer = self.layer
		com.pos = vec(self.margin+com.pos.x,y+com.pos.y)
		if (com._id == "dropdown") com.grow = true
		local upd = com:_update()
		add(upds,upd)
		self.size.x = com.size.x > self.size.x and com.size.x + com.pos.x or self.size.x
		self.size.y += com.size.y + self.gap
		y += (com.size.y + self.gap)
	end
	self.size.x += self.margin*2
	self.size.y = self.height != 0 and self.height or self.size.y - self.gap
	return upds	
end

pgui_components.hstack = {fns={}, data={_id="hstack",stroke=true,width=0,margin=3,gap=3,contents={},box=true}}
pgui_components.hstack.fns.update = function(self,offset)
	self.size = vec(self.margin*2,0)
	local x = self.margin
	if (self.box) pgui:component("box",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,size=self.size,stroke=self.stroke})
	local upds = {}
	for content in all(self.contents) do
		local com = pgui:component(content[1],content[2],true)
		com.offset = offset
		com.clip = self.clip
		com.layer = self.layer
		com.pos = vec(x+com.pos.x,self.margin+com.pos.y)
		if (com._id == "dropdown") com.grow = false
		local upd = com:_update()
		add(upds,upd)
		self.size.y = com.size.y > self.size.y and com.size.y + com.pos.y or self.size.y
		self.size.x += com.size.x + self.gap
		x += (com.size.x + self.gap)
	end
	self.size.y += self.margin*2
	self.size.x = self.width > 0 and self.width or self.size.x - self.gap
	return upds
end

pgui_components.topbar = {fns={}, data={_id="topbar",width=479,gap=3,contents={}}}
pgui_components.topbar.fns.update = function(self)
	local hstack = pgui:component("hstack",{gap=self.gap,layer=self.layer,width=self.width,stroke=false,margin=0,contents=self.contents},true)
	return hstack:_update()
end

pgui_components.dropdown = {fns={}, data={label="dd",_id="dropdown",grow=false,text="DROPDOWN",stroke=true,margin=2,gap=3,contents={},disable=false}}
pgui_components.dropdown.fns.update = function(self,offset)
	local button = pgui:component("button",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,size=self.size,stroke=self.stroke,text=self.text,margin=self.margin,disable=self.disable},true)
	
	local clicked = button:_update()
	self.size = button.size:copy()
	pgui:component("line",{clip=self.clip,offset=offset,layer=self.layer,pos=vec(0,button.size.y),size=vec(self.size.x,0),color=self.color}) --a kind of hacky solution to overlapping dropwdown buttons, but it avoids adding lots of code to the library
	if clicked and not self.disable then
		local toggle = not pgui:get_store(self.label,true)
		pgui:set_store(self.label,toggle,true)
	end
	if pgui:get_store(self.label,true) then
		local y = button.size.y
		local vstack = pgui:component("vstack",{clip=self.clip,offset=offset,layer=self.layer+1,color=self.color,pos=vec(0,y),margin=self.margin,gap=self.gap,contents=self.contents},true)
		local upd = vstack:_update()
		if (self.grow) self.size.y += vstack.size.y
		return upd
	end
	return {}
end

pgui_components.scrollable = {fns={}, data={label="scrll",_id="scrollable",scroll_x=false,scroll_y=true,size=vec(50,50),sensibility=4,stroke=true,content={"text_box",{text="scrollable",margin=50}}}}
pgui_components.scrollable.fns.update = function(self,offset)
	if pgui:get_store(self.label,true) == nil then
		pgui:set_store(self.label,{
			scrolling = vec(0,0)
		},true)
	end
	local store = pgui:get_store(self.label,true)
	local com = pgui:component(self.content[1],self.content[2],true)
	com.offset=offset
	com.pos = store.scrolling
	com.layer = self.layer
	com.clip = {self.pos.x+self.offset.x,self.pos.y+self.offset.y,self.size.x,self.size.y}
	local upd = com:_update()
	if (not self.scroll_x or (com.size.x < self.size.x)) self.size.x = com.size.x
	if (not self.scroll_y or (com.size.y < self.size.y)) self.size.y = com.size.y
			
	function limit(com,scroller)
		if com.size.y - scroller.size.y + com.pos.y <= 0 then
			com.pos.y = scroller.size.y - com.size.y
		elseif com.pos.y > 0 then
			com.pos.y = 0
		end
		if com.size.x - scroller.size.x + com.pos.x <= 0 then
			com.pos.x = scroller.size.x - com.size.x
		elseif com.pos.x > 0 then
			com.pos.x = 0
		end
	end	
		
	if self.mouse.over then
		if (self.scroll_y) store.scrolling.y += self.mouse.vs*self.sensibility
		if (self.scroll_x) store.scrolling.x += self.mouse.hs*self.sensibility
		limit(com,self)
	end
	
	if (self.stroke) pgui:component("rect",{offset=self.offset,clip=self.clip,layer=self.layer,color=self.color,pos=self.pos,size=self.size})
	return upd
end

pgui_components.hslider = {fns={}, data={_id="hslider",format=function(v) return v end,min=0,max=100,value=50,size=vec(100,10),stroke=true,flr=false}}
pgui_components.hslider.fns.update = function(self,offset)
	local box = pgui:component("box",{clip=self.clip,offset=offset,layer=self.layer,size=self.size,stroke=self.stroke},true)
	box:_update()
	local range = self.max - self.min
	if box.mouse.left_btn then
		self.value = self.min + (box.mouse.rel_pos.x / self.size.x) * range
	end 
	self.value = mid(self.min, self.value, self.max)
	local width = ((self.value - self.min) / range)*self.size.x
	if (self.flr) self.value = flr(self.value)
	local s = vec(width,self.size.y)
	local col = self.color
	col[1] = self.color[3]
	if (width > 0) pgui:component("box",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,size=s,stroke=self.stroke,color=col})
	local text_pos = vec(2,(self.size.y - 6) / 2)
	pgui:component("text",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,text=self.format(self.value),pos=text_pos})
	return self.value
end

pgui_components.radio = {fns={}, data={_id="radio",gap=3,r=3,sep=4,selected=1,options={}}}
pgui_components.radio.fns.update = function(self,offset)
	local y = 0
	local i = 1
	local d = self.r * 2
	local tw = 0
	for opt in all(self.options) do
		if pgui.stats.memos.text_width[opt] == nil then
			pgui.stats.memos.text_width[opt] = pgui:get_text_width(opt)
		end
		local text_width = pgui.stats.memos.text_width[opt]
		tw =  text_width > tw and text_width or tw 
		local pos = vec(0, y)
		local on  = self.selected == i
		local radiocircle = pgui:component("radiocircle",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,pos=pos,r=self.r,on=on},true)
		radiocircle:_update()
		local text_pos = pos+vec(d+self.sep,(d - 7) / 2)
		pgui:component("text",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,text=opt,pos=text_pos})
		y += d + self.gap
		local clicked = pgui:mouse_events(radiocircle).clicked
		if (clicked) self.selected = i 
		i += 1
	end	
	self.size = vec(tw + self.sep + d,y - self.gap)
	return self.selected
end

pgui_components.multi_select = {fns={}, data={_id="multi_select",gap=3,box_size=7,sep=4,selected={},options={}}}
pgui_components.multi_select.fns.update = function(self,offset)
	if (#self.selected < #self.options) then
		notify("#options and #selected do not match in multi_select")
		return
	end
	local y = 0
	local i = 1
	local d = self.box_size
	local tw = 0
	local selected = pgui:copy_table(self.selected)
	for opt in all(self.options) do
		if pgui.stats.memos.text_width[opt] == nil then
			pgui.stats.memos.text_width[opt] = pgui:get_text_width(opt)
		end
		local text_width = pgui.stats.memos.text_width[opt]
		tw =  text_width > tw and text_width or tw 
		local pos = vec(0, y)
		local on  = selected[i]
		local multibox = pgui:component("multibox",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,pos=pos,size=vec(d,d),on=on},true)
		multibox:_update()
		local text_pos = pos+vec(d+self.sep,(d - 7) / 2)
		pgui:component("text",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,text=opt,pos=text_pos})
		y += d + self.gap
		local clicked = pgui:mouse_events(multibox).clicked
		if (clicked) selected[i] = not selected[i]
		i += 1
	end	
	self.size = vec(tw + self.sep + d,y - self.gap)
	return selected
end

pgui_components.checkbox = {fns={}, data={_id="checkbox",text="CHECKBOX",value=false,box_size=8,sep=4}}
pgui_components.checkbox.fns.update = function(self,offset)
	local selected = {self.value}
	local options = {self.text}
	local select = pgui:component("multi_select",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,sep=self.sep,selected=selected,options=options,box_size=self.box_size},true)
	local upd = select:_update()
	self.size = select.size
	return upd[1]
end

pgui_components.palette = {fns={}, data={_id="palette",columns=4,gap=3,box_size=10,colors={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},selected=1}}
pgui_components.palette.fns.update = function(self,offset)
	local i = 0
	for col in all(self.colors) do
		local new_palette = pgui:copy_table(self.color)
		new_palette[1] = col
		new_palette[4] = self.selected == col and new_palette[3] or new_palette[4]
		local pos = vec((i % self.columns), flr(i / self.columns))
		pos = pos * (self.box_size+self.gap)
		local box = pgui:component("box",{clip=self.clip,offset=offset,layer=self.layer,pos=pos,size=vec(self.box_size,self.box_size),stroke=true,color=new_palette},true)
		box:_update()
		if (box.mouse.clicked) self.selected = col
		i += 1
	end
	self.size = vec(
		((self.box_size + self.gap)*self.columns)-self.gap,
		((self.box_size+self.gap)*ceil(#self.colors / self.columns))-self.gap
	)
	return self.selected
end

------ end of components -------

pgui_methods =  {}

--CYCLE METHODS
function pgui_methods:refresh()
	self.components = {}
	self.stats.t += 1
	self.stats.blink = flr(self.stats.t / 20 % 2) == 1
	self.stats.prev_mouse = self:copy_table(self.stats.mouse)
	self.stats.mouse = self:get_mouse()
end

function pgui_methods:draw(callback)
	callback = callback and callback or function() end
	self:sort_table(self.components,"layer")
	for component in all(self.components) do
		if self.components.layer == 4 then
			callback()
		end
		if self.stats.clipping and #component.clip == 4 then
			clip(component.clip[1]+1,component.clip[2]+1,component.clip[3]-1,component.clip[4]-1)
			component:draw()
			clip()
		else
			component:draw()
		end
	end	
end

--COMPONENT METHODS

function pgui_methods:component(name, opts, no_update)
	local template = pgui_components[name]
	if not template then
		notify("ERROR: pgui component '"..tostring(name).."' does not exist")
		return self:new_component(pgui_components["unknown"], "_",{})
	else
		return self:new_component(template, opts, no_update)
	end
end

function pgui_methods:new_component(template, opts, no_update)
	local base_data = {pos=vec(0,0),size=vec(0,0),offset=vec(0,0),color=pgui_methods:copy_table(self.stats.palette),clip={},layer=0}
	local data = {}
	for k,v in pairs(base_data) do
		local value = v
		if (opts[k] != nil) value = opts[k]
		data[k] = value
	end
	for k,v in pairs(template.data) do
		local value = v
		if (opts[k] != nil) value = opts[k]
		data[k] = value
	end
			
	local fns = template.fns
	function fns:_update()
		self.mouse = pgui:mouse_events(self)
		if (self.draw) addcomponent(self)
		if (self.update) then
			local offset = pgui:get_offset(self)
			local upd = self:update(offset)
			return upd == nil and self._id or upd
		else
			return self._id
		end
	end
		
	function addcomponent(component)
		add(self.components, component)
	end
		
	local component = setmetatable(data, {__index=template.fns})	
	
	if no_update then
		return component --create components without updating them, for composition inside other components
	else
		return component:_update()
	end
end

--UPDATE METHODS

function pgui_methods:get_offset(component)
	return component.pos+component.offset
end

function pgui_methods:get_mouse()
	local mx,my,mb,hs,vs = mouse()
	return {mx=mx,my=my,mb=mb,hs=hs,vs=vs}
end

function pgui_methods:get_text_width(str)
	local lines = split(str,"\n")
	
	function tw(text)
		local sum = 0
		local charlist = split(text,"")
		for ch in all(charlist) do
			if ch == "I" or ch == "i" or ch == "l" or ch == "1" then
				sum += 4
			elseif ch == "M" or ch == "T" or ch == "W" or ch == "m" or ch == "w" then
				sum += 6
			else
				sum += 5
			end
		end
		return sum
	end
	
	if (#lines == 1) return tw(str)
	
	local width = 0
	for text in all(lines) do
		local w = tw(text)
		width = width > w and width or w
	end
	
	return width
end

function pgui_methods:get_cursor_pos(margin,text,relx)
	local sum = margin
	local charlist = split(text,"")
	local i = 0
	for ch in all(charlist) do
		local v = 0	
		if ch == "I" or ch == "i" or ch == "l" or ch == "1" then
			v = 4
		elseif ch == "M" or ch == "T" or ch == "W" or ch == "m" or ch == "w" then
			v += 6
		else
			v += 5
		end
		if (sum + v > relx) return {sum,i}
		sum += v
		i += 1
	end
	return {sum,i}
end

function pgui_methods:get_scancodes()
	local scancodes = {
		"~","!","@","#","$","%","^","&","*","(",")",
		"_","-","+","=","[","]","{","}","|",":",";",
		"'",",",".","<",">","/","?","`",
		"0","1","2","3","4","5","6","7","8","9",
		"a","b","c","d","e","f","g","h",
		"i","j","k","l","m","n","o","p",
		"q","r","s","t","u","v","w","x",
		"y","z","space","enter"
	}
	return scancodes
end

function pgui_methods:copy_table(table)
	local new_table = {}
	for k,v in pairs(table) do
		if type(v) == "table" then
			new_table[k] = self:copy_table(v)
		else
			new_table[k] = v
		end
	end
	return new_table
end

function pgui_methods:mouse_events(data)
	local mx = self.stats.mouse.mx
	local my = self.stats.mouse.my
	local mb = self.stats.mouse.mb
	local hs = self.stats.mouse.hs
	local vs = self.stats.mouse.vs
	local pmb = self.stats.prev_mouse.mb
	
	--adjust response to clipping
	local colrect = data.pos+data.offset --collision rectangle position
	local colsize = data.size:copy() --collision rectangle size
	
	if self.stats.clipping then
		if #data.clip == 4 then
			local cx = data.clip[1]
			local cw = data.clip[3]
			local cy = data.clip[2]
			local ch = data.clip[4]
			
			if colrect.x < cx then
				colsize.x = (colrect.x + colsize.x) - cx
				colrect.x = cx
			elseif colrect.x + data.size.x > cx + cw then
				colsize.x = colsize.x - ((colrect.x + colsize.x) - (cx +  cw))
			end 
			if colrect.y < cy then
				colsize.y = (colrect.y + colsize.y) - cy
				colrect.y = cy
			elseif colrect.y + data.size.y > cy + ch then
				colsize.y = colsize.y - ((colrect.y + colsize.y) - (cy +  ch))
			end
		end
	end
	---
	
	local collision = self:rect_collision(colrect,{x=mx,y=my},colsize,{x=1,y=1})
	local lb = collision and mb == 1
	local rb = collision and mb == 2
	local clicked = pmb == 0 and lb
	local released = pmb == 1 and collision and mb == 0
	return {over=collision,left_btn=lb,right_btn=rb,clicked=clicked,released=released,rel_pos=vec(mx,my)-data.offset-data.pos,hs=hs,vs=vs}
end

function pgui_methods:rect_collision(apos, bpos, as, bs)
	--check if two rectangles are colliding
	local colliding = true
	if (apos.x + as.x < bpos.x or
		apos.x > bpos.x + bs.x or
		apos.y + as.y < bpos.y or
		apos.y > bpos.y + bs.y) then
		colliding = false
	end 
	return colliding
end

--RENDER METHODS

function pgui_methods:set_palette(palette)
	if (#palette == 6) then
		self.stats.palette = palette
	else
		notify("Palette must be a table with 6 indexes")
	end
end

function pgui_methods:activate_clipping()
	self.stats.clipping = true
end

function pgui_methods:_text(text,com,col)
	local x = com.pos.x+com.offset.x
	local y = com.pos.y+com.offset.y
	print(tostring(text),x,y,col)
end

function pgui_methods:_rect(x,y,w,h,c,f)
	palt(0,true)
	line(x+1,y,x+w-1,y,c)
	line(x,y+1,x,y+h-1,c)
	line(x+1,y+h,x+w-1,y+h,c)
	line(x+w,y+1,x+w,y+h-1,c)
	if f then
		rectfill(x+1,y+1,x+w-1,y+h-1)
	end
end

function pgui_methods:_box(com,w,h,fill,stroke)
	local x = com.pos.x+com.offset.x
	local y = com.pos.y+com.offset.y
	self:_rect(x,y,w,h,fill,true)
	self:_rect(x,y,w,h,stroke,false)
end

function pgui_methods:_radiocirc(com,r,fill,stroke,f)
	local x = com.pos.x+com.offset.x+r
	local y = com.pos.y+com.offset.y+r
	if (f) circfill(x,y,r,fill)
	circ(x,y,r,stroke)
end

function pgui_methods:_sprite(sprite,com)
	local x = com.pos.x+com.offset.x
	local y = com.pos.y+com.offset.y
	spr(sprite,x,y)
end

--STORE METHODS

function pgui_methods:uid()
	local uid = split(date()," ")
	uid = table.concat(split(uid[1],"-"),"")..table.concat(split(uid[2],":"),"")..sub(tostring(rnd() * 1000),0,3)
	return uid
end

function pgui_methods:set_store(id,data,alt)
	if not alt then
		self.store[id] = data
	else
		self.alt_store[id] = data
	end
end

function pgui_methods:get_store(id,alt)
	if not alt then
		return self.store[id]
	else
		return self.alt_store[id]
	end
end

function pgui_methods:sort_table(tbl, key)
	local n = #tbl
	local sorted = false
	
	while not sorted do
		sorted = true
		for i = 1, n - 1 do
			if tbl[i][key] > tbl[i + 1][key] then
				tbl[i], tbl[i + 1] = tbl[i + 1], tbl[i]
				sorted = false
			end
		end
		n = n - 1
	end
end

pgui = setmetatable({
		components={},
		store={},
		alt_store={},
		stats={
			t = 0,
			blink = false,
			palette = {7,18,12,0,7,6},
			clipping = false,
			memos = {text_width={}},
			scancodes=pgui_methods:get_scancodes(),
			mouse=pgui_methods:get_mouse(),
			prev_mouse=pgui_methods:get_mouse()
		}
	},
	{__index=pgui_methods}
)
:: lib/vgfx/
:: lib/vgfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTA2IDAxOjM4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSJdXWx6NAAEAAAAAwAAADBuaWw=
:: lib/vgfx/vgfx.lua
--[[pod_format="raw",created="2024-03-22 09:38:38",modified="2024-05-05 22:34:01",revision=9584]]
--[[ vgfx.lua
0.3
vector graphics drawing

=== usage: ===
if loading vector sprite in a .vgfx file:
	load_vgfx("pathToMyFile.vgfx")
	sprv(index, x,y, [rotation, scale, color])
	
if generating vector sprites at runtime:
	my_vsprite = {
	make_polygon(vars),
	make_polygon(vars),
	make_polygon(vars),
	...	}
make sure vertices you pass to make_polygon() are triangulated
there are several functions included for this purpose

for simple triangle drawing, just call tri(x0,y0, x1,y1, x2,y2)
but make sure you call vgfx_vclip() ahead so it is properly clipped!

=== todo: ===
-polygon outline generation
-tween/interpolate between two vector sprites/polygons
-animation playback
-compression for vector data
-maybe try writing directly to graphics memory if it's faster
-reset color() to what it was before drawing a vector sprite
-fix outline drawing not matching triangle edges


=== docs: ===
"vector sprite": an array of polygons
"polygon": a table with the elements: 
 - col (color)
 - ocol (outline color)
 - pts (points/vertices for triangle drawing)
   - 1D f64 userdata numbers (x0,y0, y1,y2, ...etc)
   - SHOULD BE TRIANGULATED before being sent to sprv()
 - lpts (points/vertices for line drawing (happens after triangles))
   - same format expected as pts, or nil
 - fill (fill pattern)



=== changes: ===
0.2
- polygon vertices now use userdata
- wire rendering uses same colour rules as filled triangles
- basic polygon outlining
0.3
- polygons now have a single colour and specified fill pattern
- graphics fill pattern is returned to its state from before drawing a vector sprite
- doesn't crash for polygons with nil vertices anymore
- tri raster now follows clipping rect (vertically) for better performace when 
	polygons go beyond the screen edges
- support for loading .vgfx files and drawing their sprites
- replaced vgfx_precise with vgfx_subpixel
- 
]]

--enable for debug view of polygon triangles
vgfx_wire=false

--disable to make all tri point positions floored
--  Disabling subpixel positions adds to the render time and makes
--  animated transformations appear a little less smooth, but
--  it should prevent edge seams between polygon triangles
vgfx_subpixel=true


vgfx_vsprites={}
function load_vgfx(path)
	vgfx_vsprites={}
	local loadfile = fetch(path)
	for s=1,#loadfile do
		local vs={}
		for l=1,#loadfile[s] do
			local layer = loadfile[s][l]
			if layer.show then
				local ol = false
				if layer.triangulation=="line" or layer.triangulation=="line_closed" then
					--its a lines-only layer
					ol=true
					layer.points_triangulated = {}
				elseif layer.triangulation=="fan" then
					layer.points_triangulated = fan_triangulate(layer.points)
				elseif layer.triangulation=="strip" then
					layer.points_triangulated = strip_triangulate(layer.points)
				else
					layer.points_triangulated = earclip_triangulate(layer.points)
				end
				
				
				local olcol = layer.outline
				if (#layer.points>1 and (layer.outline!=-1 or ol)) then
					ol = convert_point_list(layer.points)
					if layer.triangulation!="line" and layer.triangulation!="strip" then
						--we close the outline
						add(ol,ol[1])
					end
				end
				if (olcol<0) olcol = layer.col_a
				
				add(vs, make_polygon(
					layer.points_triangulated,
					(layer.col_b<<8)+layer.col_a,
					layer.fill,
					ol,
					olcol
				) )
			end
	---
		end
		add(vgfx_vsprites, vs)
	end
end

function make_polygon(vertices, c1, pattern, outline, c2)
	local polygon={
		col=c1,
		ocol=c2,
		pts=userdata("f64",#vertices),
		lpts=nil,
		fill=0b0000000000000000,
	}
	
	for i=1,#vertices do
		set(polygon.pts, i-1, vertices[i])
	end
	
	if outline==true then
		--generate outline
		--this doesn't work yet!
		outline=nil
	elseif outline then
		--polygon.lpts = one_d_point_list(outline)
		polygon.lpts = one_d_point_list(convert_point_list(outline))
		
	end
	if pattern and pattern!=false then
		if pattern==true then
			--set pattern to checkered dither
			polygon.fill = 0b1010010110100101
		else
			--use specified pattern
			polygon.fill = pattern
		end
	end

	return polygon
end


vgfx_clipt=0
vgfx_clipb=0
--sets top/bottom clip 
function vgfx_vclip()
	vgfx_clipt = peek4(0x5514)
	vgfx_clipb = peek4(0x5514)+peek2(0x552e)
end
--draw a vector sprite
function sprv(v, x,y, rot,scale, col)
	if #vgfx_vsprites>=1 and type(v)!="table" then
		v = vgfx_vsprites[v+1]
	end
	vgfx_vclip()
	

	local oldfill = peek(0x5500,8)
	--local oldcol = peek(?????,?????)

	local s, cs = 0,0
	if rot and rot!=0 then
		s = sin(rot)
		cs = cos(rot)
	end
	
	local sinxy = vec(0,0,0,0,0,0)
	local cosxy = vec(0,0,0,0,0,0)
	local triv = userdata("f64",6)
	local tpos = vec(x,y,x,y,x,y)
	if (not scale) scale = 1
	
	if (col) color(col)
	local b=0
	local polys = 0
	for p=1,#v do
		b=0
		polys = 0
		if v[p].pts then
			polys=#v[p].pts
			if not col then
				fillp(v[p].fill)
				color(v[p].col)
			end
		end
		while b<polys do
			set(triv, 0, v[p].pts:get(b,6))
			b+=6
			
			triv *= scale
			
			if rot and rot!=0 then
				sinxy = triv*s
				cosxy = triv*cs
				
				set(triv, 0,
				cosxy[0]-sinxy[1], sinxy[0]+cosxy[1],
				cosxy[2]-sinxy[3], sinxy[2]+cosxy[3],
				cosxy[4]-sinxy[5], sinxy[4]+cosxy[5])
			end
			triv += tpos
			tri(triv[0],triv[1],triv[2],triv[3],triv[4],triv[5])
		end
		if (v[p].lpts) then
			local b=0
			local oline=vec(0,0,0,0)
			if (not col) color((v[p].ocol<<8)+v[p].ocol)
			while b<#v[p].lpts-2 do
				set(oline, 0, v[p].lpts:get(b,4))
				b+=2
				oline *= scale
				if rot and rot!=0 then
					sinxy = oline*s
					cosxy = oline*cs
					
					set(oline, 0,
					cosxy[0]-sinxy[1], sinxy[0]+cosxy[1],
					cosxy[2]-sinxy[3], sinxy[2]+cosxy[3])
				end
				oline += tpos
				line(oline[0],oline[1],oline[2],oline[3])
			end
		end
	end
	
	
	--this poke is weird???
	--poke4(0x5500,oldfill)
	--poke4(0x5504,oldfill>>4)
	poke8(0x5500,oldfill)
	--color(oldcol)
end


vgfx_trisdrawn=0
function tri(x0,y0, x1,y1, x2,y2)
	vgfx_trisdrawn += 1
	
	if (not vgfx_subpixel)	x0,y0,x1,y1,x2,y2 = flr(x0),flr(y0),flr(x1),flr(y1),flr(x2),flr(y2)

	if vgfx_wire then
		line(x0,y0, x1,y1)
		line(x1,y1, x2,y2)
		line(x2,y2, x0,y0)
		return
	end
	
	--order the vertices so they are descending from top to bottom
	--we need this since we are drawing it as two triangles:
	--one with a flat base, one with a flat top
	if (y1<y0) x0,x1=x1,x0; y0,y1=y1,y0
	if (y2<y1) x1,x2=x2,x1; y1,y2=y2,y1
	if (y1<y0) x0,x1=x1,x0; y0,y1=y1,y0
	
	--draw the top half
	local hh=y1-y0--height of the half
	local x3=x0+hh*(x2-x0)/(y2-y0)--slicing the tri in two makes another vertex
	if (y0!=y1) triraster(y0,y1, (x3-x0)/hh,(x1-x0)/hh, x0,x0)
	
	--draw the bottom half
	hh=y2-y1
	if (y1!=y2) triraster(y1,y2, (x2-x1)/hh,(x2-x3)/hh, x1,x3)
end

--draws a filled triangle line-by-line, top-to-bottom
--args: top, bottom, step left, step right, left pixel, right pixel
--requires clipping values be set first to work properly
function triraster(t,b, sl,sr, pl,pr)
	if t<vgfx_clipt then
		pl+=sl*(vgfx_clipt-t)
		pr+=sr*(vgfx_clipt-t)
		t=vgfx_clipt
	end
	b=min(b,vgfx_clipb)

	for y=t,b do
		rectfill(pl,y,pr,y)
		pl+=sl
		pr+=sr
	end
end

--triangulation stuff
function earclip_triangulate(points)
	points=convert_point_list(points)
	if (#points<3) return {}
	local pindices = {}
	for p=1,#points do
		add(pindices, p)
	end
	
	if clockwise(points) then
		points = reverselist(points)
	end

	local tris = {}
	while #pindices>3 do
		local earIndex = GetEarIndex(points,pindices)
		local earLeftIndex = wrapIndex(earIndex-1, #pindices)
		local earRightIndex = wrapIndex(earIndex+1, #pindices)

		add(tris, points[pindices[earLeftIndex]].x)
		add(tris, points[pindices[earLeftIndex]].y)
		add(tris, points[pindices[earIndex]].x)
		add(tris, points[pindices[earIndex]].y)
		add(tris, points[pindices[earRightIndex]].x)
		add(tris, points[pindices[earRightIndex]].y)
		
		deli(pindices, earIndex)
	end

	add(tris, points[pindices[1]].x)
	add(tris, points[pindices[1]].y)
	add(tris, points[pindices[2]].x)
	add(tris, points[pindices[2]].y)
	add(tris, points[pindices[3]].x)
	add(tris, points[pindices[3]].y)
	
	return tris
end
function clockwise(p)
	local sum=0.0
	local i_next = 0
	for i=1,#p do
		i_next=i+1
		if (i_next>#p) i_next=1
		sum += (p[i_next].x-p[i].x)*(p[i_next].y+p[i].y)
	end
	return sum>0
end
function reverselist(l)
	local r = {}
	for i=#l, 1, -1 do
		r[#r+1] = l[i]
	end
	return r
end
function wrapIndex(index, size)
	while (index<1) index+=size
	while (index>size) index-=size
	return index
end
function GetEarIndex(points,indices)
	local i=1
	local i_l
	local i_r
	
	while true do
		if i>=#indices then
			return 1-- #couldn't find an ear :/
		end
		
		i_l = wrapIndex(i-1, #indices)
		i_r = wrapIndex(i+1, #indices)
		
		if VertIsConvex(points[indices[i_l]],points[indices[i]],points[indices[i_r]]) then
			if NoVertsInTriangle(i_l,i,i_r, indices, points) then
				return i
			end
		end
		
		i+=1
	end
end
function VertIsConvex(prev, v, next)
	return CrossProd(prev-v, next-v) <= 0
end
function CrossProd(a,b)
	return a.x*b.y - a.y*b.x
end
function NoVertsInTriangle(a, b, c, polyIndices, P)
	
	for k=1,#polyIndices do
		if k!=a and k!=b and k!=c then
			--check if this point is within the tri
			if point_in_triangle(P[polyIndices[k]],P[polyIndices[a]],P[polyIndices[b]],P[polyIndices[c]]) then
				return false
			end
		end
	end
	return true
end
function orient(a,b,c)
	local ab=vec(b.x-a.x,b.y-a.y)
	local ac=vec(c.x-a.x,c.y-a.y)
	if CrossProd(ab,ac)>0 then
		return 1
	end
	return -1
end
function point_in_triangle(p, a,b,c)
	local turns = orient(a,b,p) + orient(b,c,p) + orient(c,a,p)
	return turns==3
end

function fan_triangulate(points)
	points=convert_point_list(points)
	local v,i={},3
	while i<=#points do
		add(v,points[i].x)
		add(v,points[i].y)
		add(v,points[i-1].x)
		add(v,points[i-1].y)
		add(v,points[1].x)
		add(v,points[1].y)
		i+=1
	end
	return v
end

function strip_triangulate(points)
	points=convert_point_list(points)
	if (#points<=3) then
		local v={}
		for i=1,#points do
			add(v,points[i].x)
			add(v,points[i].y)
		end
		return v
	end
	
	local v,i={},4
	add(v,points[1].x)
	add(v,points[1].y)
	add(v,points[2].x)
	add(v,points[2].y)
	add(v,points[3].x)
	add(v,points[3].y)
	while i<=#points do
		add(v,points[i].x)
		add(v,points[i].y)
		add(v,points[i-1].x)
		add(v,points[i-1].y)
		add(v,points[i-2].x)
		add(v,points[i-2].y)
		i+=1
	end
	return v
end

function convert_point_list(t)
	--converts a list of points from various formats to {vec,vec,vec...}
	--this is used for various operations when loading or making polygons
	--but not for storing/rendering the vector sprites themselves
	if #t>0 and type(t[1])=="userdata" then
		if t[1]:width()==2 then
			--already correct vector format
			return t
		end
	end
	local l = {}
	if type(t)=="userdata" then
		--assume its a userdata list of [x0,y0,x1,y1,...]
		for i=0,t:width()-1,2 do
			add(l, vec(t[i],t[i+1]) )
		end
		return l
	end
	
	if #t>0 
	and type(t[1])=="table" and #t[1]==2 then
		--assume it's a list of tables, each table describing a point
		for i=1,#t do
			if t[i].x then
				add(l, vec(t[i].x,t[i].y) )
			else
				add(l, vec(t[i][1],t[i][2]) )
			end
		end
	else
		--assume its a list of {x0,y0,x1,y1,...}
		for i=1,#t,2 do
			add(l, vec(t[i],t[i+1]) )
		end
	end
	return l
end
function one_d_point_list(t)
	--converts table {vec,vec,...} to userdata [x0,y0,x1,y1,...]
	local l = userdata("f64", #t*2)
	local udi=0
	for i=1,#t do
		l[udi]=t[i].x
		l[udi+1]=t[i].y
		udi+=2
	end
	return l
end
:: lib/yottafile.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTA2IDAxOjM3OjMzIixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwMTozODowNiIscmV2aXNpb249MTJdXWx6NADtAAAA_QEAAPYoe195Zl92ZXJzaW9uPTEs
ZGVwcz17Ii9kZXYvbGliL2Vycm9yX2V4cGxvcmVyLnA2NC5wbmciLCIAX2dhdmVsGQABT3BndWkY
AAFFdmdmeBgA8BV9LHRhZ3M9e2NyZWF0ZWQ9IjIwMjQtMDUtMDYgMDE6Mzc6MzMlAM9yYWNrZWQ9
e19yZWahAFwKYgBPPXsiLnkAAC8iLBcAAgsPAHEubHVhIn0skgAFSQABoAAoIiwOAIMvYWxnZWJy
YTAAAKkABS8AAA0AJyIsDQABBQADKgAAuwAFKgAADQAnIiwNAAEFAIAubHVhIn19fQ==
:: lib/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTA2IDAxOjM3OjMzIixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSJdXWx6NAAEAAAAAwAAADBuaWw=
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI1OjE1Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSIscmV2aXNpb249MjEwOF1dbHo0ALoAAACvIAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_9HjIEAA8BAFYfMgQABg8BAFMfMgQAAg8BAE8fMgQACg8B
AFMfMgQAAg8BAF8XMgQADwEA--------nPEIIiksaGlkZGVuPWZhbHNlLHBhbl94PTAIANJ5PTAs
dGlsZV9oPTE2CgAQdwoAj3pvb209MX0sVxALHzEEAP--------------------gPVxAkUG09MX19
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI1OjE0Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSJdXWx6NAAEAAAAAwAAADBuaWw=
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI1OjE1Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSIscmV2aXNpb249MjEwNV1dbHo0ABUBAACiDAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAA------_9
H-8BAKy-yA9AAA1A--_w8HAKAP--ZB--AQD-mVD-----IA==
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI1OjE0Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSJdXWx6NAAEAAAAAwAAADBuaWw=
:: vgfx/0.vgfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIyOjMwOjQ5Iixtb2RpZmllZD0iMjAyNC0w
NC0yOSAyMzowMTo0NSIscmV2aXNpb249MjJdXWx6NAAhAQAAXQEAALB7e3tjb2xfYT0xLAgA8CRi
PTE2LGZpbGw9NDM2OTAsbmFtZT0iIixvdXRsaW5lPS0xLHBvaW50cz17ezQ4LDQ4fSwIABEtCQAV
MAgA8ww0OH19LHNob3c9dHJ1ZSx0eXBlPSJlYXIifSxvABM4bwASOG4ADmoAJjEyagDxNS0xMTYu
ODE4NTgxNDY3ODYsLTQyLjQwNDM2NzMzNTEwNX0sey04MC4zNTMxODc0NDUyMDgsLTYzLjMzOTM4
Njc3MDc5JADwETUwLjYxODk2NjUzMTIwMiwtMzcuMjQ1NzgzOTc5MzYyJADwEDQwLjAyOTQ0NzU1
OTA2OSwzLjQ1ODc4Njg2ODg3MTMjAEA4OCw3CABfMTIxLDbrAANQciJ9fX0=
:: vgfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIyOjMwOjQ5Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSJdXWx6NAAEAAAAAwAAADBuaWw=
:: behaviors.lua
--[[pod_format="raw",created="2024-05-05 05:54:19",modified="2024-05-06 05:10:51",revision=1674]]
--[[----------- TODO -----------))--

- Have an event system that propogates through entities and behaviors
- Better way for default values for variables a behavior might use, instead of having
  all the defaults on the prototype

--((--------- END TODO ---------]]--
include "protos.lua"

-- List of Behaviors
beh_velocity = behavior_proto:new()
beh_acceleration = behavior_proto:new()
beh_bounce = behavior_proto:new()
beh_flip_with_velocity = behavior_proto:new()
beh_display_sprite = behavior_proto:new()


------------------
-- beh_velocity --
------------------
function beh_velocity._update(self, parent)
	if parent.vx == nil or parent.vy == nil then
		return nil
	end
	parent.x += parent.vx / 60.0
	parent.y += parent.vy / 60.0
end


----------------------
-- beh_acceleration --
----------------------
function beh_acceleration._update(self, parent)
	if parent.ax == nil or parent.ay == nil
	or parent.vx == nil or parent.vy == nil then
		return nil
	end
	parent.vx += parent.ax / 30.0
	parent.vy += parent.ay / 30.0
end


----------------
-- beh_bounce --
----------------
function beh_bounce._update(self, parent)
	if parent.vx == nil or parent.vy == nil then
		return nil
	end
	
	if (parent.x < 0 and parent.vx < 0)
	or (parent.x > width and parent.vx > 0) then
		parent.vx = -parent.vx
	end
	if (parent.y < 0 and parent.vy < 0)
	or (parent.y > height and parent.vy > 0) then
		parent.vy = -parent.vy
	end
end


---------------------------
-- beh_flip_with_velocity --
---------------------------
function beh_flip_with_velocity.setup(self, parent)
	parent.flip = parent.flip or {}
	
	parent.flip.with_vel_x = true
	parent.flip.with_vel_y = true
	parent.flip.invert_x = false
	parent.flip.invert_y = false
	
	return self
end

function beh_flip_with_velocity._update(self, parent)
	if parent.vx == nil or parent.vy == nil
	or parent.flip.x == nil or parent.flip.y == nil then
		return nil
	end
	
	if with_vel_x then
		if invert_x then
			parent.flip.x = parent.vx > 0
		else
			parent.flip.x = parent.vx < 0
		end
	end
	if with_vel_y then
		if invert_y then
			parent.flip.y = parent.vy > 0
		else
			parent.flip.y = parent.vy < 0
		end
	end
end


---------------------------
-- beh_display_sprite --
---------------------------
function beh_display_sprite.setup(self, parent)
	parent.sprite = parent.sprite or {}
	parent.flip = parent.flip or {}
	
	parent.sprite.sheet = fetch("./gfx/0.gfx")
	parent.sprite.i = 0
	
	parent.flip.x = false
	parent.flip.y = false
	
	return self
end

	
function beh_display_sprite._draw(self, parent)
	spr(parent.sprite.sheet[parent.sprite.i].bmp, parent.x, parent.y, parent.flip.x, parent.flip.y)
end
:: entities.lua
--[[pod_format="raw",created="2024-04-29 21:34:20",modified="2024-05-06 05:10:51",revision=2363]]
include "protos.lua"
include "behaviors.lua"

-- List of Entities --
ent_player = entity_proto:new()


----------------
-- ent_player --
----------------
ent_player.behaviors = {
	beh_display_sprite:setup(ent_player),
	beh_flip_with_velocity:setup(ent_player),
	
	beh_acceleration,
	beh_velocity,
	beh_bounce,
}

ent_player.sprite.sheet = fetch("./gfx/characters.gfx")
ent_player.sprite.i = 0

ent_player.flip.with_vel_y = false

function ent_player._update(self)

end
:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAIAAADe_FMwAAAa50lEQVR4Ae3dsYvjSNrHcZXH
oZlLj6ZxNpMszQTKOtlNjWeyngFh6OSgMXR04Gjv6MDcu5HhIoMZuNAoGGU7c5PuJs6U9f4DTnrT
hc71BrX3bG2VJJdkyS27vx_EuqpUVSqV2j_lKvvt1wAA0D39Q9-wh5_6tQHff6f--uv-PndqXf-8
x1sWxsK6szDpjENS2W_-mnX3VTX5Yuql8-ff7R6oc7bu-J6-nH-_463ZU6p6i4q2rvbP0rrdAcZ6
LticvPxGVZexzyNXHV70Nssv1dvJPZ_rdvhWepVPFtD6Z2v_hHU5j7mlbnUnz-7_MVi0ezvX86--
_6w3v7xn3_eRKi2u_RfpE7s--FTyUlsij1_0RTt3v2uefMEHTjHPW9dYVRd28jj_96xE-v674Ief
Gvw5Wx-aql_49v4tfdI5J6CtZZV-YBv4D5DPpn4xVmPRd7U8smUqs_AZ9M4OWlsp323rA151NnOq
Sv8u7pLc2ayluveyZttzwbmT_1Rzd7ikp-tEOx_hqH-J2yx-0fV2cufbdKtFj9nqq8QBPpyVvh92
QBf9H-jcrGZqSzpLnprxan1LreSt_pWumNHWw5qfK5_vn8_rKv8ElvQ3B1qN1lLdHKz3y7QiI3dh
7vLKq_4Ol2SK_0SVvoglW2TeuuRSIztpjSqq5i677VdZss6OJ53-5ndh8dYySp7FDmj3M-sET2sm
cjcnbOElHeYf1EycqjN4Lnjnz37-5-V8hDb_P8056_3kzlH_G9jeq9QdupnR5V84n38h-3_MnTO3
nfg5AW1_t8sXkbv6Oiv_4ac-hamuNpWqjU-Y6D_Z-3bV_ymWvLhKPz--BZfMmTtJvRTweYQ2wsWa
s8ZO7hxVPtX_C-B5lTr6O5jObav6yPW_svUDuuqbbn6HfvjpT0mqyxKyReFrVq0ZrGqVrbceUFqk
YG6X_X-vfuGt2dzJ9-nXMRfmtlhX5b7uyust2Jzc7OYu2J3E2kD37rlPvfMRdq6k-G0WXbLmrLeT
1ihrHv8NrL0Az-_9A6Wz9ZvVP_fSH2zuJ6olnj9Sa3sb3FuV-fbr4T5PuSH75L7-7kD-i9X-OUoC
qCML6_yOsbBmF_YZVWhWjy04Ct38eQNolTq-ThqeMY3ZVgDwdzMe5bb32BoA6IJv330jBwENAB1K
Z7e6V0CrNPbptl7NPLvt7Okz1WCeyLmGegMH88Rz4J7LA-B81A9oz3QOgmAyXTTYrZse7674ZwLQ
lYDOwsin23o1W69mZlmquS3S7hbcgSVZKYk5mCf6kKo0mh18rrqz5bJmsyaxlgcARfpt32AyXZhJ
OpkudLzqdl31SXkZaFV9ZtBpOJgnVsFtfLy7KrlqXqrEvS8A7NQ70nWvVzMz92vEZb2Bg3kymCdV
B9YbBeCZ6x-puifTRaV83CeX3XAfzBP-2aQzGQ2gkl7tkSqN5VxivZrJ2Q3Z9WqmD6u-XLJ6lgws
T9WiPH28uxrMEzNwpcW9qstmZytzrVHuhABQIWbPrxsOjp2RfWBmngJAB92MR9___8Zq-PnHX3on
-_SkM4AjdfoBDQAENACgGwGt0lilsU-P9Wrm2W1nT5_pBvNEzgczmCeed3yS5QF4RgGt0jgLoyyM
fDJ6Ml34zOnZrZse7674ZwLQiYDOwsiz53o1W69mZlmquS3S7hbcgSVZaSbmYJ7oo6Sae8m6mtvB
Zc7mTuIuDwBy9fcZrNJ4Z1JPpgszSSfThY5X3a6rPikvA63qzhkG88QK69yqFMyqddUa68_6BQD4
6LWazu1Zr2Zm7peH42CeDOZJSYJ7Xt05Vb1bAECu-jGmcxAEk_nCv-Pj3ZVOSV3IvVo_1nOqonSW
UfzDAfDXqz1SpbE_yrutVzM5uyG7Xs30YfWXS1bPkoEl_agPnZKPd1fS4lbddDavWlO5mWvNaU3C
fxuAajF7ft1wcOyMbACA6WY8_vbdN1bjzz-_0mNrAKCbCGgAIKABAIcJaJXGKo19eq5XM89uO3v6
TDWYJ3Iu6eBWB-Mkd1RRe41bA0CRn3-8RY69AlqlcRZGWRj5ZPRkuvCZ07Nb4x7vrqxCUQcAaM_3
776RY6_AzsLIs_d6NVuvZmZZqrkt0u4W3IEleSqpOpgnZkHOVsGTNZs1g3VrAPD384_-yKFb_rXn
Umnsk9ST6cJM0sl0oeNVt_uqT8rLQKvqOYMZ34N5Ihmqq-vsqZ7KnBMAavj23TdWS-2A1tGs0nhn
RrfBDP2ntWe_A0CRmgH9VLksJtNFR9L58e6KmAbQhl69YVkYqTT2ien1aiZnN2TXq5k_rP5yyepZ
MrDI493VYJ6YAWq2mGfJXKtgVq3Z3MkBoCnq-LrhcFFpzLYCgL_b8ejbd99YjT--_EuPrQGAbiKg
AYCABgAcLKBVGrODANC5gCadAaCLAa3SOAsjtg8AOhfQAIDuBrRKYzkDABrXrzcsCyOdzroAAGhc
jy0AgBMM6CyM2EEA6GJAAwAIaAAgoAEARx3QKo3laHZBN_ORPhqcreSqfxUADqxfe2QWRo2v5mY8
_vjla_Oz1Zu2wZUAQA29jq-vZjy6GY_ssrRYHXZGrTWbO6dZte7r3rSkAwA8ZUCrNFZp3HYof-zy
9eOXr2b1ZjySFl02O1i5bMWo2Vmntm4pqppTuTe1prWGAMCe_vWGZWEkMS3lorS1EtOs5g4xu_Um
b9H8uVNJhvrMVoOV_Ps-PoBn6Ocff-n23TdmtX5AV8qvkurO8HWD1X9CGd5sJlo5634Gmnp8AM8t
o62WmgGt0lgXsjBqNs2tLLaisKR-bjjqq-qS27mogxRyM9dMZPPjQfgCaJY6v04anvF-2X3CzFgH
gEYihYAGgKMJ6B5bAwDdREADwMkFtEpjlcZde57tZrndLHmvAE5Av3Y6Z2HUzUcaXt7yXgE834Cu
ZL2a6cJkupCqVV6vZrrF6gAABHRlKo2DIMjCaGc6m1lsRrMuSDqbZ7ODabtZSnl4eetedRsB4NkF
tI5mlcY7M9qN7NodyvN3eHlLRgMgoH1NpgszcNer2WS6sFJYtxRVTdvN0jOsAeCZBnQWRiqNdcEn
oyWRrbwuD3Q3qQllAM_HOr9OGp4xja0WieYDPM92syTHARyXm-Eot71-gHsfJpo1ohnAyeixBQBA
QAMA2g9olcZysIntGcwTOeuCefjPUHTJnMed1myxVgLgAPr1hmVhJEnNJh7M492VTkldaHxCs9rg
XQDU0_vagtarmT6sFqtc1OEkE7k8KAfzZDBPrKpukbPZob2VAGhWf5-BKo2zMGp8TZPpQseuLrhV
XTbPZofjst0spTy8vK06fDBPdGjqglQlVa0Wd7gZu1Y1twXAEQR0S_nsWq9me3boshqhnBuyZiL7
R6oZ7rmjZEIAxxTQh7FezSbThZXCuqWoely2m_WeYW2lqpW5AAjotkymCzOayzscY1LXC2Uzjgfz
JLdsNVbNa3O2kq-LnusHUEKdX_-4EVaeMY3Z1ueAdAaacjMe5bb32BrUQzoDbSOgAYCABgAcJqBV
Gqs07shjrFezSu0l8_QOyW2vOnkNg3kiZ12Qckm7O0PVO7bRueS5ADQZ0CqNszDKwqg7Gd1Iyk_m
i8l04V7KbTy8x7ur3KrVDuBZB3TbQblezcxyUdXq7I7Nna3GMsovld90-0TOzd-BPBnMk9x2q2BW
9ajcgVaf3LuYw63ObrVkbMlzARD9esOyMFJprAuNr2kyXeiM04WSqjRKGppXzQ65M1uZK2drZquz
dVO3Z_78RbabpZSHl7eVsrsoZ3OTV9JQF8wWa05pl7IuWEPcFreDO9Z-zQBqBrRKYx3NUmiQpG3j
Y0uuumle_6aVJqkUyvXkZrH-WPeTUDRb7bsAaDKg2yMpKamnC5J6VrV8rP-VfdSLdW27WTYb1hKj
VoukZ3nIlmeurnomvnkjd1UAdlLn1zV-NiqNgyDIwii3fc_MluCTVLVCNrezW7UC3ZrZSlj3Xj7z
lC_4cZJ6kncSmlae6hiVMLWq5mxWFptTmXex7uiux7177vqLwn27WTbyiQKOzs141HBAlwd3U3YG
NEpCvFI_Nr4G60YlqyKdQUAfZUADwLMN6B5bAwDdREADwMkFtEpjlcaHX-F6Ncstn6TBPJGzLki5
pN2dwXN_AKcQ0CqNszDKwuhJMvrZery7yq1a7QCedUC3ar2arVczKZsFOZvtUs4da3U4xkTOzd-B
PBnMk9x2q2BW9Si5VDI-gCfXrzcsCyOVxi2taTJd6GDVBeuS1W52lktuobO2m6WUh5e3lbI7N6Bz
DeaJpLAumC0ATiqgdUYHQdBGTK9Xs2azvssqhXI9ZDHw7AK6JevVTKdqgzHdZdvNstmwfry7GswT
t0UyWl8lsoFTDmiVxkEQZGHU7IIm04UZzVbVbNE57nmps2qEsk5bnbNW8uqyPpsxbWb0zmjebpaN
fCoA7EmdX--xM25mxjRmW5_WjubcIDYDnXQGOuJmPCKgAeCYArrH1gBANxHQAHASAa3S2Cyb1Y5Y
r2an9HoG80TO0mJWrc5Fl8xJ3DkBHH1AW_mchVEWRl3L6Ml0ccJvazBPHu_uHu_u3HgtuUQcA0eq
79-VjeM20nm9mumQNQuSvLrRapFoNtvdgceY4I93V3L2SduiS2Zw584J4LgD2qLS2I3sw_S1GcFm
4EpG5-Z3h3fBdrOU8vDydmf-wTwx09bzEoDnFdBZGB1miZK5ksJuIncqcyvxCWXT491VjUtA27ab
ZdV-ZrQY0G2HsmRuefjqq2b-o-u3rh3WABl92nr_XVUayzkLI5XGKo2zMGo7ndermT5ye_pDYlrO
MrDjwT28vJVjZ_fHu6vBPBnMk8e7K90ymCc7L0nZbCn5TgD7ZDSb0CB1fl34o605YxqzrUf3o-L5
PACe0cy-U1U341Fue5_tAT8n8L-UTT22AEAj0Ty8vN1ulmwFAQ2gozHNJjxZQKs0LqkW2W6WfFcB
oMWArpfOfFQBoJ4XL9988O17dqEe7oOzi-yqBPfDvTv0738b--s--2W7AcAVvn6V2947zO2Hl7fb
zZLXAAD_DhTQ281yeHnLdgNA5wIaANBiQKs0lrNbBQA0S51fJw3P6ET2drMMgmB4ect2A4DrZjzK
be8f4N5EMwDU0GMLAICABgC0FtAqjc2yWQUANOvFyzcfqqXz2YUuZ2EUnF2oNNYtf3R7uGdbAcBf
_PrVvgEdnF2oh-vf4-h-ofxHCwENAI0GdG_fSVUaZ2HE5gJAG_oHNOkMAF0MaNIZADoU0CqN5awL
_mATAaANL16__eDb9_zi98Ms66qZ4w-3bCsA_Atfv8pt77E1ANBNBDQAENAAgPYCWqWxWTarlaxX
s6IW85LbzTWYJ2a5pAoAJxvQVjpnYZSFUb2MnkwXjazeiuPHu6vHuyvdaFUB4Oj0-buacZyFkeeo
9WomcazL69XMzGhdNctmB6uzlc4785d0BvAsAtqiw9o-qYVktBnfEsRmoJsxPZkutpultA8vb61p
Jawf7678ExwAOqtXe2QWRlkY6ZjeSRJ5H8PLWzkkgs3z492VmciS1ABwjPr1hqk0zsLowGvdbpZm
WOv81bnMiwRwetT5deIfyrqgo1lX3ZiWbmK9mk2mC33WVd2eW5UWa4hctZgBPZgnQRAUVQGgm27G
o30DumqOAwD2CegeWwMA3URAAwABDQBoL6BVGpdUc61Xs3od3PbyqQbzZDBPzLLbwvsGcET6raaz
j8l0sf8kg3nyeHclBV3WVfcqbx3AqQV0FkYSyiqNzWq59WpmBrFZzb2Ue1WXrf7CJ3Z1WAPACQZ0
bZKwk_lCn6WqWySdzSy2BppjgyDYbpYy--DyViLYTGqzqstkNIAj0qs9UqWxnCtZr2YSwbUNL2-l
2JnOQRCYZQA4Cv16w7Iw0umsC5VMpouidv-g3m6WZlhbcQwAJ6Dn31WlsZxr0ymsjyAIzLO_WhTf
5lgdynLoq4N5og934OPdlb5EiAM4Iur8OifR9ppxjwTX4VuS0QBwem7Go9z2fqdWSTQDgOixBQBA
QAMAWgtolcZSkINNBIA29Guks5aFEdsHAO158fLNB9__Zxfq4T44uwiCQAo5Of5wz7YCgL-w9avc
9l7tGVUaqzRmZwGgJS9evvlQIZQf7oOziyAIgrMLfag0-r3F7AMA8Ba_fpXb3mNrAKCbKgS0SmPz
rI8sjNhEAGjDi5dvPvj2Pbv4-bDKVo4-3LOtAOAvfP0qt73H1gBANxHQANBRfbagy7Zv35vV4edP
7AnwfPQq9VZpbJbNaiNuxiPzMButDtaQ2rdrdvElMzd7LwDPQb92Omdh1PhqPn75qrNMF8yyFMyq
e7WzOr48AB3U8_-aRiK36mY8uhmPdMFttHqWXC0fa85gdigvu0squS8AAroalcYqjTv_eB_-fL0Z
j-RZWsyqzsePX75KwbpqzVZ0Vc_gO7idpdG9JDflfxGApV97ZBZGOqZ1oYgZZ1a6PUkqWfEq6Zx7
tXwsAHQ0oD1ZKXz4ULbyV1clavU3Q-qULM8d29TyyH0AuXr_XVUayzkLI5XGKo2zMGo7Xm-GIzND
zap71XO23IiUq7mJmTvWs4NuLBr78cvXw3_3AHSfOr9OGp4xjdnWSuTz4F7avn1vVoefP7FdwKmG
AAENAEcT0D22BgC6iYAGgJMIaJXGUpCDTQSANrx4_eZDtXQ_u-j9fHYRnF2oh-vfW6Tbwz3bCgD_
wtev9g3owjgmoAGghYDu7TOpSuMsjNhcAGhD-YAmnQGgowENAOhKQKs0ljMAoG0vXr754Nv37OL3
Q6q5Of5wz7YCgL-w9avc9h5bAwDdREADAAENAGgvoFUam2Wz2oib8Si3XNSnfCo59lyJ-00BoEH9
2umchZFZaDCjP375WhKIH7989ZzKv_chpwIATz3-rs0GcUkU6ow2I1vy2i2XRLmV_2bBHWu2mH2s
m_5cQ6VVAUCJfr1hWRipND5Mauuw1qmt4zv3UlEo516yxlozWC3mTaVdCiXzAMATBLRKYx3NUihi
5akbr0XRmTtDjWQ-JHnAkg9Gpa0AQEC3m1n7hObNeKSH1I7pw2e0uewGtwLAc9Pz76rSWM5ZGKk0
VmmchVHbeXczHkk660KNsLbmKboqHcz_5lnac_NVJiF8AexPnV8nDc_YxmwrAPi7GY9y23tsDQB0
EwENAAQ0AKC9gFZpbJbNarnt2-fbt_9rrM8aVW8S13o187nkdttulrllAHjKgLbSOQujLIx8Mnr7
9v3w86fh50-7L7eRSYIgmEwXNS5tN8vh5e0fi7m8JaMBtKfv39Uzjn3CWgrbt__t5DVbdFmfpWr1
lNn8E3y9mkkQ67JVNctmCwAcUq-eMB3WPnktISsZahl_-mRmsa7qnJWzWTWD3op4s1rCStvJdDGZ
Ltwg1mV9lX8UAIfXrz0yC6MgCHZmtA5NM1sBAD56bAEAdFPfv6tKY33Owkiquuxv_PnT9u17n6vD
z5-MFils374ffv5ktu_86Xo1k-JkutDV9Wo2mS5ye8ol6ez2BIC2qfPrpOEZ0-iE92u7WQ4vb90y
ANR2Mx7ltvfYmkrMRCadAbSKgAYAAhoA0FJAqzRWaVxUbdV6Nduzg9hultvNkhcP4HQCWqVxFkZZ
GOlQtqptm0wXDc42vLzlxQPovr5nvyyMclO78QWtVzOJY11er2aS0bpsRra0mFXpbE3F_wZwRHqV
eqs0lqQ2y62ygnUyXUhq69i1Uliuurab5fDylrcO4NQC2krkVtO5KGH3nGp4ebvdLHnrAE4qoK10
BgB0JaB1RusjCIIsjHS58dSeTBfr1UzOQRCsVzM553aWS1LVA92pAOCIqPPrpOEZ07jLD7zdLIMg
GF7e8u4BdMTNeJTb3n9uG0E0AzgWPbYAAAhoAEA7Aa3SWKWx1dKFZ1ivZkVVq2z1rGcwT_R8yLEA
COjCdM7CKAsjCeWOpLNrMl1UageAblLn10m1AWmchZFbNjsc8gHWq5kZwbqqs9i6pFskps2e_xjM
k8e7q8E8CYJACrosHawWADDdjEe57f3a6dwROpQlZyWj3UtWrLuRLbabpZSHl7eeGS1VXZbglir-
hQAqqRDQHUznfUiOu3xC2WSmMwAcOqBPLJ2DIJhMF0WXtptl7bAOgmAwTyS1H__udBUAqlLn117x
odJYyjqppcUKbrPnwaxXM525umDmr1zKLZcntWcc6yzOre5sB4Cb8WivgK4Q_U8R0N3hBvFgngRB
QDoDIKAB4EQCusfWAEA3EdAAcPwBrdJYpXFRtUHbzXK7WfJuADxzL16__eCZzlkYBWcXKo312az_
qefD-Z5r_vd--vv3v43--Z--8noAPAfh61d7BbSksHq4D84u7GqjAR0EAQENgIDuVZpFpXEWRkXV
Bg0vb7ebJa8NwHNWIaAPls5BEGw3y_HlLa8HAAHdrXQGAFQIaB3K_sitAgCapc6vk4Zn3Duyt5tl
EATDy1teD4Dn4GY8ym3vd3CtRDMABEHQYwsAgIAGALQT0CqNVRoXVQEAzXrx8s0Hz3TOwig4u1Bp
rM9m9U89H_7ZVgDwF75_tVdASwqrh-vg7MKuEtAA0HRAAwAAADiY7Ldfn3yGVu9e3uEwj_-2qX3f
qgPbu1GDDwWcsB5bcETfsye-b0uPQDoDuVTRT0X95a9SNctuVbdkv-0q7VJ1h_uyO5vPMswb7Zw5
d83uVLlXcx_wJFNyl5H7UEWPX7I57saW3Dd3V80ZSp63aHOsDuWPUHtjzZl9-g18-ouAY9dzE0Qf
8n9v-d6scDQ75_aRGS4y1rxUMtAaa-2Yy2fOXXP5A1pjyx-Quuretzydcx_naJHm8J33tapW8JU8
r3Vf9-FzH6HoHdXeWHefd75NfsY4Vf3yy0Vx48P65fhPZf2Sq85ccqOdMz8Vc83uIq2QbUmlzXHT
tpsbC5xsQEsuSHzs8yOsNEru6xkW-jeqNHOD_euzqqJF6vjzXLD5jqo_Zskot9FdZBsbW-IvJ18F
4FkEtPkfr-7yV-cH4P5E5fdT-mvZObP7m5TbWWP9Z85NmZIQNx_nqGXn43t_UczHt9acu0gzo8vv
65_P1lj3viUPZXXec2N1WR7QTHnPzy2-ZJx_QOdG8M4f_c5y1ZnLx1aa2fqdF-UsiQOfgNjzicrn
yV1bvfuWP29Rtvq8vj031vN-w53N-6MIAADQmP8HZN76M6p2NqoAAAAQdEVYdExvZGVQTkcAMjAx
MTAyMjHjWbbBAAAAAElFTkSuQmCC
:: main.lua
--[[pod_format="raw",created="2024-04-29 20:25:15",modified="2024-05-06 05:10:51",revision=2573]]
include "protos.lua"
include "scenes.lua"
include "util.lua"

-- Game Settings --
game = {
	name          	= "Test RPG",
	author 			= "lilykp",
	version 			= "0.0.1",
}

save = {
	appdata_folder = "lilykp_testrpg", -- name of subfolder in /appdata to save to
	version = 1, -- increment when migrations are needed
	data = {
		-- can put in defaults here
	},
}

width=480
height=270

-- TODO make a thing to easily make shortcuts (like menu but without menu)
-- then make Ctrl+5 and Ctrl+9 quicksave and quickload

-- Main Functions --
function _init()
	window{
		title = "rpg"
	}
	
	menuitem{
		id = 0,                   -- unique identifier. integer ids are used to sort items (otherwise in order added)
		shortcut = "CTRL-Q",      -- drawn right justified in menu
		action = function(b)
			stop("Application force closed",0,0,8)
		  end
	}
	
	world = world_proto:new_named("World")
	--gui = create_gui()

	debug:info("test")

	world:start(sce_sandbox)
end

function _draw()
	world:_draw()
	debug:_draw() -- TODO move out to main
end

function _update()
	game:_update()
	world:_update()
	debug:_update()
end


-- Game Functions --
function game:_update()
	if keyp({"ctrl","q"}) then
	  -- TODO cant yet detect multiple, lib/events comments say it will accept table
	  -- but its unimplemented, so for now use menuitems
	end
end

-- Save Functions --
function save:save(file_name)
	local path = "/appdata/"..self.appdata_folder.."/"..file_name..".sav"	
	local folders = ls("/appdata/")	
	
	local make_dir = true
	if folders ~= nil then
		for i,v in pairs(folders) do
			if v == self.appdata_folder then
				make_dir = false
				break
			end
		end
	end
	if make_dir then
		mkdir("/appdata/"..self.appdata_folder)
	end
	
	store(path,save.data)
	debug:info("Saved to "..path)
end

function save:load(file_name)
	local path = "/appdata/"..self.appdata_folder.."/"..file_name..".sav"
	local files = ls("/appdata/"..self.appdata_folder.."/")

	local d = nil
	if files ~= nil then
		for i,v in pairs(files) do
			if v == file_name..".sav" then
				d = fetch(path)
				break
			end
		end
	end

	if d ~= nil then
		for k,v in pairs(d) do
			self.data[k] = v
		end
	else
		debug:warn("Unable to load. No file at "..path)
	end
end



--include "./lib/error_explorer/error_explorer.lua"
--[[-------------- DOCUMENTATION --------------))--

### Order of Operations ###
This order is the same for init, draw, and update

- scene function
- for all scene ents
   - ent function
   - for all ent behaviors
      - behavior function
- for all persistet ents
   - for all ent behaviors
      - behavior function

### Random Lua Notes ###
when doing for loops use
- ipairs for array
- pairs for table

--((------------ END DOCUMENTATION ------------]]--
:: protos.lua
--[[pod_format="raw",created="2024-05-05 04:59:35",modified="2024-05-06 05:10:51",revision=1867]]
include "util.lua"

-- List of Protos --
world_proto = {}
scene_proto = {}
entity_proto = {}
behavior_proto = {}

-----------------
-- world_proto --
-----------------
-- TODO support for multiple scenes loaded at once? or maybe just use multiple
-- worlds for that
world_proto.name = "world"

world_proto.active_scene = {} -- currently active scene

world_proto.scene_ents = {} -- ents from the active scene will go in here
world_proto.pers_ents = {} --[[ put ents in here that should persist between scene
									   change these are added with an id as a key so we
                                can easily access them and check for existing
                                ones before adding an entity	]]--

function world_proto:new(o)
	o = o or {}
	setmetatable(o,self)
	self.__index = self
	return o
end

function world_proto:new_named(n)
	o = {name = n}
	return world_proto:new(o)
end

function world_proto:start(starting_scene)
	self:set_active_scene(starting_scene)
end

function world_proto:set_active_scene(scene)
	self.active_scene = scene
	world.scene_ents = scene:create_ents()
	scene:_init()
	for i,ent in ipairs(world.scene_ents) do
		ent:_init()
		ent:init_behaviors()
	end
	debug:info("Loaded scene " .. scene.name)
end

function world_proto:reload_scene()
	self:set_active_scene(self.active_scene)
end

function world_proto:add_pers_ent(id, ent)
	if ent == nil then
		debug:err("Tried to add_pers_ent with no ent")
		return
	end
	self.pers_ents[id] = ent
	ent:_init()
	ent:init_behaviors()
end

function world_proto:has_pers_ent(id)
	return self.pers_ents[id] ~= nil
end

function world_proto:get_pers_ent(id)
	return self.pers_ents[id]
end

function world_proto:pers(id)
	return self:get_pers_ent(id)
end

function world_proto:_draw()
	cls(1) -- TODO change
	self.active_scene:_draw()
	for i,ent in ipairs(self.scene_ents) do
		ent:_draw()
		ent:draw_behaviors()
	end
	for i,ent in pairs(self.pers_ents)	 do
		ent:_draw()
		ent:draw_behaviors()
	end
end

function world_proto:_update()
	self.active_scene:_update()
	for i,ent in ipairs(self.scene_ents) do
		ent:_update()
		ent:update_behaviors()
	end
	for i,ent in pairs(self.pers_ents)	 do
		ent:_update()
		ent:update_behaviors()
	end
end


-----------------
-- scene_proto --
-----------------
scene_proto.name = ""

function scene_proto.new(self, o)
	o = o or {}
	setmetatable(o,self)
	self.__index = self
	return o
end

function scene_proto.new_named(self, n)
	o = {name = n}
	return scene_proto:new(o)
end

-- should be overriden to return the default state of entities in this scene
function scene_proto.create_ents()
	return {}
end

function scene_proto._init(self)
end

function scene_proto._draw(self)
end

function scene_proto._update(self)
end

--[[
In prototypes we define functions with . instead of : bc defining with : prevents us
from overriding the self argument by calling with . notation
We want to be able to override the self argument for a prototypes methods so we can
call the 'super' version of a function in the overriding function if necessary

Basically
- defined with : = only callable with :
- define with . = callable with both : and .
]]--


------------------
-- entity_proto --
------------------
entity_proto.behaviors = {}
-- dont need to use :new() because behaviors never store values -- TODO change this
-- so new can setup necessary variables in parent entity

entity_proto.x = 0
entity_proto.y = 0
entity_proto.vx = 0
entity_proto.vy = 0
entity_proto.ax = 0
entity_proto.ay = 0

entity_proto.flip = {
	x = false,
	y = false,
}

function entity_proto.new(self, o)
	o = o or {}
	setmetatable(o,self)
	self.__index = self
	return o
end

function entity_proto._init(self)
end

function entity_proto.init_behaviors(self)
	for i,beh in ipairs(self.behaviors) do
		beh:_init(self) -- pass in self as parent
	end
end
	
function entity_proto._draw(self)
end

-- do NOT override
function entity_proto.draw_behaviors(self)
	for i,beh in ipairs(self.behaviors) do
		beh:_draw(self) -- pass in self as parent
	end
end

function entity_proto._update(self)
end

-- do NOT override
function entity_proto.update_behaviors(self)
	for i,beh in ipairs(self.behaviors) do
		beh:_update(self) -- pass in self as parent
	end
end


--------------------
-- behavior_proto --
--------------------
--[[
Behaviors should NEVER have per-entity values stored within them, they should
get data from their parent if the parent has it.
If the parent NEEDS data for the behavior to work properly, you can initialize that
data in the behavior's _init.
The only values that can be stored on the component are 'static' ones that you
understand will be shared for that behavior across all entities that utilize it.
]]--
function behavior_proto.new(self, o)
	o = o or {}
	setmetatable(o,self)
	self.__index = self
	return o
end

-- can be overriden to initialize variables in parent
-- this function is used when adding behaviors to an entity
-- this allows it to run before additional variables are set on the entity
function behavior_proto.setup(self, parent)
	return self
end

function behavior_proto._init(self, parent)
end

function behavior_proto._draw(self, parent)
end

function behavior_proto._update(self,parent)
end


:: scenes.lua
--[[pod_format="raw",created="2024-05-05 04:37:49",modified="2024-05-06 05:10:51",revision=1878]]
--[[----------- TODO -----------))--

- Have scenes able to define a .map file and a section of that .map file to serve as
  the scene.

--((--------- END TODO ---------]]--
include "protos.lua"
include "entities.lua"

-- List of Scene Names --
sce_sandbox = scene_proto:new_named("Sandbox Scene")


-----------------
-- sce_sandbox --
-----------------
function sce_sandbox.create_ents(self)
	return {
		-- can do like conditional entity creation, for example if smthn shouldnt spawn
		-- based on a bool in save data
	}
end

function sce_sandbox._init(self)
	if not world:has_pers_ent("player") then
		world:add_pers_ent("player",
			ent_player:new({
				x=0,y=height/2,
				vx=30,vy=0,
				ax=0,ay=9.8
			}))
	end
end

function sce_sandbox._draw(self)
	map()
end

:: util.lua
--[[pod_format="raw",created="2024-05-05 04:43:06",modified="2024-05-06 05:10:51",revision=1957]]
debug = {
	enabled = true,
	visible = true,
	log_file = "/log.txt",
	lines = {}, -- auto regenerated when log changes
	
	enable_print_info = true,
	enable_print_warn = true,
	enable_print_err = true,
}

store(debug.log_file, "") -- fresh log file on init

function debug:_draw()	
	if not self.visible then return end
	for i=0, 9 do
		if #self.lines-i <= 0 then
			break
		end
		local newline = self.lines[#self.lines-i]
		local pre = newline:sub(23,27)
		local col = 7
		if pre == "[INFO" then col = 12
		elseif pre == "[WARN" then col = 10
		elseif pre == "[ERR]" then col = 8 end
		
		print("\014"..self.lines[#self.lines-i], 3, (height-(8*i)), col)
	end
end

function debug:_update()
	if not self.enabled then return end
	if keyp("`") then
		self.visible = not self.visible
	end 
end

function debug:info(text)
	if debug.enable_print_info then
		debug:log_line("[INFO] " .. text)
	end
end

function debug:warn(text)
	if debug.enable_print_warn then
		debug:log_line("[WARN] " .. text)
	end
end

function debug:err(text)
	if debug.enable_print_err then
		debug:log_line("[ERR] " .. text)
	end
end

-- info 12
-- warn 10
-- err 8
function debug:log_line(text)
	local timestamp = date("%Y-%m-%d %H:%M:%S > ")
	local newline = timestamp..text.."\n"
	local t = fetch(debug.log_file)..newline
	store(debug.log_file, t)
	debug.lines = split(t, "\n", false)
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI4OjE1Iixtb2RpZmllZD0iMjAyNC0w
NS0wNiAwNToxMDo1MSIscnVudGltZT03LHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEj
MzYiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InV0aWwubHVhIzE0Iix3b3Jrc3BhY2Vf
aW5kZXg9MX0se2xvY2F0aW9uPSJwcm90b3MubHVhIzg3Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJiZWhhdmlvcnMubHVhIzE3Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJl
bnRpdGllcy5sdWEjMjEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InNjZW5lcy5sdWEj
NCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5k
ZXg9Mn0se2xvY2F0aW9uPSJnZngvY2hhcmFjdGVycy5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7
bG9jYXRpb249Im1hcC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAu
c2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV1sejQABAAAAAMAAAAwbmls
:: [eoc]
