picotron cartridge // www.picotron.net
version 2

:: gfx/
:: map/
:: sfx/
:: vgfx/
:: lib/
:: behaviors.lua
--[[pod_format="raw",created="2024-05-05 05:54:19",modified="2024-05-13 22:14:44",revision=2509]]
--[[----------- TODO -----------))--

- Have an event system that propogates through entities and behaviors
- Better way for default values for variables a behavior might use, instead of having
  all the defaults on the prototype

--((--------- END TODO ---------]]--
include "protos.lua"

-- List of Behaviors
beh_velocity = behavior_proto:new()
beh_acceleration = behavior_proto:new()
beh_bounce = behavior_proto:new()
beh_flip_with_velocity = behavior_proto:new()
beh_display_sprite = behavior_proto:new()


------------------
-- beh_velocity --
------------------
function beh_velocity._update(self, parent)
	if parent.vx == nil or parent.vy == nil then
		return nil
	end
	parent.x += parent.vx / 60.0
	parent.y += parent.vy / 60.0
end


----------------------
-- beh_acceleration --
----------------------
function beh_acceleration._update(self, parent)
	if parent.ax == nil or parent.ay == nil
	or parent.vx == nil or parent.vy == nil then
		return nil
	end
	parent.vx += parent.ax / 30.0
	parent.vy += parent.ay / 30.0
end


----------------
-- beh_bounce --
----------------
function beh_bounce._update(self, parent)
	if parent.vx == nil or parent.vy == nil then
		return nil
	end
	
	if (parent.x < 0 and parent.vx < 0)
	or (parent.x > width and parent.vx > 0) then
		parent.vx = -parent.vx
	end
	if (parent.y < 0 and parent.vy < 0)
	or (parent.y > height and parent.vy > 0) then
		parent.vy = -parent.vy
	end
end


---------------------------
-- beh_flip_with_velocity --
---------------------------
function beh_flip_with_velocity.setup(self, parent)
	parent.flip = parent.flip or {}
	
	parent.flip.with_vel_x = true
	parent.flip.with_vel_y = true
	parent.flip.invert_x = false
	parent.flip.invert_y = false
	
	return self
end

function beh_flip_with_velocity._update(self, parent)
	if parent.vx == nil or parent.vy == nil
	or parent.flip.x == nil or parent.flip.y == nil then
		return nil
	end
	
	if with_vel_x then
		if invert_x then
			parent.flip.x = parent.vx > 0
		else
			parent.flip.x = parent.vx < 0
		end
	end
	if with_vel_y then
		if invert_y then
			parent.flip.y = parent.vy > 0
		else
			parent.flip.y = parent.vy < 0
		end
	end
end


---------------------------
-- beh_display_sprite --
---------------------------
function beh_display_sprite.setup(self, parent)
	parent.sprite = parent.sprite or {}
	parent.flip = parent.flip or {}
	
	parent.sprite.sheet = fetch("./gfx/0.gfx")
	parent.sprite.i = 0
	
	parent.flip.x = false
	parent.flip.y = false
	
	return self
end

	
function beh_display_sprite._draw(self, parent)
	spr(parent.sprite.sheet[parent.sprite.i].bmp, parent.x, parent.y, parent.flip.x, parent.flip.y)
end
:: entities.lua
--[[pod_format="raw",created="2024-04-29 21:34:20",modified="2024-05-13 22:14:44",revision=3210]]
include "protos.lua"
include "behaviors.lua"

-- List of Entities --
ent_player = entity_proto:new()


----------------
-- ent_player --
----------------
ent_player.behaviors = {
	beh_display_sprite:setup(ent_player),
	beh_flip_with_velocity:setup(ent_player),
	
	beh_acceleration,
	beh_velocity,
	beh_bounce,
}

ent_player.sprite.sheet = fetch("./gfx/characters.gfx")
ent_player.sprite.i = 0

ent_player.flip.with_vel_y = false

function ent_player._update(self)

end
:: scenes.lua
--[[pod_format="raw",created="2024-05-05 04:37:49",modified="2024-05-13 22:14:44",revision=2757]]
--[[----------- TODO -----------))--

- Have scenes able to define a .map file and a section of that .map file to serve as
  the scene.

--((--------- END TODO ---------]]--
include "protos.lua"
include "entities.lua"
include "debug.lua"

-- List of Scene Names --
sce_sandbox = scene_proto:quick("sce_sandbox", "Sandbox Scene")

-----------------
-- sce_sandbox --
-----------------
function sce_sandbox.create_ents(self)
	return {
	--[[
		ent_player:new({
			x=0,y=height/2,
			vx=30,vy=0,
			ax=0,ay=9.8
		})
	]]--
		-- can do like conditional entity creation, for example if smthn shouldnt spawn
		-- based on a bool in save data
	}
end

function sce_sandbox._init(self, w)
	debug:info("INITING WORLD "..w.name)
	if not w:has_pers_ent("player") then
		w:add_pers_ent("player",
			ent_player:new({
				x=0,y=height/2,
				vx=30,vy=0,
				ax=0,ay=9.8
			}))
	end
end

function sce_sandbox._draw(self)
	map()
end
:: scenes_gui.lua
--[[pod_format="raw",created="2024-05-13 20:23:21",modified="2024-05-13 22:14:44",revision=205]]
include "protos.lua"
include "entities.lua"

-- List of Scene Names --
gui_main = scene_proto:quick("gui_main", "GUI Main")

--------------
-- gui_main --
--------------
function gui_main.create_ents(self)
	return {
		entity_proto:new{
			behaviors = {
				-- TODO button proto
			}
		}
	}
end

function gui_main._draw()
	rectfill(0, 270-32, 480, 270, 11)
end
:: gui/
:: world/
:: world/behaviors.lua
--[[pod_format="raw",created="2024-05-05 05:54:19",modified="2024-05-13 22:21:49",revision=2554]]
--[[----------- TODO -----------))--

- Have an event system that propogates through entities and behaviors
- Better way for default values for variables a behavior might use, instead of having
  all the defaults on the prototype

--((--------- END TODO ---------]]--
include "protos.lua"

-- List of Behaviors
beh_velocity = behavior_proto:new()
beh_acceleration = behavior_proto:new()
beh_bounce = behavior_proto:new()
beh_flip_with_velocity = behavior_proto:new()
beh_display_sprite = behavior_proto:new()


------------------
-- beh_velocity --
------------------
function beh_velocity._update(self, parent)
	if parent.vx == nil or parent.vy == nil then
		return nil
	end
	parent.x += parent.vx / 60.0
	parent.y += parent.vy / 60.0
end


----------------------
-- beh_acceleration --
----------------------
function beh_acceleration._update(self, parent)
	if parent.ax == nil or parent.ay == nil
	or parent.vx == nil or parent.vy == nil then
		return nil
	end
	parent.vx += parent.ax / 30.0
	parent.vy += parent.ay / 30.0
end


----------------
-- beh_bounce --
----------------
function beh_bounce._update(self, parent)
	if parent.vx == nil or parent.vy == nil then
		return nil
	end
	
	if (parent.x < 0 and parent.vx < 0)
	or (parent.x > width and parent.vx > 0) then
		parent.vx = -parent.vx
	end
	if (parent.y < 0 and parent.vy < 0)
	or (parent.y > height and parent.vy > 0) then
		parent.vy = -parent.vy
	end
end


---------------------------
-- beh_flip_with_velocity --
---------------------------
function beh_flip_with_velocity.setup(self, parent)
	parent.flip = parent.flip or {}
	
	parent.flip.with_vel_x = true
	parent.flip.with_vel_y = true
	parent.flip.invert_x = false
	parent.flip.invert_y = false
	
	return self
end

function beh_flip_with_velocity._update(self, parent)
	if parent.vx == nil or parent.vy == nil
	or parent.flip.x == nil or parent.flip.y == nil then
		return nil
	end
	
	if with_vel_x then
		if invert_x then
			parent.flip.x = parent.vx > 0
		else
			parent.flip.x = parent.vx < 0
		end
	end
	if with_vel_y then
		if invert_y then
			parent.flip.y = parent.vy > 0
		else
			parent.flip.y = parent.vy < 0
		end
	end
end


---------------------------
-- beh_display_sprite --
---------------------------
function beh_display_sprite.setup(self, parent)
	parent.sprite = parent.sprite or {}
	parent.flip = parent.flip or {}
	
	parent.sprite.sheet = fetch("./gfx/0.gfx")
	parent.sprite.i = 0
	
	parent.flip.x = false
	parent.flip.y = false
	
	return self
end

	
function beh_display_sprite._draw(self, parent)
	spr(parent.sprite.sheet[parent.sprite.i].bmp, parent.x, parent.y, parent.flip.x, parent.flip.y)
end
:: world/entities.lua
--[[pod_format="raw",created="2024-04-29 21:34:20",modified="2024-05-13 22:21:49",revision=3255]]
include "protos.lua"
include "content/behaviors.lua"

-- List of Entities --
ent_player = entity_proto:new()


----------------
-- ent_player --
----------------
ent_player.behaviors = {
	beh_display_sprite:setup(ent_player),
	beh_flip_with_velocity:setup(ent_player),
	
	beh_acceleration,
	beh_velocity,
	beh_bounce,
}

ent_player.sprite.sheet = fetch("./gfx/characters.gfx")
ent_player.sprite.i = 0

ent_player.flip.with_vel_y = false

function ent_player._update(self)

end
:: world/scenes.lua
--[[pod_format="raw",created="2024-05-05 04:37:49",modified="2024-05-13 22:21:49",revision=2802]]
--[[----------- TODO -----------))--

- Have scenes able to define a .map file and a section of that .map file to serve as
  the scene.

--((--------- END TODO ---------]]--
include "protos.lua"
include "debug.lua"
include "content/entities.lua"

-- List of Scene Names --
sce_sandbox = scene_proto:quick("sce_sandbox", "Sandbox Scene")

-----------------
-- sce_sandbox --
-----------------
function sce_sandbox.create_ents(self)
	return {
	--[[
		ent_player:new({
			x=0,y=height/2,
			vx=30,vy=0,
			ax=0,ay=9.8
		})
	]]--
		-- can do like conditional entity creation, for example if smthn shouldnt spawn
		-- based on a bool in save data
	}
end

function sce_sandbox._init(self, w)
	if not w:has_pers_ent("player") then
		w:add_pers_ent("player",
			ent_player:new({
				x=0,y=height/2,
				vx=30,vy=0,
				ax=0,ay=9.8
			}))
	end
end

function sce_sandbox._draw(self)
	map()
end
:: world/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTEzIDIyOjE2OjM3Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMjoyMTo1MCJdXWx6NAAEAAAAAwAAADBuaWw=
:: content/
:: util.lua
--[[pod_format="raw",created="2024-05-05 04:43:06",modified="2024-05-13 17:23:22",revision=1966]]
debug = {
	enabled = true,
	visible = true,
	log_file = "/log.txt",
	lines = {}, -- auto regenerated when log changes
	
	enable_print_info = true,
	enable_print_warn = true,
	enable_print_err = true,
}

store(debug.log_file, "") -- fresh log file on init

function debug:_draw()	
	if not self.visible then return end
	for i=0, 9 do
		if #self.lines-i <= 0 then
			break
		end
		local newline = self.lines[#self.lines-i]
		local pre = newline:sub(23,27)
		local col = 7
		if pre == "[INFO" then col = 12
		elseif pre == "[WARN" then col = 10
		elseif pre == "[ERR]" then col = 8 end
		
		print("\014"..self.lines[#self.lines-i], 3, (height-(8*i)), col)
	end
end

function debug:_update()
	if not self.enabled then return end
	if keyp("`") then
		self.visible = not self.visible
	end 
end

function debug:info(text)
	if debug.enable_print_info then
		debug:log_line("[INFO] " .. text)
	end
end

function debug:warn(text)
	if debug.enable_print_warn then
		debug:log_line("[WARN] " .. text)
	end
end

function debug:err(text)
	if debug.enable_print_err then
		debug:log_line("[ERR] " .. text)
	end
end

-- info 12
-- warn 10
-- err 8
function debug:log_line(text)
	local timestamp = date("%Y-%m-%d %H:%M:%S > ")
	local newline = timestamp..text.."\n"
	local t = fetch(debug.log_file)..newline
	store(debug.log_file, t)
	debug.lines = split(t, "\n", false)
end
:: debug.lua
--[[pod_format="raw",created="2024-05-05 04:43:06",modified="2024-05-13 22:25:03",revision=2893]]
width = width or 480
height = height or 270

debug = {
	enabled = true, -- if false, logging will not work
	visible = true, -- whether to display logged lines on screen
	
	log_file = "/log.txt", -- default filepath to save log file to -- TODO make relative to cart?
	save_when_logged = true, -- if true, save when log is made
	save_every_x_tick = 0, -- if > 0, save after this many ticks
	lines = {}, -- auto regenerated when log changes
	
	key_toggle_visible = "`",
	key_save_log = "f11",

	enable_print_info = true,
	enable_print_warn = true,
	enable_print_err = true,
}

store(debug.log_file, "") -- fresh log file on init

function debug:_draw()	
	if not self.visible then return end
	for i = 0, 9 do
		if #self.lines-i <= 0 then
			break
		end
		local newline = self.lines[#self.lines-i]
		local pre = newline:sub(23,27)
		local col = 7
		if pre == "[INFO" then col = 12
		elseif pre == "[WARN" then col = 10
		elseif pre == "[ERR!" then col = 8 end

		local c = count(newline, "\n") or 1 -- TODO doesnt work ):

		print("\014"..self.lines[#self.lines-i], 3, (height-((8*c)+8*i)), col)
	end
end

local ticks_since_save = 0
function debug:_update()
	if not self.enabled then return end
	if keyp(self.key_toggle_visible) then
		self.visible = not self.visible
	end
	if keyp(self.key_save_log) then
		self:info("Manually saved log file to "..self.log_file)
		self:save_to_file(self.log_file)
	end
	if self.save_every_x_tick > 0 then
		if ticks_since_save == debug.save_every_x_tick then
			self:save_to_file(self.log_file)
			ticks_since_save = 0
		else
			ticks_since_save += 1
		end
	end
end

function debug:info(text)
	if debug.enable_print_info then
		debug:log_line("[INFO] " .. text)
	end
end

function debug:warn(text)
	if debug.enable_print_warn then
		debug:log_line("[WARN] " .. text)
	end
end

function debug:err(text)
	if debug.enable_print_err then
		debug:log_line("[ERR!] " .. text)
	end
end

-- info 12
-- warn 10
-- err 8
function debug:log_line(text)
	if not debug.enabled then return end
	local timestamp = date("%Y-%m-%d %H:%M:%S > ")
	local newline = timestamp..text.."\n"
	add(debug.lines, newline)
	if debug.save_when_logged then
		self:save_to_file(self.log_file)
	end
	-- local t = fetch(debug.log_file)..newline
	-- store(debug.log_file, t)
	-- debug.lines = split(t, "\n", false)
end

function debug:save_to_file(file)
	local lines = ""
	for l in all(self.lines) do
		lines = lines..l
	end
	store(file, lines)
end	


-- Misc Functions --
function stringify_table(t,offset)
	offset = offset or 0
	local str = ""
	if offset == 0 then
		str = str.."{"
	end
	for k,v in pairs(t) do
		newstr = "\n"
		for i = 0, offset do
			newstr = newstr.."\t"
		end
		newstr = newstr..k.." = "
		if type(v) == "table" then
			--newstr = newstr.."TABLE"
			newstr = newstr.."{"..stringify_table(v,offset+1).."\n"
			for i = 0, offset do
				newstr = newstr.."\t"
			end
			newstr = newstr.."}"
		else
			newstr = newstr..tostring(v)
		end
		str = str..newstr..","
	end
	if offset == 0 then
		str = str.."\n}"
	end
	return str
end
:: dialogue.lua
--[[pod_format="raw",created="2024-05-13 17:14:41",modified="2024-05-13 22:25:03",revision=886]]

dg_test01 = {
	lines = {
		"line of dialogue",
		"auto line breaks thanks!",
		{dialogue:wait, {0}},       -- to run func, first arg func, second is args
		{dg:choice, {
			{"choice 1", 12}, -- choice name, line num
			{"choice 2", 16},
		}
	}
}

-- dg_obj - object containing dialogue data
-- start  - line number of the dialogue to start on
function dg:start(dg_obj, start)
	if not dg_obj then return end
	start = start or 0
	
	return "TODO UNIMPLEMENTED"
end

function dg:wait(ticks)
	return "PASS"
end

function dg:sfx(sfx)
	return "PASS"
end

function dg:choice(choices)
	return "PASS"
end
:: saveload.lua
--[[pod_format="raw",created="2024-05-13 17:53:44",modified="2024-05-13 20:29:04",revision=653]]
include "debug.lua"

save = {
	appdata_folder = "dev", -- name of subfolder in /appdata to save to
	version = 1, -- increment when migrations are needed
	data = {
		-- can put in defaults here
	},
	
	file_ext = ".sav",
	
	quicksave_pre = "quick",
	num_quicksaves = 3,
	
	presave_callback = function()
	
	end,
	postload_callback = function() -- function called on load, it should reset state
		debug:err("Load callback not implemented")
	end,
}
-- TODO use revision metadata to track num of times save overwritten?

-- Returns metadata of all save files
function save:get_all_saves()
	local path = "/appdata/"..self.appdata_folder.."/"
	local files = ls(path)
	local save_meta = {}
	for file in all(files) do
		if file:sub(-1 * #self.file_ext) == self.file_ext then
			local m = fetch_metadata(path..file)
			m.path = path..file
			add(save_meta, m)
		end
	end	
	return save_meta
end

function save:save(file_name)
	-- trim file extension if provided one
	if file_name:sub(-1 * #self.file_ext) == self.file_ext then
		file_name = file_name:sub(1, -1 * #self.file_ext - 1)
	end
	local path = "/appdata/"..self.appdata_folder.."/"..file_name..self.file_ext
	local folders = ls("/appdata/")	
	
	local make_dir = true
	if folders ~= nil then
		for i,v in pairs(folders) do
			if v == self.appdata_folder then
				make_dir = false
				break
			end
		end
	end
	if make_dir then
		mkdir("/appdata/"..self.appdata_folder)
	end
	self.presave_callback()
	store(path,save.data,{save_version = save.version})
	debug:info("Saved to "..path)
end

function save:quicksave()
	local path = "/appdata/"..self.appdata_folder.."/"
	local files = ls(path)
	-- rename old quicksaves and delete oldest if at max
	for i = self.num_quicksaves, 1, -1 do
		f = self.quicksave_pre..tostring(i)..self.file_ext
		if contains(files, f) then
			if i == self.num_quicksaves then
				rm(path..f)
			else
				mv(path..f,path..self.quicksave_pre..tostring(i+1)..self.file_ext)
			end
		end
	end
	self:save(self.quicksave_pre.."1")
end

function save:load(file_name)
	-- trim file extension if provided one
	if file_name:sub(-1 * #self.file_ext) == self.file_ext then
		file_name = file_name:sub(1, -1 * #self.file_ext - 1)
	end
	local path = "/appdata/"..self.appdata_folder.."/"..file_name..self.file_ext
	local files = ls("/appdata/"..self.appdata_folder.."/")

	local d = nil
	if files ~= nil then
		for i,v in pairs(files) do
			if v == file_name..self.file_ext then
				d = fetch(path)
				break
			end
		end
	end

	if d ~= nil then
		for k,v in pairs(d) do
			self.data[k] = v
		end
		debug:info("Loaded from "..path)
	else
		debug:warn("Unable to load. No file at "..path)
	end
	self.postload_callback()
end

function save:quickload()
	local path = "/appdata/"..self.appdata_folder.."/"
	local files = ls(path)
	local file = self.quicksave_pre.."1"..self.file_ext
	if contains(files, file) then 
		self:load(file)
	else
		debug:info("No quicksave found.")
	end
end

-- Misc Functions (move elsewhere) --

function contains(t, v)
	for f in all(t) do
		if f == v then
			return true
		end
	end
	return false
end
:: content/behaviors.lua
--[[pod_format="raw",created="2024-05-05 05:54:19",modified="2024-05-13 23:48:58",revision=2808]]
--[[----------- TODO -----------))--

- Have an event system that propogates through entities and behaviors
- Better way for default values for variables a behavior might use, instead of having
  all the defaults on the prototype

--((--------- END TODO ---------]]--
include "protos.lua"

-- List of Behaviors
beh_velocity = behavior_proto:new()
beh_acceleration = behavior_proto:new()
beh_bounce = behavior_proto:new()
beh_flip_with_velocity = behavior_proto:new()
beh_display_sprite = behavior_proto:new()
beh_saveload = behavior_proto:new()

------------------
-- beh_velocity --
------------------
function beh_velocity._update(self, parent)
	if parent.vx == nil or parent.vy == nil then
		return nil
	end
	parent.x += parent.vx / 60.0
	parent.y += parent.vy / 60.0
end


----------------------
-- beh_acceleration --
----------------------
function beh_acceleration._update(self, parent)
	if parent.ax == nil or parent.ay == nil
	or parent.vx == nil or parent.vy == nil then
		return nil
	end
	parent.vx += parent.ax / 30.0
	parent.vy += parent.ay / 30.0
end


----------------
-- beh_bounce --
----------------
function beh_bounce._update(self, parent)
	if parent.vx == nil or parent.vy == nil then
		return nil
	end
	
	if (parent.x < 0 and parent.vx < 0)
	or (parent.x > width and parent.vx > 0) then
		parent.vx = -parent.vx
	end
	if (parent.y < 0 and parent.vy < 0)
	or (parent.y > height and parent.vy > 0) then
		parent.vy = -parent.vy
	end
end


---------------------------
-- beh_flip_with_velocity --
---------------------------
function beh_flip_with_velocity.setup(self, parent)
	parent.flip = parent.flip or {}
	
	parent.flip.with_vel_x = true
	parent.flip.with_vel_y = true
	parent.flip.invert_x = false
	parent.flip.invert_y = false
	
	return self
end

function beh_flip_with_velocity._update(self, parent)
	if parent.vx == nil or parent.vy == nil
	or parent.flip.x == nil or parent.flip.y == nil then
		return nil
	end
	
	if with_vel_x then
		if invert_x then
			parent.flip.x = parent.vx > 0
		else
			parent.flip.x = parent.vx < 0
		end
	end
	if with_vel_y then
		if invert_y then
			parent.flip.y = parent.vy > 0
		else
			parent.flip.y = parent.vy < 0
		end
	end
end


---------------------------
-- beh_display_sprite --
---------------------------
function beh_display_sprite.setup(self, parent)
	parent.sprite = parent.sprite or {}
	parent.flip = parent.flip or {}
	
	parent.sprite.sheet = fetch("./gfx/0.gfx")
	parent.sprite.i = 0
	
	parent.flip.x = false
	parent.flip.y = false
	
	return self
end

	
function beh_display_sprite._draw(self, parent)
	spr(parent.sprite.sheet[parent.sprite.i].bmp, parent.x, parent.y, parent.flip.x, parent.flip.y)
end


------------------
-- beh_saveload --
------------------
:: content/entities.lua
--[[pod_format="raw",created="2024-04-29 21:34:20",modified="2024-05-13 23:48:58",revision=3521]]
include "protos.lua"
include "content/behaviors.lua"

-- List of Entities --
ent_player = entity_proto:new()


----------------
-- ent_player --
----------------
ent_player.behaviors = {
	beh_display_sprite:setup(ent_player),
	beh_flip_with_velocity:setup(ent_player),
	
	beh_acceleration,
	beh_velocity,
	beh_bounce,
}

ent_player.sprite.sheet = fetch("./gfx/characters.gfx")
ent_player.sprite.i = 0

ent_player.flip.with_vel_y = false

function ent_player:_update()

end

function ent_player:_save()
	save.data.player = write_props(self, {"x", "y", "vx", "vy", "ax", "ay"})
end

function ent_player:_load()
	set_props(self, save.data.player)
end
:: content/scenes.lua
--[[pod_format="raw",created="2024-05-05 04:37:49",modified="2024-05-13 23:48:58",revision=3053]]
--[[----------- TODO -----------))--

- Have scenes able to define a .map file and a section of that .map file to serve as
  the scene.

--((--------- END TODO ---------]]--
include "protos.lua"
include "lib/debug.lua"
include "content/entities.lua"

-- List of Scene Names --
sce_sandbox = scene_proto:quick("sce_sandbox", "Sandbox Scene")

-----------------
-- sce_sandbox --
-----------------
function sce_sandbox.create_ents(self)
	return {
	--[[
		ent_player:new({
			x=0,y=height/2,
			vx=30,vy=0,
			ax=0,ay=9.8
		})
	]]--
		-- can do like conditional entity creation, for example if smthn shouldnt spawn
		-- based on a bool in save data
	}
end

function sce_sandbox._init(self, w)
	if not w:has_pers_ent("player") then
		w:add_pers_ent("player",
			ent_player:new({
				x=0,y=height/2,
				vx=30,vy=0,
				ax=0,ay=9.8
			}))
	end
end

function sce_sandbox._draw(self)
	map()
end
:: content/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTEzIDIyOjE2OjM3Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OSJdXWx6NAAEAAAAAwAAADBuaWw=
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI1OjE1Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OCIscmV2aXNpb249MzIxOF1dbHo0AK8AAADcMQAA8xR7WzBdPXtibXA9cHh1
AEMgEBAE8PAsZmxhZ3M9MCxwYW5feAgAynk9MCx6b29tPTl9LDEAL-8VMgAdpxAPEwAOAA6QDgAC
AD8QDgAQAAk_HgAOHgAPLAAECxAAPjAOABwADw4AAg9YACcQcAQADwcBHC-w8DEA------------
----------------------------------------------------dVBtPTl9fQ==
:: gfx/characters.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjMwOjU3Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OCIscmV2aXNpb249MzIzNV1dbHo0AKYAAABDMQAA8hZ7WzBdPXtibXA9cHh1
AEMgEBAEQBY3cBZ3QAY3BScFFzAGJwUHAgAwMAanDgD3BmdAFhcVN3BXgCZHYBZ3UBZ3QBaXMAMA
8wAQLGZsYWdzPTAscGFuX3gIAMp5PTAsem9vbT04fSxvAC-w8DEA------------------------
----------------------------------------11BtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI1OjE0Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OSJdXWx6NAAEAAAAAwAAADBuaWw=
:: gui/scenes.lua
--[[pod_format="raw",created="2024-05-13 20:23:21",modified="2024-05-13 22:23:31",revision=231]]
include "protos.lua"

-- List of Scene Names --
gui_main = scene_proto:quick("gui_main", "GUI Main")

--------------
-- gui_main --
--------------
function gui_main.create_ents(self)
	return {
		entity_proto:new{
			behaviors = {
				-- TODO button proto
			}
		}
	}
end

function gui_main._draw()
	rectfill(0, 270-32, 480, 270, 11)
end
:: gui/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTEzIDIyOjE2OjQwIixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OSJdXWx6NAAEAAAAAwAAADBuaWw=
:: lib/error_explorer/
:: lib/error_explorer/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTA2IDAxOjM4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OSJdXWx6NAAEAAAAAwAAADBuaWw=
:: lib/error_explorer/error_explorer.lua
b64$LS0gIyBwaWNvdHJvbiBlcnJvciBleHBsb3JlcgotLQotLSBieSBraXJhCi0tCi0tIHZlcnNp
b24gMC4wLjQKLS0KLS0gYW4gaW50ZXJhY3RpdmUgZXJyb3Igc2NyZWVuIGZvciBwaWNvdHJvbi4K
LS0gb24gZXJyb3IsIHNob3dzIHRoZSBzdGFjaywgbG9jYWwgdmFyaWFibGVzLAotLSBhbmQgdGhl
IHNvdXJjZSBjb2RlIHdoZW4gYXZhaWxhYmxlLgotLQotLSAjIyB1c2FnZQotLQotLSBgaW5jbHVk
ZWAgb3IgYHJlcXVpcmVgIGBlcnJvcl9leHBsb3Jlci5sdWFgCi0tIGluIHlvdXIgcHJvZ3JhbSBf
YWZ0ZXJfIGRlZmluaW5nIHlvdXIgYF9pbml0YCwKLS0gYF91cGRhdGVgLCBhbmQgYF9kcmF3YCBm
dW5jdGlvbnMuCi0tCi0tIHByZXNzIGB1cGAgYW5kIGBkb3duYCB0byBtb3ZlIHVwIGFuZCBkb3du
IG9uCi0tIHRoZSBzdGFjaywgcHJlc3MgYHhgIG9yIGBzcGFjZWAgdG8gdG9nZ2xlIGZvbnQKLS0g
c2l6ZS4gY2xpY2sgb24gdGFibGVzIGluIHRoZSB2YXJpYWJsZSB2aWV3IHRvCi0tIGV4cGFuZCB0
aGVtLgotLQotLSAjIyBob3cgaXQgd29ya3MKLS0KLS0gaW4gb3JkZXIgdG8gY2F0Y2ggZXJyb3Jz
IGFuZCBpbnNwZWN0IHJ1bnRpbWUKLS0gc3RhdGUsIHRoaXMgc2NyaXB0IHJlcGxhY2VzIGBfaW5p
dGAsIGBfdXBkYXRlYAotLSBhbmQgYF9kcmF3YCBmdW5jdGlvbnMgd2l0aCBvbmVzIHRoYXQgY2Fs
bCB0aGUKLS0gb3JpZ2luYWwgb25lcyBpbnNpZGUgYSBjb3JvdXRpbmUuCi0tCi0tIHdoZW4gdGhl
cmUncyBhbiBlcnJvciwgaXQgdXNlcyBsdWEncyBkZWJ1ZwotLSBsaWJyYXJ5IHRvIGluc3BlY3Qg
dGhlIGNvcm91dGluZS4gYSBjb3B5Ci0tIG9mIHRoZSBlcnJvciBpcyBhbHNvIHByaW50ZWQgdG8g
dGhlIGNvbnNvbGUKLS0gd2l0aCBwcmludGggaWYgeW91J3JlIHJ1bm5pbmcgcGljb3Ryb24gZnJv
bQotLSB0aGUgY29tbWFuZCBsaW5lLgotLQotLSB0aGUgZm9sbG93aW5nIGRlYnVnIGFwaXMgYXJl
IHVzZWQ6Ci0tCi0tIC0gYGRlYnVnLmdldGluZm9gCi0tIC0gYGRlYnVnLmdldGxvY2FsYAotLSAt
IGBkZWJ1Zy5nZXR1cHZhbHVlYAotLSAtIGBkZWJ1Zy50cmFjZWJhY2tgCi0tCi0tICMjIHZlcnNp
b24gaGlzdG9yeSAKLS0KLS0gdmVyc2lvbiAwLjAuNAotLQotLSAtIGFsc28gY2F0Y2ggZXJyb3Jz
IGluIGBfaW5pdGAKLS0KLS0gdmVyc2lvbiAwLjAuMwotLQotLSAtIGF1dG9tYXRpY2FsbHkgY2hv
b3NlIHRoZSByaWdodCBzdGFjayBmcmFtZQotLSAgIGJhc2VkIG9uIHRoZSBlcnJvciBtZXNzYWdl
Ci0tIC0gbW9yZSB0aG9yb3VnaGx5IHByb3RlY3QgZnJvbSBlcnJvcnMgaW4gZXJyb3IKLS0gICBl
eHBsb3JlciBpdHNlbGYKLS0KLS0gdmVyc2lvbiAwLjAuMgotLQotLSAtIGRvbid0IHJlZ2VuZXJh
dGUgc3RhY2sgaW5mbyBldmVyeSBkcmF3Ci0tIC0gc2Nyb2xsIHN0YWNrIGFuZCB2YXJpYWJsZXMg
bGlzdCB3aXRoIG1vdXNld2hlZWwKLS0gLSBjbGljayBvbiBzdGFjayB0byBzd2l0Y2ggc3RhY2sg
ZnJhbWVzCi0tIC0gY2xpY2sgb24gdGFibGVzIGluIHZhcmlhYmxlcyB2aWV3IHRvIGV4cGFuZCB0
aGVtCi0tIC0gZXNjYXBlIHN0cmluZ3Mgd2hlbiBwcmludGluZyB0aGVtCi0tCi0tIHZlcnNpb24g
MC4wLjEKLS0KLS0gLSBhZGp1c3QgY29sb3JzCi0tIC0gY29kZSBjbGVhbnVwCi0tIC0gdXNlIGBi
dG5wYCBpbnN0ZWFkIG9mIGBrZXlwYAotLSAtIHNsaWdodGx5IG1vcmUgdGhvcm91Z2ggYHJlc2V0
YAotLSAtIGRvbid0IHNob3cgdGVtcG9yYXJpZXMKLS0KLS0gdmVyc2lvbiAwLjAuMCAocHJlcmVs
ZWFzZSkKLS0KLS0gLSBpbml0aWFsIGRpc2NvcmQgYmV0YQoKLS0gIyMgbGljZW5zZQotLQotLSBD
b3B5cmlnaHQgMjAyNCBLaXJhIEJvb20KLS0gCi0tIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50
ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkKLS0gb2Yg
dGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUg4oCc
U29mdHdhcmXigJ0pLCB0bwotLSBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0
aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZQotLSByaWdodHMgdG8gdXNlLCBj
b3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQv
b3IKLS0gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMg
dG8gd2hvbSB0aGUgU29mdHdhcmUgaXMKLS0gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRv
IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczoKLS0KLS0gVGhlIGFib3ZlIGNvcHlyaWdodCBub3Rp
Y2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4KLS0gYWxs
IGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi0tIAotLSBU
SEUgU09GVFdBUkUgSVMgUFJPVklERUQg4oCcQVMgSVPigJ0sIFdJVEhPVVQgV0FSUkFOVFkgT0Yg
QU5ZIEtJTkQsIEVYUFJFU1MKLS0gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRF
RCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksCi0tIEZJVE5FU1MgRk9SIEEg
UEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxM
Ci0tIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENM
QUlNLCBEQU1BR0VTIE9SIE9USEVSCi0tIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04g
T0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HCi0tIEZST00sIE9VVCBPRiBP
UiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIKLS0g
REVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKLS0tLSB1dGlsIC0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0KCmxvY2FsIGZ1bmN0aW9uIGZpbGVuYW1lX29mIChwYXRoKQog
IHJldHVybiBwYXRoOm1hdGNoICgnW14vXSokJykKZW5kCgpsb2NhbCBmdW5jdGlvbiBzYWZlX3Rv
c3RyaW5nICh2YWx1ZSkKICBpZiB0eXBlICh2YWx1ZSkgPT0gJ3N0cmluZycgdGhlbgogICAgcmV0
dXJuIHN0cmluZy5mb3JtYXQgKCclcScsIHZhbHVlKQogIGVsc2UKICAgIGxvY2FsIHN1Y2Nlc3Ms
IHZhbHVlX3N0cmluZyA9IHBjYWxsICh0b3N0cmluZywgdmFsdWUpCiAgICByZXR1cm4gc3VjY2Vz
cyBhbmQgdmFsdWVfc3RyaW5nCiAgICAgICAgICAgICAgICAgICBvciAoJ2Vycm9yIGR1cmluZyB0
b3N0cmluZzogJyAuLiB0b3N0cmluZyAodmFsdWVfc3RyaW5nKSkKICBlbmQKZW5kCgpsb2NhbCBm
dW5jdGlvbiBnZXRfbGluZXMgKHRleHQpCiAgbG9jYWwgbGluZXMgPSB7fQogIGZvciBsaW5lIGlu
IHRleHQ6Z21hdGNoICgiKC4tKVxyP1xuIikgZG8KICAgIHRhYmxlLmluc2VydCAobGluZXMsIGxp
bmUpCiAgZW5kCiAgbG9jYWwgbGFzdF9saW5lID0gdGV4dDptYXRjaCAoJyhbXlxuXSopJCcpCiAg
aWYgbGFzdF9saW5lIGFuZCBsYXN0X2xpbmUgfj0gJycgdGhlbgogICAgdGFibGUuaW5zZXJ0IChs
aW5lcywgbGFzdF9saW5lKQogIGVuZAogIHJldHVybiBsaW5lcwplbmQKCmxvY2FsIGZ1bmN0aW9u
IGNvbXBhcmVfa2V5cyAoYSwgYikKICBsb2NhbCB0YSA9IHR5cGUgKGEua2V5KQogIGxvY2FsIHRi
ID0gdHlwZSAoYi5rZXkpCiAgaWYgdGEgfj0gdGIgdGhlbgogICAgcmV0dXJuIHRhIDwgdGIKICBl
bmQKICBpZiB0YSA9PSAnbnVtYmVyJyBvciB0YSA9PSAnc3RyaW5nJyB0aGVuCiAgICByZXR1cm4g
YS5rZXkgPCBiLmtleQogIGVsc2UKICAgIHJldHVybiBzYWZlX3Rvc3RyaW5nIChhLmtleSkgPCBz
YWZlX3Rvc3RyaW5nIChiLmtleSkKICBlbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBzb3J0ICh0LCBm
KQogIC0tIGluc2VydGlvbiBzb3J0CiAgZiA9IGYgb3IgZnVuY3Rpb24gKGEsIGIpIHJldHVybiBh
IDwgYiBlbmQKICBmb3IgaSA9IDEsICN0LTEgZG8KICAgIGxvY2FsIHZhbCA9IHRbaSsxXQogICAg
bG9jYWwgaiA9IGkKICAgIHdoaWxlIGogPj0gMSBhbmQgbm90IGYodFtqXSwgdmFsKSBkbwogICAg
ICB0W2orMV0gPSB0W2pdCiAgICAgIGogPSBqIC0gMQogICAgZW5kCiAgICB0W2orMV0gPSB2YWwK
ICBlbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBhcHByb2FjaCAoZnJvbSwgdG8pCiAgcmV0dXJuIGZy
b20gKyAodG8gLSBmcm9tKSAqIDAuMjUKZW5kCgpsb2NhbCBmdW5jdGlvbiByb3VuZCAodmFsdWUp
CiAgcmV0dXJuIG1hdGguZmxvb3IgKHZhbHVlICsgMC41KQplbmQKCmxvY2FsIGZ1bmN0aW9uIHBh
cnNlX21lc3NhZ2VfZm9yX2xvY2F0aW9uIChtc2cpCiAgbG9jYWwgcGF0aCwgbGluZSwgZXJyID0g
bXNnOm1hdGNoICgnXihbXjpdKyk6KCVkKyk6KC4qKSQnKQogIHJldHVybiBwYXRoLCB0b251bWJl
ciAobGluZSksIGVycgplbmQKCi0tLS0gc3RhdGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tCgpsb2NhbCBfRyA9IF9HCmxvY2FsIGVycm9yX21lc3NhZ2UKbG9jYWwgZXJy
b3JfdGhyZWFkCmxvY2FsIGVycm9yX3RyYWNlYmFjawpsb2NhbCBpbml0X2RvbmUgPSBmYWxzZQps
b2NhbCB1c2Vfc21hbGxfZm9udCA9IGZhbHNlCmxvY2FsIG1vdXNlX3dhc19jbGlja2VkID0gZmFs
c2UKCi0tIHN0YWNrIHZpZXcKbG9jYWwgc3RhY2tfZnJhbWVzID0ge30KbG9jYWwgY3VycmVudF9z
dGFja19pbmRleCA9IDEKbG9jYWwgaG92ZXJlZF9zdGFja19pbmRleCA9IGZhbHNlCmxvY2FsIG1v
dXNlX292ZXJfc3RhY2sgPSBmYWxzZQpsb2NhbCBzdGFja19tYXhfc2Nyb2xsID0gMApsb2NhbCBz
dGFja19zY3JvbGwgPSAwCmxvY2FsIHN0YWNrX3Njcm9sbF9zbW9vdGggPSAwCgotLSB2YXJpYWJs
ZXMgdmlldwpsb2NhbCB2YXJpYWJsZXMgPSB7fQpsb2NhbCBob3ZlcmVkX3ZhcmlhYmxlID0gZmFs
c2UKbG9jYWwgdmFyaWFibGVzX21heF9zY3JvbGwgPSAwCmxvY2FsIHZhcmlhYmxlc19zY3JvbGwg
PSAwCmxvY2FsIHZhcmlhYmxlc19zY3JvbGxfc21vb3RoID0gMApsb2NhbCBtb3VzZV9vdmVyX3Zh
cmlhYmxlcyA9IGZhbHNlCgotLSBzb3VyY2Ugdmlldwpsb2NhbCBzb3VyY2VfbGluZXMgPSB7fQoK
Ci0tLS0gbWFpbiBldmVudHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpsb2Nh
bCBXID0gNDgwCmxvY2FsIEggPSAyNzAKCmxvY2FsIGZ1bmN0aW9uIHJlYnVpbGQgKCkKICAtLSBy
ZWJ1aWxkIHN0YWNrIGZyYW1lIGluZm8KICBzdGFja19mcmFtZXMgPSB7fQogIHZhcmlhYmxlcyA9
IHt9CiAgc291cmNlX2xpbmVzID0ge30KICB2YXJpYWJsZXNfc2Nyb2xsID0gMAogIHZhcmlhYmxl
c19zY3JvbGxfc21vb3RoID0gMAoKICBmb3IgaSA9IDAsIDIwIGRvCiAgICBsb2NhbCBpbmZvID0g
ZGVidWcuZ2V0aW5mbyAoZXJyb3JfdGhyZWFkLCBpKQogICAgaWYgbm90IGluZm8gdGhlbgogICAg
ICBicmVhawogICAgZW5kCgogICAgaWYgaW5mby5zaG9ydF9zcmMgdGhlbgogICAgICB0YWJsZS5p
bnNlcnQgKHN0YWNrX2ZyYW1lcywgewogICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWVfb2YgKGlu
Zm8uc2hvcnRfc3JjKSwKICAgICAgICBwYXRoID0gaW5mby5zaG9ydF9zcmMsCiAgICAgICAgbGlu
ZSA9IGluZm8uY3VycmVudGxpbmUsCiAgICAgICAgZGVwdGggPSBpLAogICAgICAgIGZuX25hbWUg
PSAoaW5mby5uYW1lIG9yIChmaWxlbmFtZV9vZiAoaW5mby5zaG9ydF9zcmMpIC4uICc6JyAuLiB0
b3N0cmluZyAoaW5mby5saW5lZGVmaW5lZCkpKSwKICAgICAgICBzb3VyY2UgPSBpbmZvLnNvdXJj
ZSwKICAgICAgfSkKICAgIGVuZAogIGVuZAoKICBsb2NhbCBmcmFtZSA9IHN0YWNrX2ZyYW1lcyBb
Y3VycmVudF9zdGFja19pbmRleF0KCiAgaWYgbm90IGZyYW1lIHRoZW4KICAgIHJldHVybgogIGVu
ZAoKICAtLSByZWJ1aWxkIHZhcmlhYmxlcwogIGRvCiAgICBsb2NhbCBsb2NhbF9pbmRleCA9IDEK
ICAgIHJlcGVhdAogICAgICBsb2NhbCBuYW1lLCB2YWx1ZSA9IGRlYnVnLmdldGxvY2FsIChlcnJv
cl90aHJlYWQsIGZyYW1lLmRlcHRoLCBsb2NhbF9pbmRleCkKICAgICAgaWYgbmFtZSB0aGVuCiAg
ICAgICAgaWYgbmFtZSB_PSAnKHRlbXBvcmFyeSknIHRoZW4KICAgICAgICAgIHRhYmxlLmluc2Vy
dCAodmFyaWFibGVzLCB7CiAgICAgICAgICAgIGtleSA9IG5hbWUsCiAgICAgICAgICAgIHZhbHVl
ID0gdmFsdWUsCiAgICAgICAgICB9KQogICAgICAgIGVuZAogICAgICAgIGxvY2FsX2luZGV4ID0g
bG9jYWxfaW5kZXggKyAxCiAgICAgIGVuZAogICAgdW50aWwgbm90IG5hbWUKCiAgICBsb2NhbCBp
bmZvID0gZGVidWcuZ2V0aW5mbyAoZXJyb3JfdGhyZWFkLCBmcmFtZS5kZXB0aCkKICAgIGlmIGlu
Zm8gYW5kIGluZm8uZnVuYyB0aGVuCiAgICAgIGxvY2FsIHVwdmFsdWVfaW5kZXggPSAxCiAgICAg
IHJlcGVhdAogICAgICAgIGxvY2FsIG5hbWUsIHZhbHVlID0gZGVidWcuZ2V0dXB2YWx1ZSAoaW5m
by5mdW5jLCB1cHZhbHVlX2luZGV4KQogICAgICAgIGlmIG5hbWUgdGhlbgogICAgICAgICAgdGFi
bGUuaW5zZXJ0ICh2YXJpYWJsZXMsIHsKICAgICAgICAgICAga2V5ID0gbmFtZSwKICAgICAgICAg
ICAgdmFsdWUgPSB2YWx1ZSwKICAgICAgICAgIH0pCiAgICAgICAgICB1cHZhbHVlX2luZGV4ID0g
dXB2YWx1ZV9pbmRleCArIDEKICAgICAgICBlbmQKICAgICAgdW50aWwgbm90IG5hbWUKICAgIGVu
ZAogIGVuZAoKICAtLSByZWJ1aWxkIHNvdXJjZSBsaW5lcwogIGxvY2FsIHNvdXJjZSA9IGZyYW1l
LnNvdXJjZQogIGlmIHNvdXJjZSB0aGVuCiAgICBpZiBzdHJpbmcuc3ViIChzb3VyY2UsIDEsIDEp
ID09ICdAJyB0aGVuCiAgICAgIGxvY2FsIGZpbGVuYW1lID0gc3RyaW5nLnN1YiAoc291cmNlLCAy
LCAjc291cmNlKQogICAgICBzb3VyY2UgPSBmZXRjaCAoZmlsZW5hbWUpCiAgICBlbmQKICAgIGlm
IHNvdXJjZSBhbmQgdHlwZSAoc291cmNlKSA9PSAnc3RyaW5nJyB0aGVuCiAgICAgIHNvdXJjZV9s
aW5lcyA9IGdldF9saW5lcyAoc291cmNlKQogICAgZW5kCiAgZW5kCmVuZAoKbG9jYWwgZnVuY3Rp
b24gZXJyb3JfdXBkYXRlICgpCiAgbG9jYWwgbGFzdF9pbmRleCA9IGN1cnJlbnRfc3RhY2tfaW5k
ZXgKICBpZiBidG5wICg1KSBvciBrZXlwICdzcGFjZScgdGhlbgogICAgdXNlX3NtYWxsX2ZvbnQg
PSBub3QgdXNlX3NtYWxsX2ZvbnQKICBlbmQKICBpZiBidG5wICgyKSB0aGVuCiAgICBjdXJyZW50
X3N0YWNrX2luZGV4ID0gbWF0aC5tYXggKDEsIGN1cnJlbnRfc3RhY2tfaW5kZXggLSAxKQogICAg
c3RhY2tfc2Nyb2xsID0gbWF0aC5taW4gKGN1cnJlbnRfc3RhY2tfaW5kZXgtMSwgc3RhY2tfc2Ny
b2xsKQogIGVuZAogIGlmIGJ0bnAgKDMpIHRoZW4KICAgIGN1cnJlbnRfc3RhY2tfaW5kZXggPSBt
YXRoLm1pbiAoI3N0YWNrX2ZyYW1lcywgY3VycmVudF9zdGFja19pbmRleCArIDEpCiAgICBzdGFj
a19zY3JvbGwgPSBtYXRoLm1heCAoKGN1cnJlbnRfc3RhY2tfaW5kZXgpIC0gKCNzdGFja19mcmFt
ZXMgLSBzdGFja19tYXhfc2Nyb2xsKSwgc3RhY2tfc2Nyb2xsKQogIGVuZAoKICBsb2NhbCBfLCBf
LCBjbGljaywgXywgd2hlZWwgPSBtb3VzZSAoKQogIGlmIG1vdXNlX292ZXJfc3RhY2sgdGhlbgog
ICAgc3RhY2tfc2Nyb2xsID0gbWF0aC5tYXggKDAsIG1hdGgubWluIChzdGFja19zY3JvbGwgLSB3
aGVlbCAqIDIsIHN0YWNrX21heF9zY3JvbGwpKQogIGVuZAogIHN0YWNrX3Njcm9sbF9zbW9vdGgg
PSBhcHByb2FjaCAoc3RhY2tfc2Nyb2xsX3Ntb290aCwgc3RhY2tfc2Nyb2xsKQogIGlmIG1vdXNl
X292ZXJfdmFyaWFibGVzIHRoZW4KICAgIHZhcmlhYmxlc19zY3JvbGwgPSBtYXRoLm1heCAoMCwg
bWF0aC5taW4gKHZhcmlhYmxlc19zY3JvbGwgLSB3aGVlbCAqIDIsIHZhcmlhYmxlc19tYXhfc2Ny
b2xsKSkKICBlbmQKICB2YXJpYWJsZXNfc2Nyb2xsX3Ntb290aCA9IGFwcHJvYWNoICh2YXJpYWJs
ZXNfc2Nyb2xsX3Ntb290aCwgdmFyaWFibGVzX3Njcm9sbCkKCiAgY2xpY2sgPSBjbGljayB_PSAw
CiAgaWYgY2xpY2sgYW5kIG5vdCBtb3VzZV93YXNfY2xpY2tlZCB0aGVuCiAgICBpZiBob3ZlcmVk
X3N0YWNrX2luZGV4IHRoZW4KICAgICAgY3VycmVudF9zdGFja19pbmRleCA9IGhvdmVyZWRfc3Rh
Y2tfaW5kZXgKICAgIGVuZAogICAgaWYgaG92ZXJlZF92YXJpYWJsZSBhbmQgdHlwZSAoaG92ZXJl
ZF92YXJpYWJsZS52YWx1ZSkgPT0gJ3RhYmxlJyB0aGVuCiAgICAgIGlmIGhvdmVyZWRfdmFyaWFi
bGUuY29udGVudHMgdGhlbgogICAgICAgIGhvdmVyZWRfdmFyaWFibGUuY29udGVudHMgPSBuaWwK
ICAgICAgZWxzZQogICAgICAgIGxvY2FsIGNvbnRlbnRzID0ge30KICAgICAgICBob3ZlcmVkX3Zh
cmlhYmxlLmNvbnRlbnRzID0gY29udGVudHMKICAgICAgICBmb3Igayx2IGluIHBhaXJzIChob3Zl
cmVkX3ZhcmlhYmxlLnZhbHVlKSBkbwogICAgICAgICAgdGFibGUuaW5zZXJ0IChjb250ZW50cywg
ewogICAgICAgICAgICBrZXkgPSBrLAogICAgICAgICAgICB2YWx1ZSA9IHYsCiAgICAgICAgICB9
KQogICAgICAgIGVuZAogICAgICAgIHNvcnQgKGNvbnRlbnRzLCBjb21wYXJlX2tleXMpCiAgICAg
IGVuZAogICAgZW5kCiAgZW5kCiAgbW91c2Vfd2FzX2NsaWNrZWQgPSBjbGljawoKICBpZiBjdXJy
ZW50X3N0YWNrX2luZGV4IH49IGxhc3RfaW5kZXggdGhlbgogICAgcmVidWlsZCgpCiAgZW5kCmVu
ZAoKbG9jYWwgZnVuY3Rpb24gZXJyb3JfZHJhdyAoKQogIGxvY2FsIHByZWZpeCA9IHVzZV9zbWFs
bF9mb250IGFuZCAnXDAxNCcgb3IgJycKICBsb2NhbCBmb250X2hlaWdodCA9ICh1c2Vfc21hbGxf
Zm9udCBhbmQgNiBvciAxMSkKICBsb2NhbCBteCwgbXkgPSBtb3VzZSgpCiAgbG9jYWwgb3Zlcl9z
ZWN0aW9uID0gZmFsc2UKICBsb2NhbCB4MCwgeTAsIHgsIHkKCiAgbG9jYWwgZnVuY3Rpb24gZ29f
dG8gKG5ld194LCBuZXdfeSkKICAgIHgwLCB5MCA9IG5ld194LCBuZXdfeQogICAgeCwgeSA9IHgw
LCB5MAogIGVuZAoKICBsb2NhbCBmdW5jdGlvbiBzZWN0aW9uIChzeCwgc3ksIHN3LCBzaCkKICAg
IG92ZXJfc2VjdGlvbiA9CiAgICAgIG14ID49IHN4IGFuZCBteCA8IHN4ICsgc3cgYW5kCiAgICAg
IG15ID49IHN5IGFuZCBteSA8IHN5ICsgc2gKICAgIGNsaXAgKHN4LCBzeSwgc3csIHNoKQogICAg
Z29fdG8oc3grMiwgc3krMikKICBlbmQKCiAgbG9jYWwgZnVuY3Rpb24gcHJpbnRfaG9yaXpvbnRh
bCAodGV4dCwgY29sb3IpCiAgICBsb2NhbCBuZXdfeCwgX25ld195ID0gcHJpbnQgKHByZWZpeCAu
LiB0ZXh0LCB4LCB5LCBjb2xvcikKICAgIHggPSBuZXdfeAogIGVuZAoKICBsb2NhbCBmdW5jdGlv
biBwcmludF9saW5lICh0ZXh0LCBjb2xvcikKICAgIGxvY2FsIF9uZXdfeCwgbmV3X3kgPSBwcmlu
dCAocHJlZml4IC4uIHRleHQsIHgsIHksIGNvbG9yKQogICAgeCA9IHgwCiAgICB5ID0gbmV3X3kK
ICBlbmQKCiAgLS0gZHJhdyBzZXR1cAogIGNscyAoMCkKICAtLSBsaWdodGVyIGRhcmsgZ3JheSBm
b3IgcmVhZGFiaWxpdHkKICBwYWwgKDUsIDB4ZmY3MDcwNzAsIDIpCiAgY29sb3IgKDUpCgogIC0t
IGVycm9yIG1lc3NhZ2UKICBzZWN0aW9uICgwLCAwLCBXLCBILzIpCiAgbW91c2Vfb3Zlcl9zdGFj
ayA9IG92ZXJfc2VjdGlvbgoKICBsb2NhbCBsb2NfcGF0aCwgbG9jX2xpbmUsIGVyciA9IHBhcnNl
X21lc3NhZ2VfZm9yX2xvY2F0aW9uIChlcnJvcl9tZXNzYWdlKQogIGlmIGxvY19wYXRoIHRoZW4K
ICAgIHByaW50X2xpbmUgKCdlcnJvciBhdCAnIC4uIGxvY19wYXRoIC4uICc6JyAuLiBsb2NfbGlu
ZSAuLiAnOicsIDYpCiAgICBwcmludF9saW5lICgnICAnIC4uIGVyciwgOCkKICBlbHNlCiAgICBw
cmludF9saW5lICgnZXJyb3I6JywgNikKICAgIHByaW50X2xpbmUgKCcgICcgLi4gZXJyb3JfbWVz
c2FnZSwgOCkKICBlbmQKCiAgLS0gc3RhY2sgZnJhbWVzCiAgcHJpbnRfbGluZSAoJ3N0YWNrOics
IDYpCiAgc2VjdGlvbiAoMCwgeSwgVywgSC8yLXkpCiAgbG9jYWwgc3RhY2tfdG9wX3kgPSB5CiAg
eSA9IHkgLSByb3VuZCAoc3RhY2tfc2Nyb2xsX3Ntb290aCAqIGZvbnRfaGVpZ2h0KQogIGxvY2Fs
IGxhc3RfaG92ZXJlZF9zdGFja19pbmRleCA9IGhvdmVyZWRfc3RhY2tfaW5kZXgKICBob3ZlcmVk
X3N0YWNrX2luZGV4ID0gZmFsc2UKICBmb3IgaSwgZnJhbWUgaW4gaXBhaXJzIChzdGFja19mcmFt
ZXMpIGRvCiAgICBjb2xvciAobGFzdF9ob3ZlcmVkX3N0YWNrX2luZGV4ID09IGkgYW5kIDcgb3IK
ICAgICAgICAgICBjdXJyZW50X3N0YWNrX2luZGV4ID09IGkgYW5kIDYgb3IgNSkKCiAgIGxvY2Fs
IHlfYmVmb3JlID0geQogICAgcHJpbnRfbGluZSAoc3RyaW5nLmZvcm1hdCAoJyAgJXM6JWQgaW4g
ZnVuY3Rpb24gJXMnLAogICAgICBmcmFtZS5maWxlbmFtZSwgZnJhbWUubGluZSwgZnJhbWUuZm5f
bmFtZSApKQogICAgaWYgb3Zlcl9zZWN0aW9uIHRoZW4KICAgICAgaWYgbXkgPj0geV9iZWZvcmUg
YW5kIG15IDwgeSB0aGVuCiAgICAgICAgaG92ZXJlZF9zdGFja19pbmRleCA9IGkKICAgICAgZW5k
CiAgICBlbmQKICBlbmQKICBzdGFja19tYXhfc2Nyb2xsID0gI3N0YWNrX2ZyYW1lcyAtIChILzIg
LSBzdGFja190b3BfeSkgLyBmb250X2hlaWdodAoKICBsb2NhbCBmcmFtZSA9IHN0YWNrX2ZyYW1l
cyBbY3VycmVudF9zdGFja19pbmRleF0KICBpZiBub3QgZnJhbWUgdGhlbgogICAgcmV0dXJuCiAg
ZW5kCgogIC0tIHZhcmlhYmxlcwogIHNlY3Rpb24gKDAsIEgvMiwgVy8yLCBILzIpCiAgbW91c2Vf
b3Zlcl92YXJpYWJsZXMgPSBvdmVyX3NlY3Rpb24KICBwcmludF9saW5lICgndmFyaWFibGVzOics
IDYpCiAgc2VjdGlvbiAoMCwgeSwgVy8yLCBILXkpCiAgbG9jYWwgdmFyaWFibGVzX3RvcF95ID0g
eQogIHkgPSB5IC0gcm91bmQgKHZhcmlhYmxlc19zY3JvbGxfc21vb3RoICogZm9udF9oZWlnaHQp
CiAgbG9jYWwgbGFzdF9ob3ZlcmVkX3ZhcmlhYmxlID0gaG92ZXJlZF92YXJpYWJsZQogIGhvdmVy
ZWRfdmFyaWFibGUgPSBmYWxzZQogIGxvY2FsIHZhcmlhYmxlX2NvdW50ID0gMAogIGxvY2FsIGZ1
bmN0aW9uIGRyYXdfdmFyaWFibGUgKHZhcmlhYmxlLCBpbmRlbnQpCiAgICB2YXJpYWJsZV9jb3Vu
dCA9IHZhcmlhYmxlX2NvdW50ICsgMQogICAgbG9jYWwgaG92ZXJlZCA9IHZhcmlhYmxlID09IGxh
c3RfaG92ZXJlZF92YXJpYWJsZQogICAgbG9jYWwgeV9iZWZvcmUgPSB5CiAgICBwcmludF9ob3Jp
em9udGFsIChpbmRlbnQgLi4gdmFyaWFibGUua2V5LCBob3ZlcmVkIGFuZCA3IG9yIDYpCiAgICBw
cmludF9ob3Jpem9udGFsICgnOiAnLCB2YXJpYWJsZSA9PSBsYXN0X2hvdmVyZWRfdmFyaWFibGUg
YW5kIDcgb3IgNSkKICAgIHByaW50X2xpbmUgKHNhZmVfdG9zdHJpbmcodmFyaWFibGUudmFsdWUp
KQoKICAgIGlmIG92ZXJfc2VjdGlvbiBhbmQgdHlwZSAodmFyaWFibGUudmFsdWUpID09ICd0YWJs
ZScgdGhlbgogICAgICBpZiBteCA_PSAwIGFuZCBteCA8IFcvMiBhbmQgbXkgPj0geV9iZWZvcmUg
YW5kIG15IDwgeSB0aGVuCiAgICAgICAgaG92ZXJlZF92YXJpYWJsZSA9IHZhcmlhYmxlCiAgICAg
IGVuZAogICAgZW5kCgogICAgaWYgdmFyaWFibGUuY29udGVudHMgdGhlbgogICAgICBmb3IgXywg
diBpbiBpcGFpcnMgKHZhcmlhYmxlLmNvbnRlbnRzKSBkbwogICAgICAgIGRyYXdfdmFyaWFibGUg
KHYsIGluZGVudCAuLiAnICAnKQogICAgICBlbmQKICAgIGVuZAogIGVuZAogIGZvciBfLCB2YXJp
YWJsZSBpbiBpcGFpcnMgKHZhcmlhYmxlcykgZG8KICAgIGRyYXdfdmFyaWFibGUgKHZhcmlhYmxl
LCAnICAnKQogIGVuZAogIHZhcmlhYmxlc19tYXhfc2Nyb2xsID0gdmFyaWFibGVfY291bnQgLSAo
SCAtIHZhcmlhYmxlc190b3BfeSkgLyBmb250X2hlaWdodAoKICAtLSBzb3VyY2UKICBzZWN0aW9u
IChXLzIsIEgvMiwgVy8yLCBILzIpCiAgcHJpbnRfbGluZSAoJ3NvdXJjZSBvZiAnIC4uIGZyYW1l
LnBhdGggLi4gJzonLCA2KQogIGxvY2FsIGNvbnRleHQgPSB1c2Vfc21hbGxfZm9udCBhbmQgMTAg
b3IgNQogIGxvY2FsIGlfbWluID0gbWF0aC5tYXggKDEsIGZyYW1lLmxpbmUgLSBjb250ZXh0KQog
IGxvY2FsIGlfbWF4ID0gbWF0aC5taW4gKCNzb3VyY2VfbGluZXMsIGZyYW1lLmxpbmUgKyBjb250
ZXh0KQogIGZvciBpID0gaV9taW4sIGlfbWF4IGRvCiAgICBjb2xvciAoaSA9PSBmcmFtZS5saW5l
IGFuZCA2IG9yIDUpCiAgICBwcmludF9ob3Jpem9udGFsIChzdHJpbmcuZm9ybWF0ICgnJTRkICcs
IGkpKQogICAgcHJpbnRfbGluZSAoc291cmNlX2xpbmVzIFtpXSkKICBlbmQKCiAgY2xpcCAoKQpl
bmQKCi0tLS0gdGFraW5nIG92ZXIgZHVyaW5nIGVycm9ycyAtLS0tLS0tLS0tLS0tLS0tLS0tCgps
b2NhbCBmdW5jdGlvbiByZXNldCAoKQogIC0tIGJhc2VkIG9uIHJlc2V0KCkgZnJvbSAvc3lzdGVt
L2xpYi9oZWFkLmx1YQogIC0tIHNlZSB0aGF0IGZuIGZvciBpbmZvCiAgbm90ZSAoKQogIC0tIHBp
Y290cm9uIHNlZ2ZhdWx0cyBpZiB3ZSBjYWxsIGNsaXAoKSBkdXJpbmcgaW5pdAogIGlmIGluaXRf
ZG9uZSB0aGVuCiAgICBjbGlwICgpCiAgZW5kCiAgY2FtZXJhICgpCiAgcGFsICgpCiAgcGFsdCAo
KQogIG1lbXNldCAoMHg1NTFmLCAwLCA5KQogIHBva2UgKDB4NTUwOCwgMHgzZikKICBwb2tlICgw
eDU1MDksIDB4M2YpCiAgcG9rZSAoMHg1NTBhLCAweDNmKQogIHBva2UgKDB4NTUwYiwgMHgwMCkK
ICBjb2xvciAoNikKICBmaWxscCAoKQogIHBva2UgKDB4NWY1NiwgMHg0MCkKICBwb2tlICgweDVm
NTcsIDB4NTYpCiAgcG9rZSAoMHg0MDAwLCBnZXQgKGZldGNoIi9zeXN0ZW0vZm9udHMvbGlsLmZv
bnQiKSkKICBwb2tlICgweDU2MDAsIGdldCAoZmV0Y2giL3N5c3RlbS9mb250cy9wOC5mb250Iikp
CiAgcG9rZSAoMHg1NjA2LCBwZWVrICgweDU2MDApICogNCkKICBwb2tlICgweDU2MDUsIDB4MikK
ICBwb2tlICgweDVmMjgsIDY0KQogIHBva2UgKDB4NWYyOSwgNjQpCmVuZAoKbG9jYWwgZnVuY3Rp
b24gb25fZXJyb3IgKHRocmVhZCwgbWVzc2FnZSkKICAtLSBkbyB0aGlzIGZpcnN0IGluIGNhc2Ug
d2UgaGl0IGFub3RoZXIgZXJyb3IKICBlcnJvcl90cmFjZWJhY2sgPSBkZWJ1Zy50cmFjZWJhY2sg
KHRocmVhZCwgbWVzc2FnZSkKICBwcmludGggKGVycm9yX3RyYWNlYmFjaykKCiAgZXJyb3JfdGhy
ZWFkID0gdGhyZWFkCiAgZXJyb3JfbWVzc2FnZSA9IHRvc3RyaW5nIChtZXNzYWdlKQogIHJlc2V0
ICgpCiAgcmVidWlsZCAoKQogIC0tIGp1bXAgdG8gdGhlIHByb3BlciBzdGFjayBmcmFtZSBpZiB3
ZSBjYW4KICBsb2NhbCBsb2NfcGF0aCwgbG9jX2xpbmUgPSBwYXJzZV9tZXNzYWdlX2Zvcl9sb2Nh
dGlvbiAoZXJyb3JfbWVzc2FnZSkKICBmb3IgaSwgZnJhbWUgaW4gaXBhaXJzIChzdGFja19mcmFt
ZXMpIGRvCiAgICBpZiBmcmFtZS5wYXRoID09IGxvY19wYXRoIGFuZCBmcmFtZS5saW5lID09IGxv
Y19saW5lIHRoZW4KICAgICAgY3VycmVudF9zdGFja19pbmRleCA9IGkKICAgICAgcmVidWlsZCAo
KQogICAgICBicmVhawogICAgZW5kCiAgZW5kCmVuZAoKLS0tLSBpbnN0YWxsIG1haW4gZXZlbnRz
IHRoYXQgY2F0Y2ggZXJyb3JzIC0tLS0tLS0KCmxvY2FsIHVzZXJfaW5pdCA9IHJhd2dldCAoX0cs
ICdfaW5pdCcpCmxvY2FsIHVzZXJfdXBkYXRlID0gcmF3Z2V0IChfRywgJ191cGRhdGUnKQpsb2Nh
bCB1c2VyX2RyYXcgPSByYXdnZXQgKF9HLCAnX2RyYXcnKQoKYXNzZXJ0ICh1c2VyX2RyYXcgYW5k
IHVzZXJfdXBkYXRlLAogICdwbGVhc2UgaW5jbHVkZSBpbnN0YWxsX2Vycm9yX2hhbmRsZXIgYWZ0
ZXIgZGVmaW5pbmcgYm90aCBfdXBkYXRlIGFuZCBfZHJhdycpCgpsb2NhbCBmdW5jdGlvbiBjYWxs
X2Vycm9yX2V2ZW50IChmbiwgLi4uKQogIC0tIGlmIHRoZXJlJ3MgYW4gZXJyb3IgaW4gb3VyIHVw
ZGF0ZSBvciBkcmF3LCB0aHJvdyB0aGUKICAtLSBvcmlnaW5hbCBlcnJvciBhcyB3ZWxsIGFzIHRo
ZSBuZXcgZXJyb3IKICBsb2NhbCBzdWNjZXNzLCBlcnIgPSBwY2FsbCAoZm4sIC4uLikKICBpZiBu
b3Qgc3VjY2VzcyB0aGVuCiAgICBlcnJvciAoZXJyb3JfdHJhY2ViYWNrIC4uICdcblxuZXJyb3Ig
ZHVyaW5nIGVycm9yIGhhbmRsaW5nOiAnIC4uIHRvc3RyaW5nIChlcnIpKQogIGVuZAplbmQKCmxv
Y2FsIGZ1bmN0aW9uIGNhbGxfcHJvdGVjdGVkIChmbikKICAtLSBuZWVkIHRvIHVzZSBjb3Jlc3Vt
ZSBldGMuIGFuZCBub3QgY29yb3V0aW5lLnJlc3VtZSBldGMuCiAgLS0gZm9yIHBpY290cm9uIGNv
bXBhdGliaWxpdHkKICBsb2NhbCB0aHJlYWQgPSBjb2NyZWF0ZSAoZm4pCiAgbG9jYWwgc3VjY2Vz
cywgbWVzc2FnZSA9IGNvcmVzdW1lKHRocmVhZCkKICBpZiBjb3N0YXR1cyAodGhyZWFkKSB_PSAn
ZGVhZCcgdGhlbgogICAgY2FsbF9lcnJvcl9ldmVudCAob25fZXJyb3IsIHRocmVhZCwgJ3NldHVw
X2Vycm9yX2Rpc3BsYXkubHVhOiBfdXBkYXRlIGFuZCBfZHJhdyBzaG91bGRuXCd0IHlpZWxkJykK
ICBlbmQKICBpZiBub3Qgc3VjY2VzcyB0aGVuCiAgICBjYWxsX2Vycm9yX2V2ZW50IChvbl9lcnJv
ciwgdGhyZWFkLCBtZXNzYWdlKQogIGVuZAplbmQKCmlmIHVzZXJfaW5pdCB0aGVuCiAgZnVuY3Rp
b24gX2luaXQgKCkKICAgIGNhbGxfcHJvdGVjdGVkICh1c2VyX2luaXQpCiAgICBpbml0X2RvbmUg
PSB0cnVlCiAgZW5kCmVsc2UKICBpbml0X2RvbmUgPSB0cnVlCmVuZAoKZnVuY3Rpb24gX3VwZGF0
ZSAoKQogIGlmIGVycm9yX3RocmVhZCB0aGVuCiAgICBjYWxsX2Vycm9yX2V2ZW50IChlcnJvcl91
cGRhdGUpCiAgZWxzZQogICAgY2FsbF9wcm90ZWN0ZWQgKHVzZXJfdXBkYXRlKQogIGVuZAplbmQK
CmZ1bmN0aW9uIF9kcmF3ICgpCiAgaWYgZXJyb3JfdGhyZWFkIHRoZW4KICAgIGNhbGxfZXJyb3Jf
ZXZlbnQgKGVycm9yX2RyYXcpCiAgZWxzZQogICAgY2FsbF9wcm90ZWN0ZWQgKHVzZXJfZHJhdykK
ICBlbmQKZW5kCg==
:: lib/gavel/
:: lib/gavel/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTA2IDAxOjM4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OSJdXWx6NAAEAAAAAwAAADBuaWw=
:: lib/gavel/algebra.lua
b64$LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQotLSBHQVZFTDogR0VPTUVUUklDIEFMR0VCUkEgVkVDVE9SIExJQlJBUlkK
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLQotLSBUaGlzIHdvcmsgwqkgMjAyNCBieSBKYXNvbiBEZUxhYXQgaXMgbGljZW5z
ZWQgdW5kZXIgQ0MgQlkgNC4wLiBUbwotLSB2aWV3IGEgY29weSBvZiB0aGlzIGxpY2Vuc2UsIHZp
c2l0Ci0tIGh0dHBzOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS80LjAvCgotLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0K
LS0gVXRpbGl0eSBmdW5jdGlvbnMgCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKLS0gJ3N1YicgZnVuY3Rpb24gd2hpY2ggd29ya3Mg
b24gYXJyYXlzIGFzIHdlbGwgYXMgc3RyaW5ncy4KZG8KICAgbG9jYWwgX3N1YiA9IHN1YgogICBm
dW5jdGlvbiBzdWIobHN0LCBpLCBqKQogICAgICBpZiB0eXBlKGxzdCkgPT0gJ3N0cmluZycgdGhl
bgogICAgICAgICByZXR1cm4gX3N1Yihsc3QsIGksIGopCiAgICAgIGVsc2UKICAgICAgICAgbG9j
YWwgciA9IHt9CiAgICAgICAgIGZvciBuPWksaiBvciAjbHN0IGRvCiAgICAgICAgICAgIGFkZChy
LCBsc3Rbbl0pCiAgICAgICAgIGVuZAogICAgICAgICByZXR1cm4gcgogICAgICBlbmQKICAgZW5k
CmVuZAoKLS0gUGFkIHRoZSBlbmQgb2Ygc3RyaW5nICdzJyB3aXRoIHNwYWNlcyB0byBhIHRvdGFs
IGxlbmd0aCAnbGVuJy4gSWYKLS0gJ3MnIGlmIGxvbmdlciB0aGFuICdsZW4nIGl0IHdpbGwgYmUg
c2hvcnRlbmVkLgpmdW5jdGlvbiBwYWQocywgbGVuKQogICBmb3IgaT0xLGxlbiBkbwogICAgICBz
IC4uPSAnICcKICAgZW5kCiAgIHJldHVybiBzdWIocywgMSwgbGVuKQplbmQKCi0tIFJlcGVhdCBz
dHJpbmcgJ3MnLCAncmVwcycgdGltZXMuCmZ1bmN0aW9uIHN0cl9yZXBlYXQocywgcmVwcykKICAg
bG9jYWwgciA9ICcnCiAgIGZvciBpPTEscmVwcyBkbwogICAgICByIC4uPSBzCiAgIGVuZAogICBy
ZXR1cm4gcgplbmQKCi0tIENvbWJpbmF0b3JpYWwgY2hvb3NlIGZ1bmN0aW9uLgpmdW5jdGlvbiBj
aG9vc2UobiwgaykKICAgbG9jYWwgdG9wLCBib3R0b20gPSAxLCAxCiAgIGxvY2FsIGxpbSA9IG1h
eChrLCBuLWspCiAgIGZvciBpPTEsbiBkbwogICAgICBpZiBpIDw9IG4gLSBsaW0gdGhlbgogICAg
ICAgICBib3R0b20gKj0gaQogICAgICBlbHNlaWYgaSA_IGxpbSB0aGVuCiAgICAgICAgIHRvcCAq
PSBpCiAgICAgIGVuZAogICBlbmQKICAgcmV0dXJuIHRvcCAvIGJvdHRvbQplbmQKCi0tIENvbWJp
bmVzIHR3byBhcnJheXMgaW50byBhIHNpbmdsZSBhcnJheS4KZnVuY3Rpb24gY29uY2F0KGwxLCBs
MikKICAgbG9jYWwgciA9IHt9CiAgIGZvcmVhY2gobDEsIGZ1bmN0aW9uKGwpIGFkZChyLCBsKSBl
bmQpCiAgIGZvcmVhY2gobDIsIGZ1bmN0aW9uKGwpIGFkZChyLCBsKSBlbmQpCiAgIHJldHVybiBy
CmVuZAoKLS0gUmV0dXJucyB0aGUgdmFsdWUgZnJvbSB0aGUgdGFibGUgJ3RibCcgYW5kIGluZGV4
ICdrZXknIGlmIGl0Ci0tIGV4aXN0cy4gSWYgJ3RibFtrZXldJyBkb2VzIG5vdCBleGlzdCwgcmV0
dXJucyAnZGVmYXVsdCcgaW5zdGVhZC4KZnVuY3Rpb24gZ2V0KHRibCwga2V5LCBkZWZhdWx0KQog
ICBsb2NhbCB2YWx1ZSA9IHRibFtrZXldCiAgIGlmIG5vdCB2YWx1ZSB0aGVuCiAgICAgIHJldHVy
biBkZWZhdWx0CiAgIGVuZAogICByZXR1cm4gdmFsdWUKZW5kCgotLSBDb252ZXJ0cyB0aGUgYXJy
YXkgJ2xzdCcgdG8gYSBzdHJpbmcgaW5zZXJ0aW5nIHRoZSBzdHJpbmcgJ3NlcCcKLS0gYmV0d2Vl
biBlYWNoIGVsZW1lbnQuCmZ1bmN0aW9uIGpvaW4obHN0LCBzZXApCiAgIHNlcCA9IHNlcCBvciAn
JwogICBsb2NhbCBzID0gdG9zdHIobHN0WzFdKQogICBmb3IgaT0yLCNsc3QgZG8KICAgICAgcyAu
Lj0gc2VwLi50b3N0cihsc3RbaV0pCiAgIGVuZAogICByZXR1cm4gcwplbmQKCi0tIFJldHVybnMg
YWxsIHBvc3NpYmxlIHN1YnNldHMgb2YgdGhlIGdpdmVuIGFycmF5ICdsc3QnLgpmdW5jdGlvbiBw
b3dlcl9zZXQobHN0KQogICBsb2NhbCBwb3dfc2V0ID0ge3t9fQogICBsb2NhbCBuID0gI2xzdAog
ICBsb2NhbCBtID0gMl5uIC0gMQogICBmb3IgaT0xLG0gZG8KICAgICAgbG9jYWwgcyA9IHt9CiAg
ICAgIGZvciBqPTAsbi0xIGRvCiAgICAgICAgIGlmIChpPj5qKSYxID09IDEgdGhlbgogICAgICAg
ICAgICBhZGQocywgbHN0W2orMV0pCiAgICAgICAgIGVuZAogICAgICBlbmQKICAgICAgYWRkKHBv
d19zZXQsIHMpCiAgIGVuZAogICByZXR1cm4gcG93X3NldAplbmQKCi0tIEVORCBVdGlsaXR5IGZ1
bmN0aW9ucyAKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tCgoKCgoKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLSBHZW9tZXRyaWMgQWxnZWJyYQotLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KZG8KICAgLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICAtLSBIZWxwZXIgZnVuY3Rp
b25zIAogICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgogICAtLSBO
b3QgYSBnZW5lcmFsIHNvcnRpbmcgYWxnb3JpdGhtLiBJdCdzIHNwZWNpZmljYWxseSB0byBwcm9w
ZXJseQogICAtLSBzb3J0IHRoZSBtdWx0aXZlY3RvciBiYXNpcyBjb21wb25lbnRzLgogICBsb2Nh
bCBmdW5jdGlvbiBzb3J0KGxzdCkKICAgICAgZm9yIGk9MSwjbHN0IGRvCiAgICAgICAgIGZvciBq
PTEsI2xzdC1pIGRvCiAgICAgICAgICAgIGlmICNsc3Rbal0gPiAjbHN0W2orMV0gb3IKICAgICAg
ICAgICAgICAgKCNsc3Rbal0gPT0gI2xzdFtqKzFdIGFuZCBsc3Rbal0gPiBsc3RbaisxXSkKICAg
ICAgICAgICAgdGhlbgogICAgICAgICAgICAgICBsc3Rbal0sIGxzdFtqKzFdID0gbHN0W2orMV0s
IGxzdFtqXQogICAgICAgICAgICBlbmQKICAgICAgICAgZW5kCiAgICAgIGVuZAogICAgICByZXR1
cm4gbHN0CiAgIGVuZAoKICAgLS0gR2VuZXJhdGVzIHRoZSBiYXNpcyBjb21wb25lbnQgbmFtZXM6
IGUxLCBlMiwgZTEyLCBldGMuCiAgIGxvY2FsIGZ1bmN0aW9uIHRvX2Jhc2lzX25hbWUobHN0KQog
ICAgICBpZiAjbHN0ID09IDAgdGhlbgogICAgICAgICByZXR1cm4gJ3NjYWxhcicKICAgICAgZWxz
ZQogICAgICAgICByZXR1cm4gJ2UnLi5qb2luKGxzdCwgJycpCiAgICAgIGVuZAogICBlbmQKCiAg
IC0tW1sKICAgICAgTXVsdGlwbGllcyB0d28gbXVsdGl2ZWN0b3IgYmFzaXMgY29tcG9uZW50cy4g
VGhpcyBpcyBvbmx5IGRvbmUKICAgICAgb25jZSBmb3IgZXZlcnkgcGFpciBvZiBiYXNpcyBjb21w
b25lbnRzIHdoZW4gZ2VuZXJhdGluZyB0aGUKICAgICAgYWxnZWJyYS4gQWZ0ZXIgdGhhdCBtdWx0
aXZlY3RvciBtdWx0aXBsaWNhdGlvbiBpcyBoYW5kbGVkIGJ5CiAgICAgIGRpcmVjdGx5IGxvb2tp
bmcgdXAgdGhlIG11dGlwbGljYXRpb24gdGFibGUuCgogICBdXQogICBsb2NhbCBmdW5jdGlvbiBt
dWx0aXBseV9iYXNpcyhhLCBiLCBzcXVhcmVzKQogICAgICBsb2NhbCB2YWwgPSAxCiAgICAgIGxv
Y2FsIGVsID0gY29uY2F0KGEsIGIpCiAgICAgIGxvY2FsIG51bV9zd2FwcyA9IDAKICAgICAgZm9y
IGk9MSwjZWwgZG8KICAgICAgICAgZm9yIGo9I2VsLGkrMSwtMSBkbwogICAgICAgICAgICBpZiBl
bFtqXSA8IGVsW2otMV0gdGhlbgogICAgICAgICAgICAgICBlbFtqXSwgZWxbai0xXSA9IGVsW2ot
MV0sIGVsW2pdCiAgICAgICAgICAgICAgIG51bV9zd2FwcyArPSAxCiAgICAgICAgICAgIGVuZAog
ICAgICAgICBlbmQKICAgICAgZW5kCiAgICAgIGxvY2FsIG5ld19lbCA9IHt9CiAgICAgIGxvY2Fs
IGkgPSAxCiAgICAgIHdoaWxlIGkgPD0gI2VsIGRvCiAgICAgICAgIGlmIGkgPT0gI2VsIG9yIGVs
W2ldIH49IGVsW2krMV0gdGhlbgogICAgICAgICAgICBhZGQobmV3X2VsLCBlbFtpXSkKICAgICAg
ICAgICAgaSArPSAxCiAgICAgICAgIGVsc2UKICAgICAgICAgICAgdmFsICo9IHNxdWFyZXNbZWxb
aV1dCiAgICAgICAgICAgIGkgKz0gMgogICAgICAgICBlbmQKICAgICAgZW5kCiAgICAgIC0tIHt2
YWx1ZSwgY29tcG9uZW50LCBncmFkZX0KICAgICAgcmV0dXJuIHt2YWwqKC0xKV5udW1fc3dhcHMs
IHRvX2Jhc2lzX25hbWUobmV3X2VsKSwgI25ld19lbH0KICAgZW5kCgogICAtLSBHZW5lcmF0ZXMg
dGhlIGFsZ2VicmEncyBtdWx0aXBsaWNhdGlvbiB0YWJsZSBiYXNlZCBvbiB0aGUgZ2l2ZW4KICAg
LS0gYmFzaXMgdmVjdG9ycyBhbmQgdGhlaXIgc3F1YXJlcy4KICAgbG9jYWwgZnVuY3Rpb24gZ2Vu
ZXJhdGVfbXVsdGlwbGljYXRpb25fdGFibGUoYmFzaXMsIHNxdWFyZXMpCiAgICAgIGxvY2FsIHRi
bCA9IHt9CiAgICAgIGZvciBhIGluIGFsbChiYXNpcykgZG8KICAgICAgICAgbG9jYWwgbmFtZV9h
ID0gdG9fYmFzaXNfbmFtZShhKQogICAgICAgICBmb3IgYiBpbiBhbGwoYmFzaXMpIGRvCiAgICAg
ICAgICAgIGxvY2FsIG5hbWVfYiA9IHRvX2Jhc2lzX25hbWUoYikKICAgICAgICAgICAgbG9jYWwg
cm93ID0gZ2V0KHRibCwgbmFtZV9hLCB7fSkKICAgICAgICAgICAgcm93W25hbWVfYl0gPSBtdWx0
aXBseV9iYXNpcyhhLCBiLCBzcXVhcmVzKQogICAgICAgICAgICB0YmxbbmFtZV9hXSA9IHJvdwog
ICAgICAgICBlbmQKICAgICAgZW5kCiAgICAgIHJldHVybiB0YmwKICAgZW5kCgogICAtLSBFeHRy
YWN0cyBhbmQgc29ydHMgdGhlIHVuaXF1ZSBiYXNpcyBjb21wb25lbnRzIGZyb20gdGhlCiAgIC0t
IGdlbmVyYXRlZCBtdWx0aXBsaWNhdGlvbiB0YWJsZS4KICAgbG9jYWwgZnVuY3Rpb24gZXh0cmFj
dF9iYXNpcyh0YmwpCiAgICAgIGxvY2FsIGIgPSB7fQogICAgICBmb3IgayxfIGluIHBhaXJzKHRi
bCkgZG8KICAgICAgICAgYWRkKGIsIGspCiAgICAgIGVuZAogICAgICBkZWwoYiwgJ3NjYWxhcicp
CiAgICAgIHJldHVybiBjb25jYXQoeydzY2FsYXInfSwgc29ydChiKSkKICAgZW5kCgogICAtLSBU
aGlzIG1heSBuZWVkIHRvIGJlIGNoYW5nZWQgYXQgc29tZSBwb2ludC4gSXQgYXNzdW1lcyBmZXdl
ciB0aGFuCiAgIC0tIDEwIGRpbWVuc2lvbnMgd2hpY2ggc2VlbXMgcmVhc29uYWJsZSBidXQgcGVv
cGxlIGRvIHdlaXJkIHRoaW5ncwogICAtLSBzby4uLgogICBsb2NhbCBmdW5jdGlvbiBncmFkZShi
YXNlKQogICAgICBpZiBiYXNlID09ICdzY2FsYXInIHRoZW4KICAgICAgICAgcmV0dXJuIDAKICAg
ICAgZWxzZQogICAgICAgICByZXR1cm4gI2Jhc2UgLSAxCiAgICAgIGVuZAogICBlbmQKCiAgIC0t
IEVORCBIZWxwZXIgZnVuY3Rpb25zIAogICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tCgoKCgoKCiAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KICAgLS0gRnVuY3Rpb25zIG9uIG11bHRpdmVjdG9ycwogICAtLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgIGxvY2FsIG12X2Z1bmN0aW9ucyA9IHsKICAgICAgLS1b
WwoKICAgICAgICAgQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBtYWduaXR1ZGUgb2YgYQogICAgICAg
ICBtdWx0aXZlY3Rvci4gCgogICAgICAgICBSZXR1cm5zIGEgTHVhICdudW1iZXInIG5vdCBhIG11
bHRpdmVjdG9yLgoKICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICAgICAgICBOb3RlOiAnbWFnbml0dWRlJyBpcyBwcm9i
YWJseSB0aGUgd3JvbmcgbmFtZSBmb3IgdGhlc2UgdHdvCiAgICAgICAgIGZ1bmN0aW9ucyBidXQg
SSdtIG5vdCBzdXJlIHdoYXQgYSBiZXR0ZXIgb25lIHdvdWxkIGJlLiBGb3IKICAgICAgICAgdmVj
dG9ycyBpbiBFdWNsaWRlYW4gc3BhY2UgdGhleSBkbyBjYWxjdWxhdGUgdGhlIG1hZ25pdHVkZQog
ICAgICAgICBidXQgSSdtIG5vdCBzdXJlIHRoYXQncyB0ZWNobmljYWxseSB0aGUgY29ycmVjdCB0
ZXJtIGZvcgogICAgICAgICBnZW5lcmFsIG11bHRpZWN0b3JzIGFuZCBtYXliZSBub3QgZXZlbiBm
b3IgdmVjdG9ycyBpbgogICAgICAgICBub24tRXVjbGlkZWFuIHNwYWNlcy4KICAgICAgICAgLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoK
ICAgICAgXV0KICAgICAgbWFnbml0dWRlMiA9IGZ1bmN0aW9uKHNlbGYpCiAgICAgICAgIHJldHVy
biAoc2VsZipzZWxmOnJldmVyc2UoKSkuc2NhbGFyCiAgICAgIGVuZCwKICAgICAgCiAgICAgIG1h
Z25pdHVkZSA9IGZ1bmN0aW9uKHNlbGYpCiAgICAgICAgIHJldHVybiBzcXJ0KHNlbGY6bWFnbml0
dWRlMigpKQogICAgICBlbmQsCiAgICAgIAogICAgICBub3JtYWxpemUgPSBmdW5jdGlvbihzZWxm
KQogICAgICAgICByZXR1cm4gc2VsZiAvIHNlbGY6bWFnbml0dWRlKCkKICAgICAgZW5kLAoKCgog
ICAgICAtLVtbCiAgICAgICAgIFRoZSByZXZlcnNlIG9mIGEgbXVsdGl2ZWN0b3IgaXMgdGhlIG11
bHRpdmVjdG9yIG9idGFpbmVkIGJ5CiAgICAgICAgIHJldmVyc2luZyB0aGUgY29tcG9zaXRpb24g
b3JkZXIgb2YgaXRzIGNvbXBvbmVudHMuIEZvcgogICAgICAgICBpbnN0YW5jZSwgZ2l2ZW4gdGhl
IG11bHRpdmVjdG9yIHYgPSAxICsgMmUxICsgM2UyICsgNGUxMiwgaXRzCiAgICAgICAgIHJldmVy
c2UgaXMKCiAgICAgICAgICAgIHZfciA9IDEgKyAyZTEgKyAzZTIgKyA0ZTIxLgoKICAgICAgICAg
VGhlIGJpdmVjdG9yIGNvbXBvbmVudCBlMTIgaXMgdGhlIG9ubHkgcmV2ZXJzaWJsZSBvbmUgYW5k
IGR1ZQogICAgICAgICB0byB0aGUgYW50aS1jb21tdXRhdGl2aXR5IG9mIHRoZSB3ZWRnZSBwcm9k
dWN0IG1lYW5zIHRoYXQKCiAgICAgICAgICAgIHZfciA9IDEgKyAyZTEgKyAzZTIgLSA0ZTEyLgog
ICAgICAgICAKICAgICAgXV0KICAgICAgcmV2ZXJzZSA9IGZ1bmN0aW9uKHNlbGYpCiAgICAgICAg
IGxvY2FsIG12ID0ge30KICAgICAgICAgZm9yIGssdiBpbiBwYWlycyhzZWxmKSBkbwogICAgICAg
ICAgICBpZiAoZ3JhZGUoaykgJSA0KSBcIDIgPT0gMSB0aGVuCiAgICAgICAgICAgICAgIG12W2td
ID0gLTEqdgogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgIG12W2tdID0gdgogICAgICAg
ICAgICBlbmQKICAgICAgICAgZW5kCiAgICAgICAgIHJldHVybiBzZXRtZXRhdGFibGUobXYsIGdl
dG1ldGF0YWJsZShzZWxmKSkKICAgICAgZW5kLAoKCgogICAgICAtLVtbCiAgICAgICAgIENhbGN1
bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBtdWx0aXZlY3Rvci4gTm90ZSB0aGF0LCBpbiBzb21lCiAg
ICAgICAgIGFsZ2VicmFzLCBpbnZlcnNlcyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gZXhpc3QuCgog
ICAgICAgICBJZiAndScgYW5kICd2JyBhcmUgbXVsdGl2ZWN0b3JzIHRoZW4gJ3UnIGlzIHRoZSBp
bnZlcnNlIG9mCiAgICAgICAgICd2JywgYW5kIHZpY2UgdmVyc2EsIGlmCgogICAgICAgICB1KnYg
PT0gdip1ID09IDEuCgogICAgICBdXQogICAgICBpbnZlcnNlID0gZnVuY3Rpb24oc2VsZikKICAg
ICAgICAgcmV0dXJuIHNlbGY6cmV2ZXJzZSgpIC8gc2VsZjptYWduaXR1ZGUyKCkKICAgICAgZW5k
LAoKICAgICAgLS1bWwoKICAgICAgICAgQXBwbGllcyB0aGUgdHJhbnNmb3JtYXRpb24gJ3QnIHRv
IHRoZSBtdWx0aXZlY3Rvci4gIElmICdyZXYnCiAgICAgICAgIGlzIHRydWUsIGFwcGxpZXMgdGhl
IHRyYW5zZm9ybWF0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlciwKICAgICAgICAgcmV2ZXJzaW5n
IHRoZSB0cmFuc2Zvcm1hdGlvbjogQ2xvY2t3aXNlIHJvdGF0aW9ucyBiZWNvbWUKICAgICAgICAg
Y291bnRlci1jbG9ja3dpc2Ugcm90YXRpb25zLCBldGMuCgogICAgICBdXQogICAgICB0cmFuc2Zv
cm0gPSBmdW5jdGlvbihzZWxmLCB0LCByZXYpCiAgICAgICAgIGlmIHJldiB0aGVuCiAgICAgICAg
ICAgIHJldHVybiB0OnJldmVyc2UoKSpzZWxmKnQKICAgICAgICAgZWxzZQogICAgICAgICAgICBy
ZXR1cm4gdCpzZWxmKnQ6cmV2ZXJzZSgpCiAgICAgICAgIGVuZAogICAgICBlbmQsCgogICAgICBn
cmFkZSA9IGZ1bmN0aW9uKHNlbGYsIG4pCiAgICAgICAgIGxvY2FsIG12ID0ge30KICAgICAgICAg
Zm9yIGssdiBpbiBwYWlycyhzZWxmKSBkbwogICAgICAgICAgICBpZiBncmFkZShrKSA9PSBuIHRo
ZW4KICAgICAgICAgICAgICAgbXZba10gPSB2CiAgICAgICAgICAgIGVuZAogICAgICAgICBlbmQK
ICAgICAgICAgcmV0dXJuIHNldG1ldGF0YWJsZShtdiwgZ2V0bWV0YXRhYmxlKHNlbGYpKQogICAg
ICBlbmQsCgogICAgICBpc196ZXJvID0gZnVuY3Rpb24oc2VsZikKICAgICAgICAgZm9yIGssdiBp
biBwYWlycyhzZWxmKSBkbwogICAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICAgZW5kCiAg
ICAgICAgIHJldHVybiB0cnVlCiAgICAgIGVuZAogICB9CgogICAtLSBFTkQgRnVuY3Rpb25zIG9u
IG11bHRpdmVjdG9ycwogICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
CgoKCgoKCgogICAtLVtbCiAgICAgIFRoZSBhbGdlYnJhIG9iamVjdCBjb250YWlucyBmdW5jdGlv
bnMgZm9yIGNyZWF0aW5nIG11bHRpdmVjdG9ycywKICAgICAgdmVjdG9ycywgcm90b3JzLCBldGMu
IEl0IGFsc28gYWN0cyBhcyB0aGUgbWV0YXRhYmxlIGZvciB0aGF0CiAgICAgIGFsZ2VicmEncyBt
dWx0aXZlY3RvcnMuCgogICBdXQogICBsb2NhbCBmdW5jdGlvbiBjcmVhdGVfYWxnZWJyYV9vYmpl
Y3QoZGltLCBzaWcsIHRibCkKICAgICAgbG9jYWwgYmFzaXMgPSBleHRyYWN0X2Jhc2lzKHRibCkK
ICAgICAgbG9jYWwgYWxnOyBhbGcgPSB7CiAgICAgICAgIF90YmwgPSB0YmwsCgogICAgICAgICAt
LSBQcmludHMgdGhlIGJhc2lzIGVsZW1lbnRzIG9mIHRoZSBhbGJlYnJhJ3MgbXVsdGl2ZWN0b3Jz
IGluCiAgICAgICAgIC0tIHRoZSBvcmRlciBleHBlY3RlZCBieSB0aGUgJ211bHRpdmVjdG9yJyBm
dW5jdGlvbi4KICAgICAgICAgYmFzaXMgPSBmdW5jdGlvbigpCiAgICAgICAgICAgIGxvY2FsIHMg
PSAnJwogICAgICAgICAgICBmb3IgYiBpbiBhbGwoYmFzaXMpIGRvCiAgICAgICAgICAgICAgIGxv
Y2FsIHBvc3QgPSAnJwogICAgICAgICAgICAgICBpZiBiID09ICdlMScgdGhlbgogICAgICAgICAg
ICAgICAgICBwb3N0ID0gJyAoeCknCiAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICBp
ZiBzaWdbM10gPT0gMSB0aGVuCiAgICAgICAgICAgICAgICAgIGlmIGIgPT0gJ2UyJyBhbmQgZGlt
ID4gMiB0aGVuCiAgICAgICAgICAgICAgICAgICAgIHBvc3QgPSAnICh5KScKICAgICAgICAgICAg
ICAgICAgZWxzZWlmIGIgPT0gJ2UzJyBhbmQgZGltID4gMyB0aGVuCiAgICAgICAgICAgICAgICAg
ICAgIHBvc3QgPSAnICh6KScKICAgICAgICAgICAgICAgICAgZWxzZWlmIGIgPT0gJ2UnLi5kaW0g
dGhlbgogICAgICAgICAgICAgICAgICAgICBwb3N0ID0gJyAodyknCiAgICAgICAgICAgICAgICAg
IGVuZAogICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgIGlmIGIgPT0gJ2UyJyBh
bmQgZGltID49IDIgdGhlbgogICAgICAgICAgICAgICAgICAgICBwb3N0ID0gJyAoeSknCiAgICAg
ICAgICAgICAgICAgIGVsc2VpZiBiID09ICdlMycgYW5kIGRpbSA_PSAzIHRoZW4KICAgICAgICAg
ICAgICAgICAgICAgcG9zdCA9ICcgKHopJwogICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAg
ICAgICAgZW5kCiAgICAgICAgICAgICAgIHMgLi49IGIuLnBvc3QuLidcbicKICAgICAgICAgICAg
ICAgLS1wcmludChiLi5wb3N0KQogICAgICAgICAgICBlbmQKICAgICAgICAgICAgcmV0dXJuIHMK
ICAgICAgICAgZW5kLAoKICAgICAgICAgLS0gUHJpbnRzIHRoZSBhbGdlYnJhJ3Mgc2lnbmF0dXJl
LgogICAgICAgICBzaWduYXR1cmUgPSBmdW5jdGlvbigpCiAgICAgICAgICAgIHJldHVybiAnYWxn
ZWJyYSgnLi5qb2luKHNpZywgJywnKS4uJyknCiAgICAgICAgICAgIC0tcHJpbnQoJ2FsZ2VicmEo
Jy4uam9pbihzaWcsICcsJykuLicpJykKICAgICAgICAgZW5kLAoKCgogICAgICAgICAtLSBQcmlu
dHMgdGhlIGFsZ2VicmEncyBtdWx0aXBsaWNhdGlvbiB0YWJsZS4KICAgICAgICAgbXVsdGlwbGlj
YXRpb25fdGFibGUgPSBmdW5jdGlvbigpCiAgICAgICAgICAgIC0tIGhlYWRlcgogICAgICAgICAg
ICBsb2NhbCB0X3N0ciA9IHBhZCgnJywgMTApCiAgICAgICAgICAgIGZvciBiIGluIGFsbChiYXNp
cykgZG8KICAgICAgICAgICAgICAgaWYgYiA9PSAnc2NhbGFyJyB0aGVuCiAgICAgICAgICAgICAg
ICAgIHRfc3RyIC4uPSBwYWQoJ3wgMScsIDEyKQogICAgICAgICAgICAgICBlbHNlCiAgICAgICAg
ICAgICAgICAgIHRfc3RyIC4uPSBwYWQoJ3wgJy4uYiwgMTIpCiAgICAgICAgICAgICAgIGVuZAog
ICAgICAgICAgICBlbmQKICAgICAgICAgICAgdF9zdHIgLi49ICdcbicuLnN0cl9yZXBlYXQoJy0n
LCAjdF9zdHIpCgogICAgICAgICAgICAtLSB0YWJsZQogICAgICAgICAgICBmb3IgYjEgaW4gYWxs
KGJhc2lzKSBkbwogICAgICAgICAgICAgICBsb2NhbCByb3cgPSB0YmxbYjFdCiAgICAgICAgICAg
ICAgIGxvY2FsIHJfc3RyCiAgICAgICAgICAgICAgIGlmIGIxID09ICdzY2FsYXInIHRoZW4KICAg
ICAgICAgICAgICAgICAgcl9zdHIgPSAnXG4nLi5wYWQoJzEnLCAxMCkKICAgICAgICAgICAgICAg
ZWxzZQogICAgICAgICAgICAgICAgICByX3N0ciA9ICdcbicuLnBhZChiMSwgMTApCiAgICAgICAg
ICAgICAgIGVuZAogICAgICAgICAgICAgICBmb3IgYjIgaW4gYWxsKGJhc2lzKSBkbwogICAgICAg
ICAgICAgICAgICBsb2NhbCB2LCBjMiA9IHVucGFjayhyb3dbYjJdKQogICAgICAgICAgICAgICAg
ICBpZiB2ID09IDAgdGhlbgogICAgICAgICAgICAgICAgICAgICByX3N0ciAuLj0gcGFkKCd8IDAn
LCAxMikKICAgICAgICAgICAgICAgICAgZWxzZWlmIGMyIH49ICdzY2FsYXInIHRoZW4KICAgICAg
ICAgICAgICAgICAgICAgcl9zdHIgLi49IHBhZCgnfCAnLi4odiA8IDAgYW5kICctJyBvciAnJyku
LmMyLCAxMikKICAgICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICAgICByX3N0
ciAuLj0gcGFkKCd8ICcuLnYsIDEyKQogICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAg
ICAgZW5kCiAgICAgICAgICAgICAgIHRfc3RyIC4uPSByX3N0cgogICAgICAgICAgICBlbmQKICAg
ICAgICAgICAgcmV0dXJuIHRfc3RyCiAgICAgICAgIGVuZCwKCgoKICAgICAgICAgLS1bWwogICAg
ICAgICAgICBDcmVhdGVzIGEgbXVsdGl2ZWN0b3IuIEFsbCAyXm4gY29tcG9uZW50cyBhcmUgcmVx
dWlyZWQKICAgICAgICAgICAgd2hlcmUgJ24nIGlzIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucy4g
TXVsdGl2ZWN0b3JzIGluIDJECiAgICAgICAgICAgIGhhdmUgZm91ciBjb21wb25lbnRzLCBtdWx0
aXZlY3RvcnMgaW4gM0QgaGF2ZSA4CiAgICAgICAgICAgIGNvbXBvbmVudHMsIGV0Yy4KCiAgICAg
ICAgIF1dCiAgICAgICAgIG11bHRpdmVjdG9yID0gZnVuY3Rpb24oLi4uKQogICAgICAgICAgICBs
b2NhbCBhcmdzID0gey4uLn0KICAgICAgICAgICAgYXNzZXJ0KAogICAgICAgICAgICAgICAjYXJn
cyA9PSAyXmRpbSwKICAgICAgICAgICAgICAgJ211bHRpdmVjdG9yIHRha2VzICcuLigyXmRpbSku
LicgYXJndW1lbnRzLicKICAgICAgICAgICAgKQogICAgICAgICAgICBsb2NhbCBtdiA9IHt9CiAg
ICAgICAgICAgIGZvciBpLHYgaW4gaXBhaXJzKGFyZ3MpIGRvCiAgICAgICAgICAgICAgIGlmIHYg
fj0gMCB0aGVuCiAgICAgICAgICAgICAgICAgIG12W2Jhc2lzW2ldXSA9IHYKICAgICAgICAgICAg
ICAgZW5kCiAgICAgICAgICAgIGVuZAogICAgICAgICAgICByZXR1cm4gc2V0bWV0YXRhYmxlKG12
LCBhbGcpCiAgICAgICAgIGVuZCwKCgoKICAgICAgICAgLS0gUmV0dXJucyBhIGZ1bmN0aW9uIGZv
ciBjcmVhdGluZyBtdWx0aXZlY3RvcnMgY29uc2lzdGluZyBvZgogICAgICAgICAtLSBjb21wb25l
bnRzIG9mIGEgcGFydGljdWxhciBncmFkZS4KICAgICAgICAgbl9ibGFkZSA9IGZ1bmN0aW9uKG4p
CiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiguLi4pCiAgICAgICAgICAgICAgIGxvY2FsIG51
bV9hcmdzID0gY2hvb3NlKGRpbSwgbikKICAgICAgICAgICAgICAgbG9jYWwgYXJncyA9IHsuLi59
CiAgICAgICAgICAgICAgIGFzc2VydCgKICAgICAgICAgICAgICAgICAgI2FyZ3MgPT0gbnVtX2Fy
Z3MsCiAgICAgICAgICAgICAgICAgIG4gPT0gMSBhbmQKICAgICAgICAgICAgICAgICAgJ3ZlY3Rv
ciAoMS1ibGFkZSkgdGFrZXMgJy4uZGltLi4nIGFyZ3VtZW50cy4nIG9yCiAgICAgICAgICAgICAg
ICAgIG4uLictYmxhZGUgdGFrZXMgJy4ubnVtX2FyZ3MuLicgYXJndW1lbnRzLicKICAgICAgICAg
ICAgICAgKQogICAgICAgICAgICAgICBsb2NhbCBtdiA9IHt9CiAgICAgICAgICAgICAgIGxvY2Fs
IGkgPSAxCiAgICAgICAgICAgICAgIGZvciBiIGluIGFsbChiYXNpcykgZG8KICAgICAgICAgICAg
ICAgICAgaWYgZ3JhZGUoYikgPT0gbiB0aGVuCiAgICAgICAgICAgICAgICAgICAgIG12W2JdID0g
YXJnc1tpXQogICAgICAgICAgICAgICAgICAgICBpICs9IDEKICAgICAgICAgICAgICAgICAgZW5k
CiAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICByZXR1cm4gc2V0bWV0YXRhYmxlKG12
LCBhbGcpCiAgICAgICAgICAgIGVuZAogICAgICAgICBlbmQsCgoKCiAgICAgICAgIC0tIENyZWF0
ZXMgYSByb3RhdGlvbiBvcGVyYXRvci4KICAgICAgICAgLS0gJ2Zyb20nIGFuZCAndG8nIHNob3Vs
ZCBiZSBub3JtYWxpemVkIHZlY3RvcnMuCiAgICAgICAgIHJvdG9yX2Zyb21fdG8gPSBmdW5jdGlv
bihmcm9tLCB0bykKICAgICAgICAgICAgcmV0dXJuICgxICsgdG8qZnJvbSkgLyBzcXJ0KDIgKyAy
Kihmcm9tICUgdG8pKQogICAgICAgICBlbmQsCgoKCiAgICAgICAgIC0tIENyZWF0ZSBhIHJvdGF0
aW9uIG9wZXJhdG9yIGZyb20gYSBwbGFuZSBhbmQgYW4gYW5nbGUuCiAgICAgICAgIC0tICdwbGFu
ZScgc2hvdWxkIGJlIGEgbm9ybWFsaXplZCBwdXJlIGJpdmVjdG9yIGNyZWF0ZWQgZnJvbQogICAg
ICAgICAtLSB0d28gdmVjdG9ycyB3aXRoIHRoZSBeIG9wZXJhdG9yLiAgJ2FuZ2xlJyBpcyBhIG51
bWJlcgogICAgICAgICAtLSB3aGVyZSAtMSA8PSBhbmdsZSA8PSAxCiAgICAgICAgIHJvdG9yX3Bs
YW5lX2FuZ2xlID0gZnVuY3Rpb24ocGxhbmUsIGFuZ2xlKQogICAgICAgICAgICByZXR1cm4gY29z
KGFuZ2xlLzIpICsgc2luKGFuZ2xlLzIpKnBsYW5lCiAgICAgICAgIGVuZCwKCgoKCiAgICAgICAg
IC0tIENvcGllcyB0aGUgYWxnZWJyYSBvYmplY3QncyBmdW5jdGlvbnMgdG8gdGhlIGdsb2JhbAog
ICAgICAgICAtLSBuYW1lc3BhY2UuCiAgICAgICAgIG1ha2VfZ2xvYmFsID0gZnVuY3Rpb24oc2Vs
ZikKICAgICAgICAgICAgZm9yIGssIHYgaW4gcGFpcnMoc2VsZikgZG8KICAgICAgICAgICAgICAg
aWYga1sxXSB_PSAnXycgdGhlbgogICAgICAgICAgICAgICAgICBfRU5WW2tdID0gdgogICAgICAg
ICAgICAgICBlbmQKICAgICAgICAgICAgZW5kCiAgICAgICAgIGVuZCwKCgoKICAgICAgICAgLS1b
WwoKICAgICAgICAgICAgTGluZWFybHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gdGhlIHR3byBtdWx0
aXZlY3RvcnMgJ3YxJwogICAgICAgICAgICBhbmQgJ3YyJy4gVGhlIHZhbHVlICd0JyBpcyB0eXBp
Y2FsbHkgYmV0d2VlbiAwIGFuZCAxIGJ1dAogICAgICAgICAgICBpdCBjYW4gYmUgYW55IG51bWJl
ci4gV2hlbiB0PTAgdGhlIHJlc3VsdCBpZiAndjEnIGFuZCB3aGVuCiAgICAgICAgICAgIHQ9MSB0
aGUgcmVzdWx0IGlmICd2MicuCgogICAgICAgICBdXQogICAgICAgICBsZXJwID0gZnVuY3Rpb24o
djEsIHYyLCB0KQogICAgICAgICAgICByZXR1cm4gdjEgKyB0Kih2MiAtIHYxKQogICAgICAgICBl
bmQsCgogICAgICAgICBubGVycCA9IGZ1bmN0aW9uKHYxLCB2MiwgdCkKICAgICAgICAgICAgcmV0
dXJuIGxlcnAodjEsIHYyLCB0KTpub3JtYWxpemUoKQogICAgICAgICBlbmQsCgogICAgICAgICBz
bGVycCA9IGZ1bmN0aW9uKHYxLCB2MiwgdCkKICAgICAgICAgICAgbG9jYWwgcHJvZHVjdCA9IHYx
KnYyOnJldmVyc2UoKQogICAgICAgICAgICBsb2NhbCBjb3NfdGhldGEgPSBwcm9kdWN0LnNjYWxh
cgogICAgICAgICAgICBsb2NhbCB0aGV0YV90ID0gdCAqIChtYXRoLmFjb3MoY29zX3RoZXRhKSAv
ICgyICogbWF0aC5waSApKQogICAgICAgICAgICBsb2NhbCBwbGFuZSA9IHByb2R1Y3Q6Z3JhZGUo
Mik6bm9ybWFsaXplKCkKICAgICAgICAgICAgbG9jYWwgciA9IGNvcyh0aGV0YV90KSArIHNpbih0
aGV0YV90KSpwbGFuZQogICAgICAgICAgICByZXR1cm4gcip2MQoKICAgICAgICAgICAgCiAgICAg
ICAgICAgIC0tbG9jYWwgY29zX3RoZXRhID0gdjEldjIKICAgICAgICAgICAgLS1sb2NhbCBwID0g
KHYxKnYyKTpncmFkZSgyKTpub3JtYWxpemUoKQogICAgICAgICAgICAtLXJldHVybiAoKGNvcyh0
aGV0YSp0KSArIHNpbih0aGV0YSp0KSpwKSp2MSk6bm9ybWFsaXplKCk6cmV2ZXJzZSgpCiAgICAg
ICAgICAgIC0tcmV0dXJuIC0oKGNvcyh0aGV0YSp0KSArIHNpbih0aGV0YSp0KSpwKSp2MSk6bm9y
bWFsaXplKCk6cmV2ZXJzZSgpCiAgICAgICAgICAgIC0tbG9jYWwgdGhldGEgPSBtYXRoLmFjb3Mo
djEldjIpIC8gKDIgKiBtYXRoLnBpICkKICAgICAgICAgICAgLS1sb2NhbCBwID0gKHYxXnYyKTpu
b3JtYWxpemUoKQogICAgICAgICAgICAtLXJldHVybiB2MTp0cmFuc2Zvcm0ocm90b3JfcGxhbmVf
YW5nbGUocCwgdGhldGEqdCkpCiAgICAgICAgIGVuZCwKCgoKCiAgICAgICAgIC0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgLS0gTXVsdGl2ZWN0b3IgbWV0
YS1tZXRob2RzCiAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0KICAgICAgICAgX190b3N0cmluZyA9IGZ1bmN0aW9uKHNlbGYpCiAgICAgICAgICAgIGxvY2Fs
IHMgPSAnJwogICAgICAgICAgICBmb3IgYiBpbiBhbGwoYmFzaXMpIGRvCiAgICAgICAgICAgICAg
IGxvY2FsIHYgPSBzZWxmW2JdCiAgICAgICAgICAgICAgIGlmIHYgYW5kIHYgfj0gMCBhbmQgYiA9
PSAnc2NhbGFyJyB0aGVuCiAgICAgICAgICAgICAgICAgIHMgLi49IHYKICAgICAgICAgICAgICAg
ZWxzZWlmIHYgYW5kIHYgPCAwIHRoZW4KICAgICAgICAgICAgICAgICAgcyAuLj0gdi4uYgogICAg
ICAgICAgICAgICBlbHNlaWYgdiBhbmQgdiA_IDAgdGhlbgogICAgICAgICAgICAgICAgICBzIC4u
PSAoI3MgPiAwIGFuZCAnKycgb3IgJycpLi52Li5iCiAgICAgICAgICAgICAgIGVuZAogICAgICAg
ICAgICBlbmQKICAgICAgICAgICAgcmV0dXJuIHMgPT0gJycgYW5kICcwJyBvciBzCiAgICAgICAg
IGVuZCwKCiAgICAgICAgIF9fZXEgPSBmdW5jdGlvbihhLCBiKQogICAgICAgICAgICBmb3Igayx2
IGluIHBhaXJzKGEpIGRvCiAgICAgICAgICAgICAgIGlmIGJba10gfj0gdiB0aGVuCiAgICAgICAg
ICAgICAgICAgIHJldHVybiBmYWxzZQogICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgZW5k
CiAgICAgICAgICAgIGZvciBrLHYgaW4gcGFpcnMoYikgZG8KICAgICAgICAgICAgICAgaWYgYVtr
XSB_PSB2IHRoZW4KICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgICAgICAg
IGVuZAogICAgICAgICAgICBlbmQKICAgICAgICAgICAgcmV0dXJuIHRydWUKICAgICAgICAgZW5k
LAogICAgICAgICAKICAgICAgICAgX191bm0gPSBmdW5jdGlvbihzZWxmKQogICAgICAgICAgICBy
ZXR1cm4gLTEgKiBzZWxmCiAgICAgICAgIGVuZCwKCiAgICAgICAgIF9fYWRkID0gZnVuY3Rpb24o
YSwgYikKICAgICAgICAgICAgbG9jYWwgbXYgPSB7fQogICAgICAgICAgICBpZiB0eXBlKGEpID09
ICdudW1iZXInIHRoZW4KICAgICAgICAgICAgICAgZm9yIGssdiBpbiBwYWlycyhiKSBkbwogICAg
ICAgICAgICAgICAgICBtdltrXSA9IHYKICAgICAgICAgICAgICAgZW5kCiAgICAgICAgICAgICAg
IG12LnNjYWxhciA9IGdldChtdiwgJ3NjYWxhcicsIDApICsgYQogICAgICAgICAgICBlbHNlaWYg
dHlwZShiKSA9PSAnbnVtYmVyJyB0aGVuCiAgICAgICAgICAgICAgIHJldHVybiBiICsgYQogICAg
ICAgICAgICBlbHNlCiAgICAgICAgICAgICAgIGZvciBjIGluIGFsbChiYXNpcykgZG8KICAgICAg
ICAgICAgICAgICAgbG9jYWwgdiA9IGdldChhLCBjLCAwKSArIGdldChiLCBjLCAwKQogICAgICAg
ICAgICAgICAgICBpZiB2IH49IDAgdGhlbgogICAgICAgICAgICAgICAgICAgICBtdltjXSA9IHYK
ICAgICAgICAgICAgICAgICAgZW5kCiAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICBlbmQK
ICAgICAgICAgICAgcmV0dXJuIHNldG1ldGF0YWJsZShtdiwgYWxnKQogICAgICAgICBlbmQsCgog
ICAgICAgICBfX3N1YiA9IGZ1bmN0aW9uKGEsIGIpCiAgICAgICAgICAgIHJldHVybiBhICsgKC1i
KQogICAgICAgICBlbmQsCiAgICAgICAgIAoKCgogICAgICAgICAtLVtbCiAgICAgICAgICAgIEdl
b21ldHJpYyBQcm9kdWN0LgoKICAgICAgICAgICAgVGhlIGdlb21ldHJpYyBwcm9kdWN0IGlzIHRo
ZSBzdW0gb2YgdGhlIGRvdCBwcm9kdWN0IGFuZAogICAgICAgICAgICB0aGUgd2VkZ2UgcHJvZHVj
dCBvZiB0d28gbXVsdGl2ZWN0b3JzLiBGb3IgbXVsdGl2ZWN0b3JzCiAgICAgICAgICAgICdhJyBh
bmQgJ2InLAoKICAgICAgICAgICAgICAgIGEqYiA9PSBhLi5iICsgYV5iLgoKICAgICAgICAgXV0K
ICAgICAgICAgX19tdWwgPSBmdW5jdGlvbihhLCBiKQogICAgICAgICAgICBsb2NhbCBtdiA9IHt9
CiAgICAgICAgICAgIGlmIHR5cGUoYSkgPT0gJ251bWJlcicgdGhlbgogICAgICAgICAgICAgICBm
b3Igayx2IGluIHBhaXJzKGIpIGRvCiAgICAgICAgICAgICAgICAgIG12W2tdID0gYSp2CiAgICAg
ICAgICAgICAgIGVuZAogICAgICAgICAgICAgICByZXR1cm4gc2V0bWV0YXRhYmxlKG12LCBhbGcp
CiAgICAgICAgICAgIGVsc2VpZiB0eXBlKGIpID09ICdudW1iZXInIHRoZW4KICAgICAgICAgICAg
ICAgcmV0dXJuIGIgKiBhCiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgZm9yIGIxLCB2
MSBpbiBwYWlycyhhKSBkbwogICAgICAgICAgICAgICAgICBmb3IgYjIsIHYyIGluIHBhaXJzKGIp
IGRvCiAgICAgICAgICAgICAgICAgICAgIGxvY2FsIG4sIGMgPSB1bnBhY2sodGJsW2IxXVtiMl0p
CiAgICAgICAgICAgICAgICAgICAgIGxvY2FsIGN1ciA9IGdldChtdiwgYywgMCkKICAgICAgICAg
ICAgICAgICAgICAgbXZbY10gPSBjdXIgKyB2MSp2MipuCiAgICAgICAgICAgICAgICAgICAgIGlm
IG12W2NdID09IDAgdGhlbgogICAgICAgICAgICAgICAgICAgICAgICBtdltjXSA9IG5pbAogICAg
ICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgICAgICAgZW5kCiAgICAgICAgICAgICAg
IGVuZAogICAgICAgICAgICAgICByZXR1cm4gc2V0bWV0YXRhYmxlKG12LCBhbGcpCiAgICAgICAg
ICAgIGVuZAogICAgICAgICBlbmQsCgoKCgogICAgICAgICAtLVtbCiAgICAgICAgICAgIFdlZGdl
IChPdXRlcikgUHJvZHVjdC4gKFRoZSAnYmV0dGVyJyBjcm9zcyBwcm9kdWN0LikKCiAgICAgICAg
ICAgIENvbWJpbmVzIHZlY3RvcnMgaW50byBoaWdoZXIgZGltZW5zaW9uYWwgc3ViLXNwYWNlcy4g
IEZvcgogICAgICAgICAgICBpbnN0YW5jZSB0YWtpbmcgdmVjdG9ycyB4PSgxLCAwLCAwKSBhbmQg
eT0oMCwgMSwgMCksIHheeQogICAgICAgICAgICBnaXZlcyBhbiAoaXJyZWR1Y2libGUpIHF1YW50
aXR5IHh5LCBjYWxsZWQgYSBiaXZlY3RvciBvcgogICAgICAgICAgICAyLWJsYWRlLCB3aGljaCBy
ZXByZXNlbnRzIGEgMkQgc3ViLXNwYWNlIChUaGF0IGlzOiBhCiAgICAgICAgICAgIHBsYW5lLiBT
cGVjaWZpY2FsbHkgdGhlIHh5LXBsYW5lIGluIHRoaXMgY2FzZS4pCgogICAgICAgICAgICBUaGUg
d2VkZ2UgcHJvZHVjdCBpcyBhbnRpLWNvbW11dGF0aXZlLiBUaGF0IGlzIGZvciB2ZWN0b3JzCiAg
ICAgICAgICAgICdhJyBhbmQgJ2InCgogICAgICAgICAgICAgICAgYV5iID0gLWJeYSwKCiAgICAg
ICAgICAgIHNvIHRoZSBvcmRlciBpbiB3aGljaCB5b3UgY29tYmluZSB0aGVtIG1hdHRlcnMuCgog
ICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tCiAgICAgICAgICAgIE5vdGUgb24gdGhlIGNyb3NzIHByb2R1Y3Q6Cgog
ICAgICAgICAgICBHaXZlbiB0aGUgdmVjdG9ycyBhID0gKGExLCBhMiwgYTMpIGFuZCBiID0gKGIx
LCBiMiwgYjMpLAoKICAgICAgICAgICAgICAgIGFeYiA9IChhMSpiMiAtIGEyKmIxLCBhMSpiMyAt
IGEzKmIxLCBhMipiMyAtIGEzKmIyKS4KCiAgICAgICAgICAgIEV4Y2VwdCBlYWNoIG9mIHRob3Nl
IGNvbXBvbmVudHMgaXMgYSBiaXZlY3RvciAvbm90LyBhCiAgICAgICAgICAgIHZlY3Rvci4gSWYg
eW91J3JlIGZhbWlsaWFyIHdpdGggc3RhbmRhcmQgdmVjdG9yIG9wZXJhdGlvbnMKICAgICAgICAg
ICAgeW91IG1heSBub3RpY2UgdGhhdCB0aGF0J3MgL2FsbW9zdC8gdGhlIGNyb3NzIHByb2R1Y3QK
ICAgICAgICAgICAgZm9ybXVsYToKCiAgICAgICAgICAgICAgICBhIHggYiA9IChhMipiMyAtIGEz
KmIyLCAtKGExKmIzIC0gYTMqYjEpLCBhMSpiMiAtIGEyKmIxKQoKICAgICAgICAgICAgVGhlIG9y
ZGVyIG9mIHRoZSB0ZXJtcyBpcyByZXZlcnNlZCBhbmQgdGhlIG1pZGRsZQogICAgICAgICAgICBj
b21wb25lbnQgaXMgbmVnYXRpdmUuIFNvIGluIDMgZGltZW5zaW9ucywgdGhlIHdlZGdlCiAgICAg
ICAgICAgIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMgYW5kIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3
bwogICAgICAgICAgICB2ZWN0b3JzIGNvbnRhaW4gdGhlIHNhbWUgaW5mb3JtYXRpb24gYnV0IHBy
ZXNlbnRlZAogICAgICAgICAgICBzbGlnaHRseSBkaWZmZXJlbnRseTogVGhlIGNyb3NzIHByb2R1
Y3QgZ2l2ZXMgeW91IGEgdmVjdG9yCiAgICAgICAgICAgIHBlcnBlbmRpY3VsYXIgdG8gc29tZSBw
bGFuZSB3aGlsZSB0aGUgd2VkZ2UgcHJvZHVjdCBnaXZlcwogICAgICAgICAgICB5b3UgdGhlIHBs
YW5lIGl0c2VsZi4KCiAgICAgICAgICAgIEEgdW5pcXVlIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRv
IGEgcGxhbmUgaXMgYSBwcm9wZXJ0eQogICAgICAgICAgICB1bmlxdWUgdG8gMyBkaW1lbnNpb25z
LiBQbGFuZXMgdGhlbXNlbHZlcywgb24gdGhlIG90aGVyCiAgICAgICAgICAgIGhhbmQsIGV4aXN0
IGluIGFsbCBkaW1lbnNpb25zIGdyZWF0ZXIgdGhhbiAyLiBTbyB3aGlsZSB0aGUKICAgICAgICAg
ICAgY3Jvc3MgcHJvZHVjdCBkb2Vzbid0IGdlbmVyYWxpemUgdG8gb3RoZXIgZGltZW5zaW9ucywg
dGhlCiAgICAgICAgICAgIHdlZGdlIHByb2R1Y3QgZG9lcy4gCgogICAgICAgICAgICBUaGUgY3Jv
c3MgcHJvZHVjdCBjYW4gYmUgaW1wbGVtZW50ZWQgaWYgeW91IHJlYWxseSB3YW50IG9yCiAgICAg
ICAgICAgIG5lZWQgaXQgYnV0IGluIGdlbmVyYWwgdGhpbmdzIHdpbGwgYmUgc2ltcGxlciBhbmQg
bW9yZQogICAgICAgICAgICBnZW5lcmFsIHdoZW4gd29ya2luZyB3aXRoIHdlZGdlIHByb2R1Y3Rz
IGluc3RlYWQuCiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiAgICAgICAgIF1dCiAgICAgICAgIF9fcG93ID0g
ZnVuY3Rpb24oYSwgYikKICAgICAgICAgICAgaWYgdHlwZShhKSA9PSAnbnVtYmVyJyBvciB0eXBl
KGIpID09ICdudW1iZXInIHRoZW4KICAgICAgICAgICAgICAgcmV0dXJuIGEqYgogICAgICAgICAg
ICBlbHNlCiAgICAgICAgICAgICAgIGxvY2FsIG12ID0ge30KICAgICAgICAgICAgICAgZm9yIGIx
LCB2MSBpbiBwYWlycyhhKSBkbwogICAgICAgICAgICAgICAgICBmb3IgYjIsIHYyIGluIHBhaXJz
KGIpIGRvCiAgICAgICAgICAgICAgICAgICAgIGxvY2FsIG4sIGMgPSB1bnBhY2sodGJsW2IxXVti
Ml0pCiAgICAgICAgICAgICAgICAgICAgIGlmIGdyYWRlKGIxKSArIGdyYWRlKGIyKSA9PSBncmFk
ZShjKSB0aGVuCiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsIGN1ciA9IGdldChtdiwgYywg
MCkKICAgICAgICAgICAgICAgICAgICAgICAgbXZbY10gPSBjdXIgKyB2MSp2MipuCiAgICAgICAg
ICAgICAgICAgICAgICAgIGlmIG12W2NdID09IDAgdGhlbgogICAgICAgICAgICAgICAgICAgICAg
ICAgICBtdltjXSA9IG5pbAogICAgICAgICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAg
ICAgICAgICAgZW5kCiAgICAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICBlbmQKICAg
ICAgICAgICAgICAgcmV0dXJuIHNldG1ldGF0YWJsZShtdiwgYWxnKQogICAgICAgICAgICBlbmQK
ICAgICAgICAgZW5kLAoKCgoKICAgICAgICAgLS1bWwogICAgICAgICAgICBEb3QgKElubmVyKSBQ
cm9kdWN0LgoKICAgICAgICAgICAgRm9yIHB1cmUgdmVjdG9ycyAnYScgYW5kICdiJywgJ2EuLmIn
IGlzIHRoZSBmYW1pbGlhciBkb3QKICAgICAgICAgICAgcHJvZHVjdCBidXQgdGhlIGZ1bmN0aW9u
IHdvcmtzIG9uIG1peGVkIG11bHRpdmVjdG9ycyBhcwogICAgICAgICAgICB3ZWxsLgoKICAgICAg
ICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLQogICAgICAgICAgICBOb3RlOiBUaGVyZSBhcmUgYWN0dWFsbHkgbXVsdGlwbGUgd2F5
cyB0byBnZW5lcmFsaXplIHRoZQogICAgICAgICAgICBkb3QgcHJvZHVjdCB0byBtdWx0aXZlY3Rv
cnMgYW5kIHRoaXMgaXMgb25seSBvbmUgb2YKICAgICAgICAgICAgdGhlbS4gRm9yIGFub3RoZXIs
IHNlZSB0aGUgc2NhbGFyIHByb2R1Y3QgKF9fbW9kLyUpCiAgICAgICAgICAgIGJlbG93LiBUaGV5
IGFsbCBnaXZlIHRoZSBzYW1lIHNvbHV0aW9uIGZvciBwdXJlIHZlY3RvcnMKICAgICAgICAgICAg
YnV0IGhhdmUgc2xpZ2h0bHkgZGlmZmVyZW50IG1lYW5pbmdzL3VzZXMgd2hlbiBhcHBsaWVkIHRv
CiAgICAgICAgICAgIG11bHRpdmVjdG9ycy4gSSd2ZSBjaG9zZW4gdGhpcyBpbXBsZW1lbnRhdGlv
biBiZWNhdXNlIGl0J3MKICAgICAgICAgICAgYm90aCBmYWlybHkgY29tbW9uIGFuZCByZWFzb25h
Ymx5IGNvbXB1dGF0aW9uYWxseQogICAgICAgICAgICBlZmZpY2llbnQuIFVubGVzcyB5b3UncmUg
ZG9pbmcgcmVhbGx5IGFkdmFuY2UgdGhpbmdzLCB5b3UKICAgICAgICAgICAgcHJvYmFibHkgZG9u
J3QgbmVlZCB0byBjYXJlLgogICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgogICAgICAgICBdXQogICAgICAgICBfX2Nv
bmNhdCA9IGZ1bmN0aW9uKGEsIGIpCiAgICAgICAgICAgIGlmIHR5cGUoYSkgPT0gJ251bWJlcicg
b3IgdHlwZShiKSA9PSAnbnVtYmVyJyB0aGVuCiAgICAgICAgICAgICAgIHJldHVybiBhKmIKICAg
ICAgICAgICAgZWxzZQogICAgICAgICAgICAgICBsb2NhbCBtdiA9IHt9CiAgICAgICAgICAgICAg
IGZvciBiMSwgdjEgaW4gcGFpcnMoYSkgZG8KICAgICAgICAgICAgICAgICAgZm9yIGIyLCB2MiBp
biBwYWlycyhiKSBkbwogICAgICAgICAgICAgICAgICAgICBsb2NhbCBuLCBjID0gdW5wYWNrKHRi
bFtiMV1bYjJdKQogICAgICAgICAgICAgICAgICAgICBpZiBiMSB_PSAnc2NhbGFyJyBhbmQgYjIg
fj0gJ3NjYWxhcicgYW5kCiAgICAgICAgICAgICAgICAgICAgICAgIGFicyhncmFkZShiMikgLSBn
cmFkZShiMSkpID09IGdyYWRlKGMpCiAgICAgICAgICAgICAgICAgICAgIHRoZW4KICAgICAgICAg
ICAgICAgICAgICAgICAgbG9jYWwgY3VyID0gZ2V0KG12LCBjLCAwKQogICAgICAgICAgICAgICAg
ICAgICAgICBtdltjXSA9IGN1ciArIHYxKnYyKm4KICAgICAgICAgICAgICAgICAgICAgICAgaWYg
bXZbY10gPT0gMCB0aGVuCiAgICAgICAgICAgICAgICAgICAgICAgICAgIG12W2NdID0gbmlsCiAg
ICAgICAgICAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICAgICAgICBlbmQKICAgICAg
ICAgICAgICAgICAgZW5kCiAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICByZXR1cm4g
c2V0bWV0YXRhYmxlKG12LCBhbGcpCiAgICAgICAgICAgIGVuZAogICAgICAgICBlbmQsCgoKCgog
ICAgICAgICAtLVtbCiAgICAgICAgICAgIFNjYWxhciBwcm9kdWN0LgoKICAgICAgICAgICAgQWx3
YXlzIHJldHVybnMgYSBudW1iZXIgL25vdC8gYSBtdWx0aXZlY3Rvci4gSWYgJ2EnIGFuZAogICAg
ICAgICAgICAnYicgYXJlIHZlY3RvcnMgdGhpcyBudW1iZXIgd2lsbCBhZ3JlZSB3aXRoIHRoZSBu
b3JtYWwgZG90CiAgICAgICAgICAgIHByb2R1Y3QgYnV0IG1heSBub3QgYWdyZWUgd2l0aCB0aGUg
ZG90IHByb2R1Y3QgZm9yIG1peGVkCiAgICAgICAgICAgIG11bHRpdmVjdG9yIGlucHV0cy4KCiAg
ICAgICAgIF1dCiAgICAgICAgIF9fbW9kID0gZnVuY3Rpb24oYSwgYikKICAgICAgICAgICAgaWYg
dHlwZShhKSA9PSAnbnVtYmVyJyB0aGVuCiAgICAgICAgICAgICAgIHJldHVybiBhbGcubXVsdGl2
ZWN0b3IoYSAqIGdldChiLCAnc2NhbGFyJywgMCkpCiAgICAgICAgICAgIGVsc2VpZiB0eXBlKGIp
ID09ICdudW1iZXInIHRoZW4KICAgICAgICAgICAgICAgcmV0dXJuIGFsZy5tdWx0aXZlY3Rvcihi
ICogZ2V0KGEsICdzY2FsYXInLCAwKSkKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICBs
b2NhbCBzID0gMAogICAgICAgICAgICAgICBmb3IgYjEsIHYxIGluIHBhaXJzKGEpIGRvCiAgICAg
ICAgICAgICAgICAgIGZvciBiMiwgdjIgaW4gcGFpcnMoYikgZG8KICAgICAgICAgICAgICAgICAg
ICAgbG9jYWwgbiwgYyA9IHVucGFjayh0YmxbYjFdW2IyXSkKICAgICAgICAgICAgICAgICAgICAg
aWYgZ3JhZGUoYykgPT0gMCB0aGVuCiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gdjEqdjIq
bgogICAgICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgICAgICAgZW5kCiAgICAgICAg
ICAgICAgIGVuZAogICAgICAgICAgICAgICByZXR1cm4gcwogICAgICAgICAgICBlbmQKICAgICAg
ICAgZW5kLAoKCgoKICAgICAgICAgLS0gU2NhbGFyIGRpdmlzaW9uIG9mIGEgbXVsdGl2ZWN0b3Iu
ICdiJyBtdXN0IGJlIGEgbnVtYmVyLgogICAgICAgICBfX2RpdiA9IGZ1bmN0aW9uKGEsIGIpCiAg
ICAgICAgICAgIGFzc2VydCh0eXBlKGIpID09ICdudW1iZXInLCAnY2Fubm90IGRpdmlkZSBieSBu
b24tbnVtYmVyLicpCiAgICAgICAgICAgIHJldHVybiBhKigxL2IpCiAgICAgICAgIGVuZCwKCgoK
CgogICAgICAgICBfX2luZGV4ID0gZnVuY3Rpb24oc2VsZiwgaykKICAgICAgICAgICAgaWYgayA9
PSAneCcgdGhlbgogICAgICAgICAgICAgICByZXR1cm4gcmF3Z2V0KHNlbGYsICdlMScpIG9yIDAK
ICAgICAgICAgICAgZW5kCiAgICAgICAgICAgIGlmIHNpZ1szXSA9PSAxIHRoZW4KICAgICAgICAg
ICAgICAgaWYgayA9PSAneScgYW5kIGRpbSA_IDIgdGhlbgogICAgICAgICAgICAgICAgICByZXR1
cm4gcmF3Z2V0KHNlbGYsICdlMicpIG9yIDAKICAgICAgICAgICAgICAgZWxzZWlmIGsgPT0gJ3on
IGFuZCBkaW0gPiAzIHRoZW4KICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhd2dldChzZWxmLCAn
ZTMnKSBvciAwCiAgICAgICAgICAgICAgIGVsc2VpZiBrID09ICd3JyB0aGVuCiAgICAgICAgICAg
ICAgICAgIHJldHVybiByYXdnZXQoc2VsZiwgJ2UnLi5kaW0pIG9yIDAKICAgICAgICAgICAgICAg
ZW5kCiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgaWYgayA9PSAneScgYW5kIGRpbSA_
PSAyIHRoZW4KICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhd2dldChzZWxmLCAnZTInKSBvciAw
CiAgICAgICAgICAgICAgIGVsc2VpZiBrID09ICd6JyBhbmQgZGltID49IDMgdGhlbgogICAgICAg
ICAgICAgICAgICByZXR1cm4gcmF3Z2V0KHNlbGYsICdlMycpIG9yIDAKICAgICAgICAgICAgICAg
ZW5kCiAgICAgICAgICAgIGVuZAogICAgICAgICAgICByZXR1cm4gcmF3Z2V0KHNlbGYsIGspIG9y
IG12X2Z1bmN0aW9uc1trXSBvciAwCiAgICAgICAgIGVuZCwKCiAgICAgICAgIC0tIEVORCBNdWx0
aXZlY3RvciBtZXRhLW1ldGhvZHMKICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQogICAgICB9CiAgICAgIGFsZy52ZWN0b3IgPSBhbGcubl9ibGFkZSgxKQog
ICAgICByZXR1cm4gYWxnCiAgIGVuZAoKCgoKICAgLS1bWwogICAgICBHZW5lcmF0ZXMgYW4gYWxn
ZWJyYSB3aXRoICdwJyBwb3NpdGl2ZSBkaW1lbnNpb25zLCAnbicgbmVnYXRpdmUKICAgICAgZGlt
ZW5zaW9ucyBhbmQgJ3onIGRlZ2VuZXJhdGUgZGltZW5zaW9ucy4gQXJndW1lbnRzICduJyBhbmQg
J3onCiAgICAgIGFyZSBvcHRpb25hbC4KCiAgICAgIEFsZ2VicmFzIHdpdGggb25seSBwb3NpdGl2
ZSBkaW1lbnNpb25zIGNvcnJlc3BvbmQgdG8gc3RhbmRhcmQKICAgICAgRXVjbGlkZWFuIGdlb21l
dHJpZXMgd2hpbGUgYWxnZWJyYXMgd2l0aCBuZWdhdGl2ZSBhbmQvb3IKICAgICAgZGVnZW5lcmF0
ZSBkaW1lbnNpb25zIGNvcnJlc3BvbmQgdG8gbW9yZSBleG90aWMgZ2VvbWV0cmllcy4KCiAgICAg
IFNvbWUgbm90ZXdvcnRoeSBnZW9tZXRyaWVzOgoKICAgICAgICB8IFNpZ25hdHVyZSAgICAgICAg
fCBHZW9tZXRyeSAgICAgICAgICAgICAgIHwKICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tKy0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwKICAgICAgICB8IGFsZ2VicmEoMikgICAgICAgfCAyRCBF
dWNsaWRlYW4gICAgICAgICAgIHwKICAgICAgICB8IGFsZ2VicmEoMykgICAgICAgfCAzRCBFdWNs
aWRlYW4gICAgICAgICAgIHwKICAgICAgICB8IGFsZ2VicmEoMiwgMCwgMSkgfCAyRCBQcm9qZWN0
aXZlICgyRCBQR0EpIHwKICAgICAgICB8IGFsZ2VicmEoMywgMCwgMSkgfCAzRCBQcm9qZWN0aXZl
ICgzRCBQR0EpIHwKICAgICAgICB8IGFsZ2VicmEoMSwgMykgICAgfCBTcGFjZXRpbWUgICAgICAg
ICAgICAgIHwKCiAgICAgIFRoZSAnYWxnZWJyYScgZnVuY3Rpb24gcmV0dXJucyBhbiBvYmplY3Qg
Y29udGFpbmluZyBhbGwKICAgICAgZnVuY3Rpb25zIGZvciB0aGF0IGFsZ2VicmEuIFRoaXMgYWxs
b3dzIHlvdSB0byB1c2UgbXVsdGlwbGUKICAgICAgZGlmZmVyZW50IGFsZ2VicmFzIGluIGEgc2lu
Z2xlIHByb2plY3QuIEhvd2V2ZXIsIGlmIHlvdSdyZSB1c2luZwogICAgICBhIHNpbmdsZSBhbGdl
YnJhIHlvdSBjYW4gbWFrZSB0aGUgZnVuY3Rpb25zIGdsb2JhbCBmb3IgbW9yZQogICAgICBjb252
ZW5pZW50IHVzZToKCiAgICAgIGFsZ2VicmEoMyk6bWFrZV9nbG9iYWwoKQoKICAgXV0KICAgZnVu
Y3Rpb24gYWxnZWJyYShwLCBuLCB6KQogICAgICBuID0gbiBvciAwCiAgICAgIHogPSB6IG9yIDAK
ICAgICAgbG9jYWwgZGltID0gcCArIG4gKyB6CiAgICAgIGxvY2FsIGJhc2lzID0ge30KICAgICAg
bG9jYWwgc3F1YXJlcyA9IHt9CiAgICAgIGZvciBpPTEsZGltIGRvCiAgICAgICAgIGFkZChiYXNp
cywgaSkKICAgICAgICAgc3F1YXJlc1tpXSA9IGkgPD0gcCBhbmQgMSBvciAoaSA8PSBwK24gYW5k
IC0xIG9yIDApCiAgICAgIGVuZAogICAgICBiYXNpcyA9IHBvd2VyX3NldChiYXNpcykKICAgICAg
bG9jYWwgbXVsdF90YmwgPSBnZW5lcmF0ZV9tdWx0aXBsaWNhdGlvbl90YWJsZShiYXNpcywgc3F1
YXJlcykKICAgICAgcmV0dXJuIGNyZWF0ZV9hbGdlYnJhX29iamVjdChkaW0sIHtwLCBuLCB6fSwg
bXVsdF90YmwpCiAgIGVuZAplbmQKCi0tIEVORCBHZW9tZXRyaWMgQWxnZWJyYQotLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCi0tIEVO
RCBHQVZFTDogR0VPTUVUUklDIEFMR0VCUkEgVkVDVE9SIExJQlJBUlkKLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQo=
:: lib/pgui/
:: lib/pgui/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTA2IDAxOjM4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OSJdXWx6NAAEAAAAAwAAADBuaWw=
:: lib/pgui/pgui.lua
--[[pod_format="raw",author="Sergio Rodriguez Gomez",created="2024-04-17 13:28:56",icon=userdata("u8",16,16,"000000010101010101010101010000000000010d0d0d0d0d0d0d0d0d0d01000000010d0d0d060606060606060d0d0100010d0d0d0606060606060606060d0d01010d0d06060607070707070706060d01010d0d06060707070101070707060d01010d0d06060707070101070707060d01010d0d06060707070101070707060d01010d0d06060607070707070706060d01010d0d06060606060606060606060d01010d0d0d0606060606060606060d0d0101010d0d0d060606060606060d0d0d010101010d0d0d0d0d0d0d0d0d0d0d0101000101010d0d0d0d0d0d0d0d0d0101000000010101010101010101010101000000000001010101010101010101000000"),modified="2024-05-06 01:05:21",notes="An Immediate Mode GUI Library",revision=11342,title="pgui",version="1.0.1"]]
--[[
	pgui - an Immediate Mode GUI library for Picotron
	v1.0.2
	By Sergio Rodriguez Gomez
	https://srsergior.itch.io/ | https://srsergiorodriguez.github.io/code?lang=en
	MIT License
	Donate:
	https://ko-fi.com/srsergior | https://buymeacoffee.com/srsergior
]]--

pgui_components = {}

pgui_components.unknown = {fns={}, data={text="?",_id="unknown"}}
pgui_components.unknown.fns.draw = function(self) print("[?]", self.pos.x, self.pos.y, 8) end

pgui_components.placeholder = {fns={}, data={_id="placeholder",visible=false}}
pgui_components.placeholder.fns.draw = function(self) if (self.visible) print("[x]", self.pos.x, self.pos.y, 8) end

pgui_components.text = {fns={}, data={_id="text",text="TEXT",size=vec(0,7)}}
pgui_components.text.fns.update = function(self)
	return self.text
end
pgui_components.text.fns.draw = function(self)
	pgui:_text(self.text,self,self.color[4])
end

pgui_components.rect = {fns={}, data={_id="rect",size=vec(16,16)}}
pgui_components.rect.fns.draw = function(self)
	pgui:_rect(self.pos.x+self.offset.x,self.pos.y+self.offset.y,self.size.x,self.size.y,self.color[4],false)
end

pgui_components.line = {fns={}, data={_id="rect",size=vec(16,16)}}
pgui_components.line.fns.draw = function(self)
	local x = self.pos.x+self.offset.x
	local y = self.pos.y+self.offset.y
	line(x,y,x+self.size.x,y+self.size.y,self.color[4])
end

pgui_components.radiocircle = {fns={}, data={_id="radiocircle",r=4,on=false}}
pgui_components.radiocircle.fns.update = function(self)
	self.size = vec(self.r*2,self.r*2)
end
pgui_components.radiocircle.fns.draw = function(self)
	local fill = self.color[3]
	local stroke = self.color[4]
	pgui:_radiocirc(self,self.r,fill,stroke,self.on)
end

pgui_components.multibox = {fns={}, data={_id="multibox",size=vec(8,8),on=false}}
pgui_components.multibox.fns.draw = function(self)
	--this is a single box, but used for multiple selection components!
	local fill = self.color[3]
	local stroke = self.color[4]
	local pos = self.pos+self.offset
	if (self.on) pgui:_rect(pos.x,pos.y,self.size.x,self.size.y,fill,true)
	pgui:_rect(pos.x,pos.y,self.size.x,self.size.y,stroke,false)
end

pgui_components.box = {fns={}, data={_id="box",size=vec(16,16),stroke=true,active=false,hover=false}}
pgui_components.box.fns.draw = function(self)
	local fill = self.color[1]
	if (self.mouse.over and self.hover) fill = self.color[2]
	if (self.mouse.left_btn and self.active) fill = self.color[3]
	local stroke = self.stroke and self.color[4] or fill
	pgui:_box(self, self.size.x, self.size.y, fill, stroke)
end

pgui_components.text_box = {fns={}, data={_id="text_box",text="TEXTBOX",margin=2,stroke=true,active=false,hover=false}}
pgui_components.text_box.fns.update = function(self,offset)
	if pgui.stats.memos.text_width[self.text] == nil then
		pgui.stats.memos.text_width[self.text] = pgui:get_text_width(self.text)
	end
	local text_width = pgui.stats.memos.text_width[self.text]
	local lines = #split(self.text,"\n")
	local text_height = lines == 1 and 6 or lines * 9
	self.size = vec(text_width+(self.margin*2),(self.margin*2)+text_height)
	pgui:component("box",{offset=offset,clip=self.clip,layer=self.layer,size=self.size,hover=self.hover,active=self.active,stroke=self.stroke,color=self.color})
	pgui:component("text",{offset=offset,clip=self.clip,layer=self.layer,pos=vec(self.margin,self.margin),active=self.active,text=self.text,color=self.color})
	return self.text
end

pgui_components.sprite = {fns={}, data={_id="sprite",sprite=0,size=vec(0,7),fn=function() end}}
pgui_components.sprite.fns.draw = function(self)
	self.fn()
	pgui:_sprite(self.sprite,self)
	palt()
end

pgui_components.sprite_box = {fns={}, data={_id="sprite_box",sprite=0,margin=2,stroke=true,active=false,hover=false,fn=function() end}}
pgui_components.sprite_box.fns.update = function(self,offset)
	local sprite_width = get_spr(self.sprite):width() - 1
	local sprite_height = get_spr(self.sprite):height() - 1
	self.size = vec(sprite_width+(self.margin*2),(self.margin*2)+sprite_height)
	pgui:component("box",{offset=offset,clip=self.clip,layer=self.layer,size=self.size,hover=self.hover,active=self.active,stroke=self.stroke,color=self.color})
	pgui:component("sprite",{offset=offset,clip=self.clip,layer=self.layer,pos=vec(self.margin,self.margin),active=self.active,sprite=self.sprite,p=self.p})
	return self.sprite
end

pgui_components.input = {fns={}, data={label="input",_id="input",text="INPUT",charlen=16,margin=2}}
pgui_components.input.fns.update = function(self,offset)
	if (pgui:get_store(self.label,true) == nil) then
		local text_width = pgui:get_text_width(self.text)
		pgui:set_store(self.label,{
			cursor_pos = self.margin+text_width,
			cursor_idx = 0,
			active = false,
		},true)
	end
	
	local text_box = pgui:component("text_box",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,text=self.text,margin=self.margin},true)
	text_box:_update()
	text_box.size.x = (6 * self.charlen) + (self.margin * 2)
	self.size = text_box.size:copy()
	
	local mouse_events = pgui:mouse_events(text_box)
	local store = pgui:get_store(self.label,true)
	if mouse_events.clicked then
		local relx = mouse_events.rel_pos.x
		local cursor_pos = pgui:get_cursor_pos(self.margin,self.text,relx)
		store.cursor_pos = cursor_pos[1]
		store.cursor_idx = cursor_pos[2]
		store.cursor_line = 0
		store.active = true
	elseif pgui:get_mouse().mb == 1 and not mouse_events.left_btn then
		store.active = false
	end
	
	if store.active then
		local lines = #split(self.text,"\n")
		local col = self.color[3]
		if pgui.stats.blink then
			pgui:component("box",{offset=offset,clip=self.clip,layer=self.layer,
				pos=vec(pgui:get_store(self.label,true).cursor_pos,2+(store.cursor_line*9)),
				size=vec(1,3+(self.margin*2)),color={col,col,col,col,col,col}
			})
		end
		if keyp("backspace") and store.cursor_idx > 0 then
			local removed = sub(self.text,store.cursor_idx,store.cursor_idx)
			self.text = sub(self.text,0,store.cursor_idx-1)..sub(self.text,store.cursor_idx+1)
			store.cursor_pos -= pgui:get_text_width(removed)
			store.cursor_idx -= 1
		elseif keyp("left") and store.cursor_idx > 0 then
			local prevchar = sub(self.text,store.cursor_idx,store.cursor_idx)
			store.cursor_pos -= pgui:get_text_width(prevchar)
			store.cursor_idx -= 1
		elseif keyp("right") and store.cursor_idx < #self.text then
			local nextchar = sub(self.text,store.cursor_idx+1,store.cursor_idx+1)
			store.cursor_pos += pgui:get_text_width(nextchar)
			store.cursor_idx += 1
		end
		local is_shift = false
		if (key("shift")) is_shift = true --TODO
		for scancode in all(pgui.stats.scancodes) do
			if keyp(scancode) and self.charlen > #self.text then
				local str = scancode == "space" and " " or scancode
				--str = str == "enter" and "\n" or str --for future text field
				str = str == "enter" and "" or str
				str = is_shift and str:upper() or str
				self.text = sub(self.text,0,store.cursor_idx)..str..sub(self.text,store.cursor_idx+1)
				store.cursor_pos += pgui:get_text_width(str)
				store.cursor_idx += 1
			end
		end
		
		--this will help to create a text field component in the future
		store.cursor_line += #split(self.text,"\n") - lines
		
		store.cursor_pos = max(0,store.cursor_pos)
		store.cursor_idx = max(0,store.cursor_idx)
	end
	
	return self.text
end

pgui_components.button = {fns={}, data={_id="button",text="BUTTON",margin=2,stroke=true,disable=false}}
pgui_components.button.fns.update = function(self,offset,mouse)
	local text_box = pgui:component("text_box",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,text=self.text,hover=true and not self.disable,active=true and not self.disable,stroke=self.stroke,margin=self.margin},true)
	text_box:_update()
	self.size = text_box.size:copy()
	return pgui:mouse_events(text_box).clicked
end

pgui_components.vstack = {fns={}, data={_id="vstack",stroke=true,height=0,margin=3,gap=3,contents={},box=true}}
pgui_components.vstack.fns.update = function(self,offset)
	self.size = vec(0,self.margin*2)
	local y = self.margin
	if (self.box) pgui:component("box",{offset=offset,clip=self.clip,layer=self.layer,color=self.color,size=self.size,stroke=self.stroke})
	local upds = {}
	for content in all(self.contents) do
		local com = pgui:component(content[1],content[2],true)
		com.offset = offset
		com.clip = self.clip
		com.layer = self.layer
		com.pos = vec(self.margin+com.pos.x,y+com.pos.y)
		if (com._id == "dropdown") com.grow = true
		local upd = com:_update()
		add(upds,upd)
		self.size.x = com.size.x > self.size.x and com.size.x + com.pos.x or self.size.x
		self.size.y += com.size.y + self.gap
		y += (com.size.y + self.gap)
	end
	self.size.x += self.margin*2
	self.size.y = self.height != 0 and self.height or self.size.y - self.gap
	return upds	
end

pgui_components.hstack = {fns={}, data={_id="hstack",stroke=true,width=0,margin=3,gap=3,contents={},box=true}}
pgui_components.hstack.fns.update = function(self,offset)
	self.size = vec(self.margin*2,0)
	local x = self.margin
	if (self.box) pgui:component("box",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,size=self.size,stroke=self.stroke})
	local upds = {}
	for content in all(self.contents) do
		local com = pgui:component(content[1],content[2],true)
		com.offset = offset
		com.clip = self.clip
		com.layer = self.layer
		com.pos = vec(x+com.pos.x,self.margin+com.pos.y)
		if (com._id == "dropdown") com.grow = false
		local upd = com:_update()
		add(upds,upd)
		self.size.y = com.size.y > self.size.y and com.size.y + com.pos.y or self.size.y
		self.size.x += com.size.x + self.gap
		x += (com.size.x + self.gap)
	end
	self.size.y += self.margin*2
	self.size.x = self.width > 0 and self.width or self.size.x - self.gap
	return upds
end

pgui_components.topbar = {fns={}, data={_id="topbar",width=479,gap=3,contents={}}}
pgui_components.topbar.fns.update = function(self)
	local hstack = pgui:component("hstack",{gap=self.gap,layer=self.layer,width=self.width,stroke=false,margin=0,contents=self.contents},true)
	return hstack:_update()
end

pgui_components.dropdown = {fns={}, data={label="dd",_id="dropdown",grow=false,text="DROPDOWN",stroke=true,margin=2,gap=3,contents={},disable=false}}
pgui_components.dropdown.fns.update = function(self,offset)
	local button = pgui:component("button",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,size=self.size,stroke=self.stroke,text=self.text,margin=self.margin,disable=self.disable},true)
	
	local clicked = button:_update()
	self.size = button.size:copy()
	pgui:component("line",{clip=self.clip,offset=offset,layer=self.layer,pos=vec(0,button.size.y),size=vec(self.size.x,0),color=self.color}) --a kind of hacky solution to overlapping dropwdown buttons, but it avoids adding lots of code to the library
	if clicked and not self.disable then
		local toggle = not pgui:get_store(self.label,true)
		pgui:set_store(self.label,toggle,true)
	end
	if pgui:get_store(self.label,true) then
		local y = button.size.y
		local vstack = pgui:component("vstack",{clip=self.clip,offset=offset,layer=self.layer+1,color=self.color,pos=vec(0,y),margin=self.margin,gap=self.gap,contents=self.contents},true)
		local upd = vstack:_update()
		if (self.grow) self.size.y += vstack.size.y
		return upd
	end
	return {}
end

pgui_components.scrollable = {fns={}, data={label="scrll",_id="scrollable",scroll_x=false,scroll_y=true,size=vec(50,50),sensibility=4,stroke=true,content={"text_box",{text="scrollable",margin=50}}}}
pgui_components.scrollable.fns.update = function(self,offset)
	if pgui:get_store(self.label,true) == nil then
		pgui:set_store(self.label,{
			scrolling = vec(0,0)
		},true)
	end
	local store = pgui:get_store(self.label,true)
	local com = pgui:component(self.content[1],self.content[2],true)
	com.offset=offset
	com.pos = store.scrolling
	com.layer = self.layer
	com.clip = {self.pos.x+self.offset.x,self.pos.y+self.offset.y,self.size.x,self.size.y}
	local upd = com:_update()
	if (not self.scroll_x or (com.size.x < self.size.x)) self.size.x = com.size.x
	if (not self.scroll_y or (com.size.y < self.size.y)) self.size.y = com.size.y
			
	function limit(com,scroller)
		if com.size.y - scroller.size.y + com.pos.y <= 0 then
			com.pos.y = scroller.size.y - com.size.y
		elseif com.pos.y > 0 then
			com.pos.y = 0
		end
		if com.size.x - scroller.size.x + com.pos.x <= 0 then
			com.pos.x = scroller.size.x - com.size.x
		elseif com.pos.x > 0 then
			com.pos.x = 0
		end
	end	
		
	if self.mouse.over then
		if (self.scroll_y) store.scrolling.y += self.mouse.vs*self.sensibility
		if (self.scroll_x) store.scrolling.x += self.mouse.hs*self.sensibility
		limit(com,self)
	end
	
	if (self.stroke) pgui:component("rect",{offset=self.offset,clip=self.clip,layer=self.layer,color=self.color,pos=self.pos,size=self.size})
	return upd
end

pgui_components.hslider = {fns={}, data={_id="hslider",format=function(v) return v end,min=0,max=100,value=50,size=vec(100,10),stroke=true,flr=false}}
pgui_components.hslider.fns.update = function(self,offset)
	local box = pgui:component("box",{clip=self.clip,offset=offset,layer=self.layer,size=self.size,stroke=self.stroke},true)
	box:_update()
	local range = self.max - self.min
	if box.mouse.left_btn then
		self.value = self.min + (box.mouse.rel_pos.x / self.size.x) * range
	end 
	self.value = mid(self.min, self.value, self.max)
	local width = ((self.value - self.min) / range)*self.size.x
	if (self.flr) self.value = flr(self.value)
	local s = vec(width,self.size.y)
	local col = self.color
	col[1] = self.color[3]
	if (width > 0) pgui:component("box",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,size=s,stroke=self.stroke,color=col})
	local text_pos = vec(2,(self.size.y - 6) / 2)
	pgui:component("text",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,text=self.format(self.value),pos=text_pos})
	return self.value
end

pgui_components.radio = {fns={}, data={_id="radio",gap=3,r=3,sep=4,selected=1,options={}}}
pgui_components.radio.fns.update = function(self,offset)
	local y = 0
	local i = 1
	local d = self.r * 2
	local tw = 0
	for opt in all(self.options) do
		if pgui.stats.memos.text_width[opt] == nil then
			pgui.stats.memos.text_width[opt] = pgui:get_text_width(opt)
		end
		local text_width = pgui.stats.memos.text_width[opt]
		tw =  text_width > tw and text_width or tw 
		local pos = vec(0, y)
		local on  = self.selected == i
		local radiocircle = pgui:component("radiocircle",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,pos=pos,r=self.r,on=on},true)
		radiocircle:_update()
		local text_pos = pos+vec(d+self.sep,(d - 7) / 2)
		pgui:component("text",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,text=opt,pos=text_pos})
		y += d + self.gap
		local clicked = pgui:mouse_events(radiocircle).clicked
		if (clicked) self.selected = i 
		i += 1
	end	
	self.size = vec(tw + self.sep + d,y - self.gap)
	return self.selected
end

pgui_components.multi_select = {fns={}, data={_id="multi_select",gap=3,box_size=7,sep=4,selected={},options={}}}
pgui_components.multi_select.fns.update = function(self,offset)
	if (#self.selected < #self.options) then
		notify("#options and #selected do not match in multi_select")
		return
	end
	local y = 0
	local i = 1
	local d = self.box_size
	local tw = 0
	local selected = pgui:copy_table(self.selected)
	for opt in all(self.options) do
		if pgui.stats.memos.text_width[opt] == nil then
			pgui.stats.memos.text_width[opt] = pgui:get_text_width(opt)
		end
		local text_width = pgui.stats.memos.text_width[opt]
		tw =  text_width > tw and text_width or tw 
		local pos = vec(0, y)
		local on  = selected[i]
		local multibox = pgui:component("multibox",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,pos=pos,size=vec(d,d),on=on},true)
		multibox:_update()
		local text_pos = pos+vec(d+self.sep,(d - 7) / 2)
		pgui:component("text",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,text=opt,pos=text_pos})
		y += d + self.gap
		local clicked = pgui:mouse_events(multibox).clicked
		if (clicked) selected[i] = not selected[i]
		i += 1
	end	
	self.size = vec(tw + self.sep + d,y - self.gap)
	return selected
end

pgui_components.checkbox = {fns={}, data={_id="checkbox",text="CHECKBOX",value=false,box_size=8,sep=4}}
pgui_components.checkbox.fns.update = function(self,offset)
	local selected = {self.value}
	local options = {self.text}
	local select = pgui:component("multi_select",{clip=self.clip,offset=offset,layer=self.layer,color=self.color,sep=self.sep,selected=selected,options=options,box_size=self.box_size},true)
	local upd = select:_update()
	self.size = select.size
	return upd[1]
end

pgui_components.palette = {fns={}, data={_id="palette",columns=4,gap=3,box_size=10,colors={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},selected=1}}
pgui_components.palette.fns.update = function(self,offset)
	local i = 0
	for col in all(self.colors) do
		local new_palette = pgui:copy_table(self.color)
		new_palette[1] = col
		new_palette[4] = self.selected == col and new_palette[3] or new_palette[4]
		local pos = vec((i % self.columns), flr(i / self.columns))
		pos = pos * (self.box_size+self.gap)
		local box = pgui:component("box",{clip=self.clip,offset=offset,layer=self.layer,pos=pos,size=vec(self.box_size,self.box_size),stroke=true,color=new_palette},true)
		box:_update()
		if (box.mouse.clicked) self.selected = col
		i += 1
	end
	self.size = vec(
		((self.box_size + self.gap)*self.columns)-self.gap,
		((self.box_size+self.gap)*ceil(#self.colors / self.columns))-self.gap
	)
	return self.selected
end

------ end of components -------

pgui_methods =  {}

--CYCLE METHODS
function pgui_methods:refresh()
	self.components = {}
	self.stats.t += 1
	self.stats.blink = flr(self.stats.t / 20 % 2) == 1
	self.stats.prev_mouse = self:copy_table(self.stats.mouse)
	self.stats.mouse = self:get_mouse()
end

function pgui_methods:draw(callback)
	callback = callback and callback or function() end
	self:sort_table(self.components,"layer")
	for component in all(self.components) do
		if self.components.layer == 4 then
			callback()
		end
		if self.stats.clipping and #component.clip == 4 then
			clip(component.clip[1]+1,component.clip[2]+1,component.clip[3]-1,component.clip[4]-1)
			component:draw()
			clip()
		else
			component:draw()
		end
	end	
end

--COMPONENT METHODS

function pgui_methods:component(name, opts, no_update)
	local template = pgui_components[name]
	if not template then
		notify("ERROR: pgui component '"..tostring(name).."' does not exist")
		return self:new_component(pgui_components["unknown"], "_",{})
	else
		return self:new_component(template, opts, no_update)
	end
end

function pgui_methods:new_component(template, opts, no_update)
	local base_data = {pos=vec(0,0),size=vec(0,0),offset=vec(0,0),color=pgui_methods:copy_table(self.stats.palette),clip={},layer=0}
	local data = {}
	for k,v in pairs(base_data) do
		local value = v
		if (opts[k] != nil) value = opts[k]
		data[k] = value
	end
	for k,v in pairs(template.data) do
		local value = v
		if (opts[k] != nil) value = opts[k]
		data[k] = value
	end
			
	local fns = template.fns
	function fns:_update()
		self.mouse = pgui:mouse_events(self)
		if (self.draw) addcomponent(self)
		if (self.update) then
			local offset = pgui:get_offset(self)
			local upd = self:update(offset)
			return upd == nil and self._id or upd
		else
			return self._id
		end
	end
		
	function addcomponent(component)
		add(self.components, component)
	end
		
	local component = setmetatable(data, {__index=template.fns})	
	
	if no_update then
		return component --create components without updating them, for composition inside other components
	else
		return component:_update()
	end
end

--UPDATE METHODS

function pgui_methods:get_offset(component)
	return component.pos+component.offset
end

function pgui_methods:get_mouse()
	local mx,my,mb,hs,vs = mouse()
	return {mx=mx,my=my,mb=mb,hs=hs,vs=vs}
end

function pgui_methods:get_text_width(str)
	local lines = split(str,"\n")
	
	function tw(text)
		local sum = 0
		local charlist = split(text,"")
		for ch in all(charlist) do
			if ch == "I" or ch == "i" or ch == "l" or ch == "1" then
				sum += 4
			elseif ch == "M" or ch == "T" or ch == "W" or ch == "m" or ch == "w" then
				sum += 6
			else
				sum += 5
			end
		end
		return sum
	end
	
	if (#lines == 1) return tw(str)
	
	local width = 0
	for text in all(lines) do
		local w = tw(text)
		width = width > w and width or w
	end
	
	return width
end

function pgui_methods:get_cursor_pos(margin,text,relx)
	local sum = margin
	local charlist = split(text,"")
	local i = 0
	for ch in all(charlist) do
		local v = 0	
		if ch == "I" or ch == "i" or ch == "l" or ch == "1" then
			v = 4
		elseif ch == "M" or ch == "T" or ch == "W" or ch == "m" or ch == "w" then
			v += 6
		else
			v += 5
		end
		if (sum + v > relx) return {sum,i}
		sum += v
		i += 1
	end
	return {sum,i}
end

function pgui_methods:get_scancodes()
	local scancodes = {
		"~","!","@","#","$","%","^","&","*","(",")",
		"_","-","+","=","[","]","{","}","|",":",";",
		"'",",",".","<",">","/","?","`",
		"0","1","2","3","4","5","6","7","8","9",
		"a","b","c","d","e","f","g","h",
		"i","j","k","l","m","n","o","p",
		"q","r","s","t","u","v","w","x",
		"y","z","space","enter"
	}
	return scancodes
end

function pgui_methods:copy_table(table)
	local new_table = {}
	for k,v in pairs(table) do
		if type(v) == "table" then
			new_table[k] = self:copy_table(v)
		else
			new_table[k] = v
		end
	end
	return new_table
end

function pgui_methods:mouse_events(data)
	local mx = self.stats.mouse.mx
	local my = self.stats.mouse.my
	local mb = self.stats.mouse.mb
	local hs = self.stats.mouse.hs
	local vs = self.stats.mouse.vs
	local pmb = self.stats.prev_mouse.mb
	
	--adjust response to clipping
	local colrect = data.pos+data.offset --collision rectangle position
	local colsize = data.size:copy() --collision rectangle size
	
	if self.stats.clipping then
		if #data.clip == 4 then
			local cx = data.clip[1]
			local cw = data.clip[3]
			local cy = data.clip[2]
			local ch = data.clip[4]
			
			if colrect.x < cx then
				colsize.x = (colrect.x + colsize.x) - cx
				colrect.x = cx
			elseif colrect.x + data.size.x > cx + cw then
				colsize.x = colsize.x - ((colrect.x + colsize.x) - (cx +  cw))
			end 
			if colrect.y < cy then
				colsize.y = (colrect.y + colsize.y) - cy
				colrect.y = cy
			elseif colrect.y + data.size.y > cy + ch then
				colsize.y = colsize.y - ((colrect.y + colsize.y) - (cy +  ch))
			end
		end
	end
	---
	
	local collision = self:rect_collision(colrect,{x=mx,y=my},colsize,{x=1,y=1})
	local lb = collision and mb == 1
	local rb = collision and mb == 2
	local clicked = pmb == 0 and lb
	local released = pmb == 1 and collision and mb == 0
	return {over=collision,left_btn=lb,right_btn=rb,clicked=clicked,released=released,rel_pos=vec(mx,my)-data.offset-data.pos,hs=hs,vs=vs}
end

function pgui_methods:rect_collision(apos, bpos, as, bs)
	--check if two rectangles are colliding
	local colliding = true
	if (apos.x + as.x < bpos.x or
		apos.x > bpos.x + bs.x or
		apos.y + as.y < bpos.y or
		apos.y > bpos.y + bs.y) then
		colliding = false
	end 
	return colliding
end

--RENDER METHODS

function pgui_methods:set_palette(palette)
	if (#palette == 6) then
		self.stats.palette = palette
	else
		notify("Palette must be a table with 6 indexes")
	end
end

function pgui_methods:activate_clipping()
	self.stats.clipping = true
end

function pgui_methods:_text(text,com,col)
	local x = com.pos.x+com.offset.x
	local y = com.pos.y+com.offset.y
	print(tostring(text),x,y,col)
end

function pgui_methods:_rect(x,y,w,h,c,f)
	palt(0,true)
	line(x+1,y,x+w-1,y,c)
	line(x,y+1,x,y+h-1,c)
	line(x+1,y+h,x+w-1,y+h,c)
	line(x+w,y+1,x+w,y+h-1,c)
	if f then
		rectfill(x+1,y+1,x+w-1,y+h-1)
	end
end

function pgui_methods:_box(com,w,h,fill,stroke)
	local x = com.pos.x+com.offset.x
	local y = com.pos.y+com.offset.y
	self:_rect(x,y,w,h,fill,true)
	self:_rect(x,y,w,h,stroke,false)
end

function pgui_methods:_radiocirc(com,r,fill,stroke,f)
	local x = com.pos.x+com.offset.x+r
	local y = com.pos.y+com.offset.y+r
	if (f) circfill(x,y,r,fill)
	circ(x,y,r,stroke)
end

function pgui_methods:_sprite(sprite,com)
	local x = com.pos.x+com.offset.x
	local y = com.pos.y+com.offset.y
	spr(sprite,x,y)
end

--STORE METHODS

function pgui_methods:uid()
	local uid = split(date()," ")
	uid = table.concat(split(uid[1],"-"),"")..table.concat(split(uid[2],":"),"")..sub(tostring(rnd() * 1000),0,3)
	return uid
end

function pgui_methods:set_store(id,data,alt)
	if not alt then
		self.store[id] = data
	else
		self.alt_store[id] = data
	end
end

function pgui_methods:get_store(id,alt)
	if not alt then
		return self.store[id]
	else
		return self.alt_store[id]
	end
end

function pgui_methods:sort_table(tbl, key)
	local n = #tbl
	local sorted = false
	
	while not sorted do
		sorted = true
		for i = 1, n - 1 do
			if tbl[i][key] > tbl[i + 1][key] then
				tbl[i], tbl[i + 1] = tbl[i + 1], tbl[i]
				sorted = false
			end
		end
		n = n - 1
	end
end

pgui = setmetatable({
		components={},
		store={},
		alt_store={},
		stats={
			t = 0,
			blink = false,
			palette = {7,18,12,0,7,6},
			clipping = false,
			memos = {text_width={}},
			scancodes=pgui_methods:get_scancodes(),
			mouse=pgui_methods:get_mouse(),
			prev_mouse=pgui_methods:get_mouse()
		}
	},
	{__index=pgui_methods}
)
:: lib/vgfx/
:: lib/vgfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTA2IDAxOjM4OjA2Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OSJdXWx6NAAEAAAAAwAAADBuaWw=
:: lib/vgfx/vgfx.lua
--[[pod_format="raw",created="2024-03-22 09:38:38",modified="2024-05-05 22:34:01",revision=9584]]
--[[ vgfx.lua
0.3
vector graphics drawing

=== usage: ===
if loading vector sprite in a .vgfx file:
	load_vgfx("pathToMyFile.vgfx")
	sprv(index, x,y, [rotation, scale, color])
	
if generating vector sprites at runtime:
	my_vsprite = {
	make_polygon(vars),
	make_polygon(vars),
	make_polygon(vars),
	...	}
make sure vertices you pass to make_polygon() are triangulated
there are several functions included for this purpose

for simple triangle drawing, just call tri(x0,y0, x1,y1, x2,y2)
but make sure you call vgfx_vclip() ahead so it is properly clipped!

=== todo: ===
-polygon outline generation
-tween/interpolate between two vector sprites/polygons
-animation playback
-compression for vector data
-maybe try writing directly to graphics memory if it's faster
-reset color() to what it was before drawing a vector sprite
-fix outline drawing not matching triangle edges


=== docs: ===
"vector sprite": an array of polygons
"polygon": a table with the elements: 
 - col (color)
 - ocol (outline color)
 - pts (points/vertices for triangle drawing)
   - 1D f64 userdata numbers (x0,y0, y1,y2, ...etc)
   - SHOULD BE TRIANGULATED before being sent to sprv()
 - lpts (points/vertices for line drawing (happens after triangles))
   - same format expected as pts, or nil
 - fill (fill pattern)



=== changes: ===
0.2
- polygon vertices now use userdata
- wire rendering uses same colour rules as filled triangles
- basic polygon outlining
0.3
- polygons now have a single colour and specified fill pattern
- graphics fill pattern is returned to its state from before drawing a vector sprite
- doesn't crash for polygons with nil vertices anymore
- tri raster now follows clipping rect (vertically) for better performace when 
	polygons go beyond the screen edges
- support for loading .vgfx files and drawing their sprites
- replaced vgfx_precise with vgfx_subpixel
- 
]]

--enable for debug view of polygon triangles
vgfx_wire=false

--disable to make all tri point positions floored
--  Disabling subpixel positions adds to the render time and makes
--  animated transformations appear a little less smooth, but
--  it should prevent edge seams between polygon triangles
vgfx_subpixel=true


vgfx_vsprites={}
function load_vgfx(path)
	vgfx_vsprites={}
	local loadfile = fetch(path)
	for s=1,#loadfile do
		local vs={}
		for l=1,#loadfile[s] do
			local layer = loadfile[s][l]
			if layer.show then
				local ol = false
				if layer.triangulation=="line" or layer.triangulation=="line_closed" then
					--its a lines-only layer
					ol=true
					layer.points_triangulated = {}
				elseif layer.triangulation=="fan" then
					layer.points_triangulated = fan_triangulate(layer.points)
				elseif layer.triangulation=="strip" then
					layer.points_triangulated = strip_triangulate(layer.points)
				else
					layer.points_triangulated = earclip_triangulate(layer.points)
				end
				
				
				local olcol = layer.outline
				if (#layer.points>1 and (layer.outline!=-1 or ol)) then
					ol = convert_point_list(layer.points)
					if layer.triangulation!="line" and layer.triangulation!="strip" then
						--we close the outline
						add(ol,ol[1])
					end
				end
				if (olcol<0) olcol = layer.col_a
				
				add(vs, make_polygon(
					layer.points_triangulated,
					(layer.col_b<<8)+layer.col_a,
					layer.fill,
					ol,
					olcol
				) )
			end
	---
		end
		add(vgfx_vsprites, vs)
	end
end

function make_polygon(vertices, c1, pattern, outline, c2)
	local polygon={
		col=c1,
		ocol=c2,
		pts=userdata("f64",#vertices),
		lpts=nil,
		fill=0b0000000000000000,
	}
	
	for i=1,#vertices do
		set(polygon.pts, i-1, vertices[i])
	end
	
	if outline==true then
		--generate outline
		--this doesn't work yet!
		outline=nil
	elseif outline then
		--polygon.lpts = one_d_point_list(outline)
		polygon.lpts = one_d_point_list(convert_point_list(outline))
		
	end
	if pattern and pattern!=false then
		if pattern==true then
			--set pattern to checkered dither
			polygon.fill = 0b1010010110100101
		else
			--use specified pattern
			polygon.fill = pattern
		end
	end

	return polygon
end


vgfx_clipt=0
vgfx_clipb=0
--sets top/bottom clip 
function vgfx_vclip()
	vgfx_clipt = peek4(0x5514)
	vgfx_clipb = peek4(0x5514)+peek2(0x552e)
end
--draw a vector sprite
function sprv(v, x,y, rot,scale, col)
	if #vgfx_vsprites>=1 and type(v)!="table" then
		v = vgfx_vsprites[v+1]
	end
	vgfx_vclip()
	

	local oldfill = peek(0x5500,8)
	--local oldcol = peek(?????,?????)

	local s, cs = 0,0
	if rot and rot!=0 then
		s = sin(rot)
		cs = cos(rot)
	end
	
	local sinxy = vec(0,0,0,0,0,0)
	local cosxy = vec(0,0,0,0,0,0)
	local triv = userdata("f64",6)
	local tpos = vec(x,y,x,y,x,y)
	if (not scale) scale = 1
	
	if (col) color(col)
	local b=0
	local polys = 0
	for p=1,#v do
		b=0
		polys = 0
		if v[p].pts then
			polys=#v[p].pts
			if not col then
				fillp(v[p].fill)
				color(v[p].col)
			end
		end
		while b<polys do
			set(triv, 0, v[p].pts:get(b,6))
			b+=6
			
			triv *= scale
			
			if rot and rot!=0 then
				sinxy = triv*s
				cosxy = triv*cs
				
				set(triv, 0,
				cosxy[0]-sinxy[1], sinxy[0]+cosxy[1],
				cosxy[2]-sinxy[3], sinxy[2]+cosxy[3],
				cosxy[4]-sinxy[5], sinxy[4]+cosxy[5])
			end
			triv += tpos
			tri(triv[0],triv[1],triv[2],triv[3],triv[4],triv[5])
		end
		if (v[p].lpts) then
			local b=0
			local oline=vec(0,0,0,0)
			if (not col) color((v[p].ocol<<8)+v[p].ocol)
			while b<#v[p].lpts-2 do
				set(oline, 0, v[p].lpts:get(b,4))
				b+=2
				oline *= scale
				if rot and rot!=0 then
					sinxy = oline*s
					cosxy = oline*cs
					
					set(oline, 0,
					cosxy[0]-sinxy[1], sinxy[0]+cosxy[1],
					cosxy[2]-sinxy[3], sinxy[2]+cosxy[3])
				end
				oline += tpos
				line(oline[0],oline[1],oline[2],oline[3])
			end
		end
	end
	
	
	--this poke is weird???
	--poke4(0x5500,oldfill)
	--poke4(0x5504,oldfill>>4)
	poke8(0x5500,oldfill)
	--color(oldcol)
end


vgfx_trisdrawn=0
function tri(x0,y0, x1,y1, x2,y2)
	vgfx_trisdrawn += 1
	
	if (not vgfx_subpixel)	x0,y0,x1,y1,x2,y2 = flr(x0),flr(y0),flr(x1),flr(y1),flr(x2),flr(y2)

	if vgfx_wire then
		line(x0,y0, x1,y1)
		line(x1,y1, x2,y2)
		line(x2,y2, x0,y0)
		return
	end
	
	--order the vertices so they are descending from top to bottom
	--we need this since we are drawing it as two triangles:
	--one with a flat base, one with a flat top
	if (y1<y0) x0,x1=x1,x0; y0,y1=y1,y0
	if (y2<y1) x1,x2=x2,x1; y1,y2=y2,y1
	if (y1<y0) x0,x1=x1,x0; y0,y1=y1,y0
	
	--draw the top half
	local hh=y1-y0--height of the half
	local x3=x0+hh*(x2-x0)/(y2-y0)--slicing the tri in two makes another vertex
	if (y0!=y1) triraster(y0,y1, (x3-x0)/hh,(x1-x0)/hh, x0,x0)
	
	--draw the bottom half
	hh=y2-y1
	if (y1!=y2) triraster(y1,y2, (x2-x1)/hh,(x2-x3)/hh, x1,x3)
end

--draws a filled triangle line-by-line, top-to-bottom
--args: top, bottom, step left, step right, left pixel, right pixel
--requires clipping values be set first to work properly
function triraster(t,b, sl,sr, pl,pr)
	if t<vgfx_clipt then
		pl+=sl*(vgfx_clipt-t)
		pr+=sr*(vgfx_clipt-t)
		t=vgfx_clipt
	end
	b=min(b,vgfx_clipb)

	for y=t,b do
		rectfill(pl,y,pr,y)
		pl+=sl
		pr+=sr
	end
end

--triangulation stuff
function earclip_triangulate(points)
	points=convert_point_list(points)
	if (#points<3) return {}
	local pindices = {}
	for p=1,#points do
		add(pindices, p)
	end
	
	if clockwise(points) then
		points = reverselist(points)
	end

	local tris = {}
	while #pindices>3 do
		local earIndex = GetEarIndex(points,pindices)
		local earLeftIndex = wrapIndex(earIndex-1, #pindices)
		local earRightIndex = wrapIndex(earIndex+1, #pindices)

		add(tris, points[pindices[earLeftIndex]].x)
		add(tris, points[pindices[earLeftIndex]].y)
		add(tris, points[pindices[earIndex]].x)
		add(tris, points[pindices[earIndex]].y)
		add(tris, points[pindices[earRightIndex]].x)
		add(tris, points[pindices[earRightIndex]].y)
		
		deli(pindices, earIndex)
	end

	add(tris, points[pindices[1]].x)
	add(tris, points[pindices[1]].y)
	add(tris, points[pindices[2]].x)
	add(tris, points[pindices[2]].y)
	add(tris, points[pindices[3]].x)
	add(tris, points[pindices[3]].y)
	
	return tris
end
function clockwise(p)
	local sum=0.0
	local i_next = 0
	for i=1,#p do
		i_next=i+1
		if (i_next>#p) i_next=1
		sum += (p[i_next].x-p[i].x)*(p[i_next].y+p[i].y)
	end
	return sum>0
end
function reverselist(l)
	local r = {}
	for i=#l, 1, -1 do
		r[#r+1] = l[i]
	end
	return r
end
function wrapIndex(index, size)
	while (index<1) index+=size
	while (index>size) index-=size
	return index
end
function GetEarIndex(points,indices)
	local i=1
	local i_l
	local i_r
	
	while true do
		if i>=#indices then
			return 1-- #couldn't find an ear :/
		end
		
		i_l = wrapIndex(i-1, #indices)
		i_r = wrapIndex(i+1, #indices)
		
		if VertIsConvex(points[indices[i_l]],points[indices[i]],points[indices[i_r]]) then
			if NoVertsInTriangle(i_l,i,i_r, indices, points) then
				return i
			end
		end
		
		i+=1
	end
end
function VertIsConvex(prev, v, next)
	return CrossProd(prev-v, next-v) <= 0
end
function CrossProd(a,b)
	return a.x*b.y - a.y*b.x
end
function NoVertsInTriangle(a, b, c, polyIndices, P)
	
	for k=1,#polyIndices do
		if k!=a and k!=b and k!=c then
			--check if this point is within the tri
			if point_in_triangle(P[polyIndices[k]],P[polyIndices[a]],P[polyIndices[b]],P[polyIndices[c]]) then
				return false
			end
		end
	end
	return true
end
function orient(a,b,c)
	local ab=vec(b.x-a.x,b.y-a.y)
	local ac=vec(c.x-a.x,c.y-a.y)
	if CrossProd(ab,ac)>0 then
		return 1
	end
	return -1
end
function point_in_triangle(p, a,b,c)
	local turns = orient(a,b,p) + orient(b,c,p) + orient(c,a,p)
	return turns==3
end

function fan_triangulate(points)
	points=convert_point_list(points)
	local v,i={},3
	while i<=#points do
		add(v,points[i].x)
		add(v,points[i].y)
		add(v,points[i-1].x)
		add(v,points[i-1].y)
		add(v,points[1].x)
		add(v,points[1].y)
		i+=1
	end
	return v
end

function strip_triangulate(points)
	points=convert_point_list(points)
	if (#points<=3) then
		local v={}
		for i=1,#points do
			add(v,points[i].x)
			add(v,points[i].y)
		end
		return v
	end
	
	local v,i={},4
	add(v,points[1].x)
	add(v,points[1].y)
	add(v,points[2].x)
	add(v,points[2].y)
	add(v,points[3].x)
	add(v,points[3].y)
	while i<=#points do
		add(v,points[i].x)
		add(v,points[i].y)
		add(v,points[i-1].x)
		add(v,points[i-1].y)
		add(v,points[i-2].x)
		add(v,points[i-2].y)
		i+=1
	end
	return v
end

function convert_point_list(t)
	--converts a list of points from various formats to {vec,vec,vec...}
	--this is used for various operations when loading or making polygons
	--but not for storing/rendering the vector sprites themselves
	if #t>0 and type(t[1])=="userdata" then
		if t[1]:width()==2 then
			--already correct vector format
			return t
		end
	end
	local l = {}
	if type(t)=="userdata" then
		--assume its a userdata list of [x0,y0,x1,y1,...]
		for i=0,t:width()-1,2 do
			add(l, vec(t[i],t[i+1]) )
		end
		return l
	end
	
	if #t>0 
	and type(t[1])=="table" and #t[1]==2 then
		--assume it's a list of tables, each table describing a point
		for i=1,#t do
			if t[i].x then
				add(l, vec(t[i].x,t[i].y) )
			else
				add(l, vec(t[i][1],t[i][2]) )
			end
		end
	else
		--assume its a list of {x0,y0,x1,y1,...}
		for i=1,#t,2 do
			add(l, vec(t[i],t[i+1]) )
		end
	end
	return l
end
function one_d_point_list(t)
	--converts table {vec,vec,...} to userdata [x0,y0,x1,y1,...]
	local l = userdata("f64", #t*2)
	local udi=0
	for i=1,#t do
		l[udi]=t[i].x
		l[udi+1]=t[i].y
		udi+=2
	end
	return l
end
:: lib/debug.lua
--[[pod_format="raw",created="2024-05-05 04:43:06",modified="2024-05-13 23:48:58",revision=2924]]
width = width or 480
height = height or 270

debug = {
	enabled = true, -- if false, logging will not work
	visible = true, -- whether to display logged lines on screen
	
	log_file = "/log.txt", -- default filepath to save log file to -- TODO make relative to cart?
	save_when_logged = true, -- if true, save when log is made
	save_every_x_tick = 0, -- if > 0, save after this many ticks
	lines = {}, -- auto regenerated when log changes
	
	key_toggle_visible = "`",
	key_save_log = "f11",

	enable_print_info = true,
	enable_print_warn = true,
	enable_print_err = true,
}

store(debug.log_file, "") -- fresh log file on init

function debug:_draw()	
	if not self.visible then return end
	for i = 0, 9 do
		if #self.lines-i <= 0 then
			break
		end
		local newline = self.lines[#self.lines-i]
		local pre = newline:sub(23,27)
		local col = 7
		if pre == "[INFO" then col = 12
		elseif pre == "[WARN" then col = 10
		elseif pre == "[ERR!" then col = 8 end

		local c = count(newline, "\n") or 1 -- TODO doesnt work ):

		print("\014"..self.lines[#self.lines-i], 3, (height-((8*c)+8*i)), col)
	end
end

local ticks_since_save = 0
function debug:_update()
	if not self.enabled then return end
	if keyp(self.key_toggle_visible) then
		self.visible = not self.visible
	end
	if keyp(self.key_save_log) then
		self:info("Manually saved log file to "..self.log_file)
		self:save_to_file(self.log_file)
	end
	if self.save_every_x_tick > 0 then
		if ticks_since_save == debug.save_every_x_tick then
			self:save_to_file(self.log_file)
			ticks_since_save = 0
		else
			ticks_since_save += 1
		end
	end
end

function debug:info(text)
	if debug.enable_print_info then
		debug:log_line("[INFO] " .. text)
	end
end

function debug:warn(text)
	if debug.enable_print_warn then
		debug:log_line("[WARN] " .. text)
	end
end

function debug:err(text)
	if debug.enable_print_err then
		debug:log_line("[ERR!] " .. text)
	end
end

-- info 12
-- warn 10
-- err 8
function debug:log_line(text)
	if not debug.enabled then return end
	local timestamp = date("%Y-%m-%d %H:%M:%S > ")
	local newline = timestamp..text.."\n"
	add(debug.lines, newline)
	if debug.save_when_logged then
		self:save_to_file(self.log_file)
	end
	-- local t = fetch(debug.log_file)..newline
	-- store(debug.log_file, t)
	-- debug.lines = split(t, "\n", false)
end

function debug:save_to_file(file)
	local lines = ""
	for l in all(self.lines) do
		lines = lines..l
	end
	store(file, lines)
end	


-- Misc Functions --
function stringify_table(t,offset)
	if type(t) ~= "table" then
		debug:warn("Cannot stringify non-table")
		return ""
	end
	offset = offset or 0
	local str = ""
	if offset == 0 then
		str = str.."{"
	end
	for k,v in pairs(t) do
		newstr = "\n"
		for i = 0, offset do
			newstr = newstr.."\t"
		end
		newstr = newstr..k.." = "
		if type(v) == "table" then
			--newstr = newstr.."TABLE"
			newstr = newstr.."{"..stringify_table(v,offset+1).."\n"
			for i = 0, offset do
				newstr = newstr.."\t"
			end
			newstr = newstr.."}"
		else
			newstr = newstr..tostring(v)
		end
		str = str..newstr..","
	end
	if offset == 0 then
		str = str.."\n}"
	end
	return str
end

function contains(t, v)
	for f in all(t) do
		if f == v then
			return true
		end
	end
	return false
end
:: lib/dialogue.lua
--[[pod_format="raw",created="2024-05-13 17:14:41",modified="2024-05-13 23:48:58",revision=1169]]
-- TODO make ent
dialogue = {
	advance_key = "space", -- TODO allow multiple
	
	active_dialogue = nil,
	line_num = 1,
	
	can_advance = true,
	current_text = "",
	chars_shown = 0,
	line_chars = 0,
	wait_time = 0,
	wait_time_elapsed = 0,
}


-- dg		 - dialogue data
-- start	 - line number of the dialogue to start on
function dialogue:start(dg, start)
	if not dg then return end
	start = start or 1
	
	self.active_dialogue = dg
	self.line_num = start
	self:process_line(dg.lines[start])
end

function dialogue:next()
	if self.line_num == #self.active_dialogue.lines then
		-- end of dialogue
		self.active_dialogue = nil
		-- TODO maybe we send an event?
	else
		self.line_num += 1
		self:process_line(self.active_dialogue.lines[self.line_num])
	end
end

function dialogue:process_line(l)
	if not (type(l) == "string" or type(l) == "table") then
		debug:err("Invalid dialogue line")
		-- TODO allow raw function 
		return nil
	end
	
	if type(l) == "string" then
		self.can_advance = true
		self.chars_shown = 0
		self.line_chars = #l -- strings are easy
		self.current_text = l
	else
		self.can_advance = false
		local cmd = l[1]
		local args = l[2]
		if type(cmd) == "function" then
			cmd(nil,args)
		end
		-- leave current_text as is unless a command changes it
	end
end

function dialogue:_draw()
	print(sub(self.current_text, 1, self.chars_shown),0,0,24)
end

function dialogue:_update()
	if self.chars_shown < self.line_chars then
		self.chars_shown += 1 -- reveal more of line
	end
	
	if self.wait_time > 0 then
		if self.wait_time_elapsed < self.wait_time then
			self.wait_time_elapsed += 1
			debug:info("elapsed "..self.wait_time_elapsed)
		else
			self.wait_time = 0
			self.wait_time_elapsed = 0
			self:next()
		end
	elseif keyp(self.advance_key) and self.can_advance then
		if self.chars_shown < self.line_chars then
			self.chars_shown = self.line_chars -- show whole line if we're still writing it
		else
			self:next() -- otherwise advance
		end
	end
end

dgcmd = {}

-- arg 1 - wait time
function dgcmd:wait(args)
	dialogue.wait_time_elapsed = 0
	dialogue.wait_time = args[1]
end

function dgcmd:choice(args)
	
	-- TODO
end

function dgcmd:sfx(args)
	-- TODO
end

dg_test01 = {
	lines = {
		"line of dialogueeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\neeeeeeeeeeeee!",
		"auto line breaks thanks!",
		{dgcmd.wait, {30}},       -- to run func, first arg func, second is args
		"new line",
		{dgcmd.choice, {
			{"choice 1", 12}, -- choice name, line num
			{"choice 2", 16},
		}}
	}
}
:: lib/saveload.lua
--[[pod_format="raw",created="2024-05-13 17:53:44",modified="2024-05-13 23:48:58",revision=845]]
include "lib/debug.lua"

save = {
	appdata_folder = "dev", -- name of subfolder in /appdata to save to
	version = 1, -- increment when migrations are needed
	data = {
		-- can put in defaults here
	},
	
	file_ext = ".sav",
	
	quicksave_pre = "quick",
	num_quicksaves = 3,
	
	presave_callback = function()
	
	end,
	postload_callback = function() -- function called on load, it should reset state
		debug:err("Load callback not implemented")
	end,
}
-- TODO use revision metadata to track num of times save overwritten?

-- Returns metadata of all save files
function save:get_all_saves()
	local path = "/appdata/"..self.appdata_folder.."/"
	local files = ls(path)
	local save_meta = {}
	for file in all(files) do
		if file:sub(-1 * #self.file_ext) == self.file_ext then
			local m = fetch_metadata(path..file)
			m.path = path..file
			add(save_meta, m)
		end
	end	
	return save_meta
end

function save:save(file_name)
	-- trim file extension if provided one
	if file_name:sub(-1 * #self.file_ext) == self.file_ext then
		file_name = file_name:sub(1, -1 * #self.file_ext - 1)
	end
	local path = "/appdata/"..self.appdata_folder.."/"..file_name..self.file_ext
	local folders = ls("/appdata/")	
	
	local make_dir = true
	if folders ~= nil then
		for i,v in pairs(folders) do
			if v == self.appdata_folder then
				make_dir = false
				break
			end
		end
	end
	if make_dir then
		mkdir("/appdata/"..self.appdata_folder)
	end
	self.presave_callback()
	store(path,save.data,{save_version = save.version})
	debug:info("Saved to "..path)
end

function save:quicksave()
	local path = "/appdata/"..self.appdata_folder.."/"
	local files = ls(path)
	-- rename old quicksaves and delete oldest if at max
	for i = self.num_quicksaves, 1, -1 do
		f = self.quicksave_pre..tostring(i)..self.file_ext
		if contains(files, f) then
			if i == self.num_quicksaves then
				rm(path..f)
			else
				mv(path..f,path..self.quicksave_pre..tostring(i+1)..self.file_ext)
			end
		end
	end
	self:save(self.quicksave_pre.."1")
end

function save:load(file_name)
	-- trim file extension if provided one
	if file_name:sub(-1 * #self.file_ext) == self.file_ext then
		file_name = file_name:sub(1, -1 * #self.file_ext - 1)
	end
	local path = "/appdata/"..self.appdata_folder.."/"..file_name..self.file_ext
	local files = ls("/appdata/"..self.appdata_folder.."/")

	local d = nil
	if files ~= nil then
		for i,v in pairs(files) do
			if v == file_name..self.file_ext then
				d = fetch(path)
				break
			end
		end
	end

	if d ~= nil then
		for k,v in pairs(d) do
			self.data[k] = v
		end
		debug:info("Loaded from "..path)
	else
		debug:warn("Unable to load. No file at "..path)
	end
	self.postload_callback()
end

function save:quickload()
	local path = "/appdata/"..self.appdata_folder.."/"
	local files = ls(path)
	local file = self.quicksave_pre.."1"..self.file_ext
	if contains(files, file) then 
		self:load(file)
	else
		debug:info("No quicksave found.")
	end
end

-- Helpers --
function write_props(obj, proplist)
	local data = {}
	for prop in all(proplist) do
		data[prop] = obj[prop]
	end
	return data
end

function set_props(obj, data)
	for prop, v in pairs(data) do
		obj[prop] = v
	end
end
	
:: lib/yottafile.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTA2IDAxOjM3OjMzIixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMjoyNjoyOCIscmV2aXNpb249MTZdXWx6NADtAAAA_QEAAPYoe195Zl92ZXJzaW9uPTEs
ZGVwcz17Ii9kZXYvbGliL2Vycm9yX2V4cGxvcmVyLnA2NC5wbmciLCIAX2dhdmVsGQABT3BndWkY
AAFFdmdmeBgA8BV9LHRhZ3M9e2NyZWF0ZWQ9IjIwMjQtMDUtMDYgMDE6Mzc6MzMlAM9yYWNrZWQ9
e19yZWahAFwKYgBPPXsiLnkAAC8iLBcAAgsPAHEubHVhIn0skgAFSQABoAAoIiwOAIMvYWxnZWJy
YTAAAKkABS8AAA0AJyIsDQABBQADKgAAuwAFKgAADQAnIiwNAAEFAIAubHVhIn19fQ==
:: lib/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA1LTA2IDAxOjM3OjMzIixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OSJdXWx6NAAEAAAAAwAAADBuaWw=
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI1OjE1Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OCIscmV2aXNpb249MzIyOF1dbHo0ALoAAACvIAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD-------_9HjIEAA8BAFYfMgQABg8BAFMfMgQAAg8BAE8fMgQACg8B
AFMfMgQAAg8BAF8XMgQADwEA--------nPEIIiksaGlkZGVuPWZhbHNlLHBhbl94PTAIANJ5PTAs
dGlsZV9oPTE2CgAQdwoAj3pvb209MX0sVxALHzEEAP--------------------gPVxAkUG09MX19
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI1OjE0Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OSJdXWx6NAAEAAAAAwAAADBuaWw=
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI1OjE1Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OCIscmV2aXNpb249MzIyNl1dbHo0ABUBAACiDAAA8CdweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDBAUGBwAP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUP
Fg8XEwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8t
Dy4PLxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AA--8P8BAOv-J1oBEAYP
IBABIAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDDAA------_9
H-8BAKy-yA9AAA1A--_w8HAKAP--ZB--AQD-mVD-----IA==
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI1OjE0Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OSJdXWx6NAAEAAAAAwAAADBuaWw=
:: vgfx/0.vgfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIyOjMwOjQ5Iixtb2RpZmllZD0iMjAyNC0w
NC0yOSAyMzowMTo0NSIscmV2aXNpb249MjJdXWx6NAAhAQAAXQEAALB7e3tjb2xfYT0xLAgA8CRi
PTE2LGZpbGw9NDM2OTAsbmFtZT0iIixvdXRsaW5lPS0xLHBvaW50cz17ezQ4LDQ4fSwIABEtCQAV
MAgA8ww0OH19LHNob3c9dHJ1ZSx0eXBlPSJlYXIifSxvABM4bwASOG4ADmoAJjEyagDxNS0xMTYu
ODE4NTgxNDY3ODYsLTQyLjQwNDM2NzMzNTEwNX0sey04MC4zNTMxODc0NDUyMDgsLTYzLjMzOTM4
Njc3MDc5JADwETUwLjYxODk2NjUzMTIwMiwtMzcuMjQ1NzgzOTc5MzYyJADwEDQwLjAyOTQ0NzU1
OTA2OSwzLjQ1ODc4Njg2ODg3MTMjAEA4OCw3CABfMTIxLDbrAANQciJ9fX0=
:: vgfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIyOjMwOjQ5Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OSJdXWx6NAAEAAAAAwAAADBuaWw=
:: label.png
b64$iVBORw0KGgoAAAANSUhEUgAAAeAAAAEOCAIAAADe_FMwAAAa50lEQVR4Ae3dsYvjSNrHcZXH
oZlLj6ZxNpMszQTKOtlNjWeyngFh6OSgMXR04Gjv6MDcu5HhIoMZuNAoGGU7c5PuJs6U9f4DTnrT
hc71BrX3bG2VJJdkyS27vx_EuqpUVSqV2j_lKvvt1wAA0D39Q9-wh5_6tQHff6f--uv-PndqXf-8
x1sWxsK6szDpjENS2W_-mnX3VTX5Yuql8-ff7R6oc7bu-J6-nH-_463ZU6p6i4q2rvbP0rrdAcZ6
LticvPxGVZexzyNXHV70Nssv1dvJPZ_rdvhWepVPFtD6Z2v_hHU5j7mlbnUnz-7_MVi0ezvX86--
_6w3v7xn3_eRKi2u_RfpE7s--FTyUlsij1_0RTt3v2uefMEHTjHPW9dYVRd28jj_96xE-v674Ief
Gvw5Wx-aql_49v4tfdI5J6CtZZV-YBv4D5DPpn4xVmPRd7U8smUqs_AZ9M4OWlsp323rA151NnOq
Sv8u7pLc2ayluveyZttzwbmT_1Rzd7ikp-tEOx_hqH-J2yx-0fV2cufbdKtFj9nqq8QBPpyVvh92
QBf9H-jcrGZqSzpLnprxan1LreSt_pWumNHWw5qfK5_vn8_rKv8ElvQ3B1qN1lLdHKz3y7QiI3dh
7vLKq_4Ol2SK_0SVvoglW2TeuuRSIztpjSqq5i677VdZss6OJ53-5ndh8dYySp7FDmj3M-sET2sm
cjcnbOElHeYf1EycqjN4Lnjnz37-5-V8hDb_P8056_3kzlH_G9jeq9QdupnR5V84n38h-3_MnTO3
nfg5AW1_t8sXkbv6Oiv_4ac-hamuNpWqjU-Y6D_Z-3bV_ymWvLhKPz--BZfMmTtJvRTweYQ2wsWa
s8ZO7hxVPtX_C-B5lTr6O5jObav6yPW_svUDuuqbbn6HfvjpT0mqyxKyReFrVq0ZrGqVrbceUFqk
YG6X_X-vfuGt2dzJ9-nXMRfmtlhX5b7uyust2Jzc7OYu2J3E2kD37rlPvfMRdq6k-G0WXbLmrLeT
1ihrHv8NrL0Az-_9A6Wz9ZvVP_fSH2zuJ6olnj9Sa3sb3FuV-fbr4T5PuSH75L7-7kD-i9X-OUoC
qCML6_yOsbBmF_YZVWhWjy04Ct38eQNolTq-ThqeMY3ZVgDwdzMe5bb32BoA6IJv330jBwENAB1K
Z7e6V0CrNPbptl7NPLvt7Okz1WCeyLmGegMH88Rz4J7LA-B81A9oz3QOgmAyXTTYrZse7674ZwLQ
lYDOwsin23o1W69mZlmquS3S7hbcgSVZKYk5mCf6kKo0mh18rrqz5bJmsyaxlgcARfpt32AyXZhJ
OpkudLzqdl31SXkZaFV9ZtBpOJgnVsFtfLy7KrlqXqrEvS8A7NQ70nWvVzMz92vEZb2Bg3kymCdV
B9YbBeCZ6x-puifTRaV83CeX3XAfzBP-2aQzGQ2gkl7tkSqN5VxivZrJ2Q3Z9WqmD6u-XLJ6lgws
T9WiPH28uxrMEzNwpcW9qstmZytzrVHuhABQIWbPrxsOjp2RfWBmngJAB92MR9___8Zq-PnHX3on
-_SkM4AjdfoBDQAENACgGwGt0lilsU-P9Wrm2W1nT5_pBvNEzgczmCeed3yS5QF4RgGt0jgLoyyM
fDJ6Ml34zOnZrZse7674ZwLQiYDOwsiz53o1W69mZlmquS3S7hbcgSVZaSbmYJ7oo6Sae8m6mtvB
Zc7mTuIuDwBy9fcZrNJ4Z1JPpgszSSfThY5X3a6rPikvA63qzhkG88QK69yqFMyqddUa68_6BQD4
6LWazu1Zr2Zm7peH42CeDOZJSYJ7Xt05Vb1bAECu-jGmcxAEk_nCv-Pj3ZVOSV3IvVo_1nOqonSW
UfzDAfDXqz1SpbE_yrutVzM5uyG7Xs30YfWXS1bPkoEl_agPnZKPd1fS4lbddDavWlO5mWvNaU3C
fxuAajF7ft1wcOyMbACA6WY8_vbdN1bjzz-_0mNrAKCbCGgAIKABAIcJaJXGKo19eq5XM89uO3v6
TDWYJ3Iu6eBWB-Mkd1RRe41bA0CRn3-8RY69AlqlcRZGWRj5ZPRkuvCZ07Nb4x7vrqxCUQcAaM_3
776RY6_AzsLIs_d6NVuvZmZZqrkt0u4W3IEleSqpOpgnZkHOVsGTNZs1g3VrAPD384_-yKFb_rXn
Umnsk9ST6cJM0sl0oeNVt_uqT8rLQKvqOYMZ34N5Ihmqq-vsqZ7KnBMAavj23TdWS-2A1tGs0nhn
RrfBDP2ntWe_A0CRmgH9VLksJtNFR9L58e6KmAbQhl69YVkYqTT2ien1aiZnN2TXq5k_rP5yyepZ
MrDI493VYJ6YAWq2mGfJXKtgVq3Z3MkBoCnq-LrhcFFpzLYCgL_b8ejbd99YjT--_EuPrQGAbiKg
AYCABgAcLKBVGrODANC5gCadAaCLAa3SOAsjtg8AOhfQAIDuBrRKYzkDABrXrzcsCyOdzroAAGhc
jy0AgBMM6CyM2EEA6GJAAwAIaAAgoAEARx3QKo3laHZBN_ORPhqcreSqfxUADqxfe2QWRo2v5mY8
_vjla_Oz1Zu2wZUAQA29jq-vZjy6GY_ssrRYHXZGrTWbO6dZte7r3rSkAwA8ZUCrNFZp3HYof-zy
9eOXr2b1ZjySFl02O1i5bMWo2Vmntm4pqppTuTe1prWGAMCe_vWGZWEkMS3lorS1EtOs5g4xu_Um
b9H8uVNJhvrMVoOV_Ps-PoBn6Ocff-n23TdmtX5AV8qvkurO8HWD1X9CGd5sJlo5634Gmnp8AM8t
o62WmgGt0lgXsjBqNs2tLLaisKR-bjjqq-qS27mogxRyM9dMZPPjQfgCaJY6v04anvF-2X3CzFgH
gEYihYAGgKMJ6B5bAwDdREADwMkFtEpjlcZde57tZrndLHmvAE5Av3Y6Z2HUzUcaXt7yXgE834Cu
ZL2a6cJkupCqVV6vZrrF6gAABHRlKo2DIMjCaGc6m1lsRrMuSDqbZ7ODabtZSnl4eetedRsB4NkF
tI5mlcY7M9qN7NodyvN3eHlLRgMgoH1NpgszcNer2WS6sFJYtxRVTdvN0jOsAeCZBnQWRiqNdcEn
oyWRrbwuD3Q3qQllAM_HOr9OGp4xja0WieYDPM92syTHARyXm-Eot71-gHsfJpo1ohnAyeixBQBA
QAMA2g9olcZysIntGcwTOeuCefjPUHTJnMed1myxVgLgAPr1hmVhJEnNJh7M492VTkldaHxCs9rg
XQDU0_vagtarmT6sFqtc1OEkE7k8KAfzZDBPrKpukbPZob2VAGhWf5-BKo2zMGp8TZPpQseuLrhV
XTbPZofjst0spTy8vK06fDBPdGjqglQlVa0Wd7gZu1Y1twXAEQR0S_nsWq9me3boshqhnBuyZiL7
R6oZ7rmjZEIAxxTQh7FezSbThZXCuqWoely2m_WeYW2lqpW5AAjotkymCzOayzscY1LXC2Uzjgfz
JLdsNVbNa3O2kq-LnusHUEKdX_-4EVaeMY3Z1ueAdAaacjMe5bb32BrUQzoDbSOgAYCABgAcJqBV
Gqs07shjrFezSu0l8_QOyW2vOnkNg3kiZ12Qckm7O0PVO7bRueS5ADQZ0CqNszDKwqg7Gd1Iyk_m
i8l04V7KbTy8x7ur3KrVDuBZB3TbQblezcxyUdXq7I7Nna3GMsovld90-0TOzd-BPBnMk9x2q2BW
9ajcgVaf3LuYw63ObrVkbMlzARD9esOyMFJprAuNr2kyXeiM04WSqjRKGppXzQ65M1uZK2drZquz
dVO3Z_78RbabpZSHl7eVsrsoZ3OTV9JQF8wWa05pl7IuWEPcFreDO9Z-zQBqBrRKYx3NUmiQpG3j
Y0uuumle_6aVJqkUyvXkZrH-WPeTUDRb7bsAaDKg2yMpKamnC5J6VrV8rP-VfdSLdW27WTYb1hKj
VoukZ3nIlmeurnomvnkjd1UAdlLn1zV-NiqNgyDIwii3fc_MluCTVLVCNrezW7UC3ZrZSlj3Xj7z
lC_4cZJ6kncSmlae6hiVMLWq5mxWFptTmXex7uiux7177vqLwn27WTbyiQKOzs141HBAlwd3U3YG
NEpCvFI_Nr4G60YlqyKdQUAfZUADwLMN6B5bAwDdREADwMkFtEpjlcaHX-F6Ncstn6TBPJGzLki5
pN2dwXN_AKcQ0CqNszDKwuhJMvrZery7yq1a7QCedUC3ar2arVczKZsFOZvtUs4da3U4xkTOzd-B
PBnMk9x2q2BW9Si5VDI-gCfXrzcsCyOVxi2taTJd6GDVBeuS1W52lktuobO2m6WUh5e3lbI7N6Bz
DeaJpLAumC0ATiqgdUYHQdBGTK9Xs2azvssqhXI9ZDHw7AK6JevVTKdqgzHdZdvNstmwfry7GswT
t0UyWl8lsoFTDmiVxkEQZGHU7IIm04UZzVbVbNE57nmps2qEsk5bnbNW8uqyPpsxbWb0zmjebpaN
fCoA7EmdX--xM25mxjRmW5_WjubcIDYDnXQGOuJmPCKgAeCYArrH1gBANxHQAHASAa3S2Cyb1Y5Y
r2an9HoG80TO0mJWrc5Fl8xJ3DkBHH1AW_mchVEWRl3L6Ml0ccJvazBPHu_uHu_u3HgtuUQcA0eq
79-VjeM20nm9mumQNQuSvLrRapFoNtvdgceY4I93V3L2SduiS2Zw584J4LgD2qLS2I3sw_S1GcFm
4EpG5-Z3h3fBdrOU8vDydmf-wTwx09bzEoDnFdBZGB1miZK5ksJuIncqcyvxCWXT491VjUtA27ab
ZdV-ZrQY0G2HsmRuefjqq2b-o-u3rh3WABl92nr_XVUayzkLI5XGKo2zMGo7ndermT5ye_pDYlrO
MrDjwT28vJVjZ_fHu6vBPBnMk8e7K90ymCc7L0nZbCn5TgD7ZDSb0CB1fl34o605YxqzrUf3o-L5
PACe0cy-U1U341Fue5_tAT8n8L-UTT22AEAj0Ty8vN1ulmwFAQ2gozHNJjxZQKs0LqkW2W6WfFcB
oMWArpfOfFQBoJ4XL9988O17dqEe7oOzi-yqBPfDvTv0738b--s--2W7AcAVvn6V2947zO2Hl7fb
zZLXAAD_DhTQ281yeHnLdgNA5wIaANBiQKs0lrNbBQA0S51fJw3P6ET2drMMgmB4ect2A4DrZjzK
be8f4N5EMwDU0GMLAICABgC0FtAqjc2yWQUANOvFyzcfqqXz2YUuZ2EUnF2oNNYtf3R7uGdbAcBf
_PrVvgEdnF2oh-vf4-h-ofxHCwENAI0GdG_fSVUaZ2HE5gJAG_oHNOkMAF0MaNIZADoU0CqN5awL
_mATAaANL16__eDb9_zi98Ms66qZ4w-3bCsA_Atfv8pt77E1ANBNBDQAENAAgPYCWqWxWTarlaxX
s6IW85LbzTWYJ2a5pAoAJxvQVjpnYZSFUb2MnkwXjazeiuPHu6vHuyvdaFUB4Oj0-buacZyFkeeo
9WomcazL69XMzGhdNctmB6uzlc4785d0BvAsAtqiw9o-qYVktBnfEsRmoJsxPZkutpultA8vb61p
Jawf7678ExwAOqtXe2QWRlkY6ZjeSRJ5H8PLWzkkgs3z492VmciS1ABwjPr1hqk0zsLowGvdbpZm
WOv81bnMiwRwetT5deIfyrqgo1lX3ZiWbmK9mk2mC33WVd2eW5UWa4hctZgBPZgnQRAUVQGgm27G
o30DumqOAwD2CegeWwMA3URAAwABDQBoL6BVGpdUc61Xs3od3PbyqQbzZDBPzLLbwvsGcET6raaz
j8l0sf8kg3nyeHclBV3WVfcqbx3AqQV0FkYSyiqNzWq59WpmBrFZzb2Ue1WXrf7CJ3Z1WAPACQZ0
bZKwk_lCn6WqWySdzSy2BppjgyDYbpYy--DyViLYTGqzqstkNIAj0qs9UqWxnCtZr2YSwbUNL2-l
2JnOQRCYZQA4Cv16w7Iw0umsC5VMpouidv-g3m6WZlhbcQwAJ6Dn31WlsZxr0ymsjyAIzLO_WhTf
5lgdynLoq4N5og934OPdlb5EiAM4Iur8OifR9ppxjwTX4VuS0QBwem7Go9z2fqdWSTQDgOixBQBA
QAMAWgtolcZSkINNBIA29Guks5aFEdsHAO158fLNB9__Zxfq4T44uwiCQAo5Of5wz7YCgL-w9avc
9l7tGVUaqzRmZwGgJS9evvlQIZQf7oOziyAIgrMLfag0-r3F7AMA8Ba_fpXb3mNrAKCbKgS0SmPz
rI8sjNhEAGjDi5dvPvj2Pbv4-bDKVo4-3LOtAOAvfP0qt73H1gBANxHQANBRfbagy7Zv35vV4edP
7AnwfPQq9VZpbJbNaiNuxiPzMButDtaQ2rdrdvElMzd7LwDPQb92Omdh1PhqPn75qrNMF8yyFMyq
e7WzOr48AB3U8_-aRiK36mY8uhmPdMFttHqWXC0fa85gdigvu0squS8AAroalcYqjTv_eB_-fL0Z
j-RZWsyqzsePX75KwbpqzVZ0Vc_gO7idpdG9JDflfxGApV97ZBZGOqZ1oYgZZ1a6PUkqWfEq6Zx7
tXwsAHQ0oD1ZKXz4ULbyV1clavU3Q-qULM8d29TyyH0AuXr_XVUayzkLI5XGKo2zMGo7Xm-GIzND
zap71XO23IiUq7mJmTvWs4NuLBr78cvXw3_3AHSfOr9OGp4xjdnWSuTz4F7avn1vVoefP7FdwKmG
AAENAEcT0D22BgC6iYAGgJMIaJXGUpCDTQSANrx4_eZDtXQ_u-j9fHYRnF2oh-vfW6Tbwz3bCgD_
wtev9g3owjgmoAGghYDu7TOpSuMsjNhcAGhD-YAmnQGgowENAOhKQKs0ljMAoG0vXr754Nv37OL3
Q6q5Of5wz7YCgL-w9avc9h5bAwDdREADAAENAGgvoFUam2Wz2oib8Si3XNSnfCo59lyJ-00BoEH9
2umchZFZaDCjP375WhKIH7989ZzKv_chpwIATz3-rs0GcUkU6ow2I1vy2i2XRLmV_2bBHWu2mH2s
m_5cQ6VVAUCJfr1hWRipND5Mauuw1qmt4zv3UlEo516yxlozWC3mTaVdCiXzAMATBLRKYx3NUihi
5akbr0XRmTtDjWQ-JHnAkg9Gpa0AQEC3m1n7hObNeKSH1I7pw2e0uewGtwLAc9Pz76rSWM5ZGKk0
VmmchVHbeXczHkk660KNsLbmKboqHcz_5lnac_NVJiF8AexPnV8nDc_YxmwrAPi7GY9y23tsDQB0
EwENAAQ0AKC9gFZpbJbNarnt2-fbt_9rrM8aVW8S13o187nkdttulrllAHjKgLbSOQujLIx8Mnr7
9v3w86fh50-7L7eRSYIgmEwXNS5tN8vh5e0fi7m8JaMBtKfv39Uzjn3CWgrbt__t5DVbdFmfpWr1
lNn8E3y9mkkQ67JVNctmCwAcUq-eMB3WPnktISsZahl_-mRmsa7qnJWzWTWD3op4s1rCStvJdDGZ
Ltwg1mV9lX8UAIfXrz0yC6MgCHZmtA5NM1sBAD56bAEAdFPfv6tKY33Owkiquuxv_PnT9u17n6vD
z5-MFils374ffv5ktu_86Xo1k-JkutDV9Wo2mS5ye8ol6ez2BIC2qfPrpOEZ0-iE92u7WQ4vb90y
ANR2Mx7ltvfYmkrMRCadAbSKgAYAAhoA0FJAqzRWaVxUbdV6Nduzg9hultvNkhcP4HQCWqVxFkZZ
GOlQtqptm0wXDc42vLzlxQPovr5nvyyMclO78QWtVzOJY11er2aS0bpsRra0mFXpbE3F_wZwRHqV
eqs0lqQ2y62ygnUyXUhq69i1Uliuurab5fDylrcO4NQC2krkVtO5KGH3nGp4ebvdLHnrAE4qoK10
BgB0JaB1RusjCIIsjHS58dSeTBfr1UzOQRCsVzM553aWS1LVA92pAOCIqPPrpOEZ07jLD7zdLIMg
GF7e8u4BdMTNeJTb3n9uG0E0AzgWPbYAAAhoAEA7Aa3SWKWx1dKFZ1ivZkVVq2z1rGcwT_R8yLEA
COjCdM7CKAsjCeWOpLNrMl1UageAblLn10m1AWmchZFbNjsc8gHWq5kZwbqqs9i6pFskps2e_xjM
k8e7q8E8CYJACrosHawWADDdjEe57f3a6dwROpQlZyWj3UtWrLuRLbabpZSHl7eeGS1VXZbglir-
hQAqqRDQHUznfUiOu3xC2WSmMwAcOqBPLJ2DIJhMF0WXtptl7bAOgmAwTyS1H__udBUAqlLn117x
odJYyjqppcUKbrPnwaxXM525umDmr1zKLZcntWcc6yzOre5sB4Cb8WivgK4Q_U8R0N3hBvFgngRB
QDoDIKAB4EQCusfWAEA3EdAAcPwBrdJYpXFRtUHbzXK7WfJuADxzL16__eCZzlkYBWcXKo312az_
qefD-Z5r_vd--vv3v43--Z--8noAPAfh61d7BbSksHq4D84u7GqjAR0EAQENgIDuVZpFpXEWRkXV
Bg0vb7ebJa8NwHNWIaAPls5BEGw3y_HlLa8HAAHdrXQGAFQIaB3K_sitAgCapc6vk4Zn3Duyt5tl
EATDy1teD4Dn4GY8ym3vd3CtRDMABEHQYwsAgIAGALQT0CqNVRoXVQEAzXrx8s0Hz3TOwig4u1Bp
rM9m9U89H_7ZVgDwF75_tVdASwqrh-vg7MKuEtAA0HRAAwAAADiY7Ldfn3yGVu9e3uEwj_-2qX3f
qgPbu1GDDwWcsB5bcETfsye-b0uPQDoDuVTRT0X95a9SNctuVbdkv-0q7VJ1h_uyO5vPMswb7Zw5
d83uVLlXcx_wJFNyl5H7UEWPX7I57saW3Dd3V80ZSp63aHOsDuWPUHtjzZl9-g18-ouAY9dzE0Qf
8n9v-d6scDQ75_aRGS4y1rxUMtAaa-2Yy2fOXXP5A1pjyx-Quuretzydcx_naJHm8J33tapW8JU8
r3Vf9-FzH6HoHdXeWHefd75NfsY4Vf3yy0Vx48P65fhPZf2Sq85ccqOdMz8Vc83uIq2QbUmlzXHT
tpsbC5xsQEsuSHzs8yOsNEru6xkW-jeqNHOD_euzqqJF6vjzXLD5jqo_Zskot9FdZBsbW-IvJ18F
4FkEtPkfr-7yV-cH4P5E5fdT-mvZObP7m5TbWWP9Z85NmZIQNx_nqGXn43t_UczHt9acu0gzo8vv
65_P1lj3viUPZXXec2N1WR7QTHnPzy2-ZJx_QOdG8M4f_c5y1ZnLx1aa2fqdF-UsiQOfgNjzicrn
yV1bvfuWP29Rtvq8vj031vN-w53N-6MIAADQmP8HZN76M6p2NqoAAAAQdEVYdExvZGVQTkcAMjAx
MTAyMjHjWbbBAAAAAElFTkSuQmCC
:: log.txt
--[[pod_format="raw",created="2024-05-13 19:17:30",modified="2024-05-13 23:48:52",revision=15003]]
2024-05-13 17:48:48 > [INFO] Loaded scene Sandbox Scene
2024-05-13 17:48:48 > [INFO] Loaded scene GUI Main
2024-05-13 17:48:49 > [INFO] elapsed 1
2024-05-13 17:48:49 > [INFO] elapsed 2
2024-05-13 17:48:49 > [INFO] elapsed 3
2024-05-13 17:48:49 > [INFO] elapsed 4
2024-05-13 17:48:49 > [INFO] elapsed 5
2024-05-13 17:48:49 > [INFO] elapsed 6
2024-05-13 17:48:49 > [INFO] elapsed 7
2024-05-13 17:48:49 > [INFO] elapsed 8
2024-05-13 17:48:49 > [INFO] elapsed 9
2024-05-13 17:48:49 > [INFO] elapsed 10
2024-05-13 17:48:49 > [INFO] elapsed 11
2024-05-13 17:48:49 > [INFO] elapsed 12
2024-05-13 17:48:49 > [INFO] elapsed 13
2024-05-13 17:48:50 > [INFO] elapsed 14
2024-05-13 17:48:50 > [INFO] elapsed 15
2024-05-13 17:48:50 > [INFO] elapsed 16
2024-05-13 17:48:50 > [INFO] elapsed 17
2024-05-13 17:48:50 > [INFO] elapsed 18
2024-05-13 17:48:50 > [INFO] elapsed 19
2024-05-13 17:48:50 > [INFO] elapsed 20
2024-05-13 17:48:50 > [INFO] elapsed 21
2024-05-13 17:48:50 > [INFO] elapsed 22
2024-05-13 17:48:50 > [INFO] elapsed 23
2024-05-13 17:48:50 > [INFO] Saved to /appdata/lilykp_testrpg/quick1.sav
2024-05-13 17:48:50 > [INFO] elapsed 24
2024-05-13 17:48:50 > [INFO] elapsed 25
2024-05-13 17:48:50 > [INFO] elapsed 26
2024-05-13 17:48:50 > [INFO] elapsed 27
2024-05-13 17:48:50 > [INFO] elapsed 28
2024-05-13 17:48:50 > [INFO] elapsed 29
2024-05-13 17:48:50 > [INFO] elapsed 30
2024-05-13 17:48:52 > [INFO] Loaded from /appdata/lilykp_testrpg/quick1.sav
2024-05-13 17:48:52 > [INFO] Loaded scene Sandbox Scene
2024-05-13 17:48:52 > [INFO] Loaded scene GUI Main

:: main.lua
--[[pod_format="raw",created="2024-04-29 20:25:15",modified="2024-05-13 23:48:58",revision=3970]]
include "protos.lua"
include "lib/saveload.lua"
include "lib/debug.lua"
include "lib/dialogue.lua"
include "gui/scenes.lua"
include "content/scenes.lua"

-- Game Settings --
game = {
	name          			= "Test RPG",
	author 					= "lilykp",
	version 					= "0.0.1",
}

debug = inherit(debug,
{
	log_file 					= "/ram/cart/log.txt",
	save_when_logged 		= true
})

save = inherit(save,
{
	appdata_folder 			= "lilykp_testrpg",
	version 					= 1,
	data = {
		-- put in defaults here
	},
})

-- Main Functions --
function _init()
	window{
		title = game.name
	}
	
	menuitem{
		id = 0,
		label = "Quicksave",
		action = function() save:quicksave() end
	}
	menuitem{
		id = 1,
		label = "Quickload",
		action = function() save:quickload() end
	}
	world = world_proto:new_named("World")
	gui = world_proto:new_named("GUI")
	--gui = create_gui()

	world:start(sce_sandbox)
	gui:start(gui_main)
	
	dialogue:start(dg_test01) -- TODO removeme, testing only
end

function _draw()
	cls(0)
	world:_draw()
	gui:_draw()
	debug:_draw()
	
	dialogue:_draw() -- TODO removeme, testing only
end

function _update()
	game:_update()
	world:_update()
	gui:_update()
	debug:_update()
	
	dialogue:_update() -- TODO removeme, testing only
end


-- Game Functions --
function game:_update()
	if key("ctrl") and keyp("q") then
		stop("Application force closed",0,0,8)
	end
	if keyp("f5") then
		save:quicksave()
	end
	if keyp("f9") then
		save:quickload()
	end
	if keyp("f10") then
		debug:info(stringify_table(save:get_all_saves()))
	end
	if keyp("=") then
		--debug:info(stringify_table(ws_gui))
		notify("butts")
	end
end


-- Save/Load Callbacks --
save.presave_callback = function()
	save.data.loaded_scene = world.active_scene.id
	for i,ent in pairs(world.scene_ents) do
		ent:_save()
	end
	for i,ent in pairs(world.pers_ents) do
		ent:_save()
	end
end

save.postload_callback = function()
	world:start(_G[save.data.loaded_scene])
	gui:start(gui_main)
	for i,ent in pairs(world.scene_ents) do
		ent:_load()
	end
	for i,ent in pairs(world.pers_ents) do
		ent:_load()
	end
end

--include "./lib/error_explorer/error_explorer.lua"
--[[-------------- DOCUMENTATION --------------))--

### Order of Operations ###
This order is the same for init, draw, and update

- scene function
- for all scene ents
   - ent function
   - for all ent behaviors
      - behavior function
- for all persistet ents
   - for all ent behaviors
      - behavior function

### Random Lua Notes ###
when doing for loops use
- ipairs for array
- pairs for table

--((------------ END DOCUMENTATION ------------]]--
:: protos.lua
--[[pod_format="raw",created="2024-05-05 04:59:35",modified="2024-05-13 23:48:58",revision=3047]]
include "lib/debug.lua"

-- List of Protos --
world_proto = {}
scene_proto = {}
entity_proto = {}
behavior_proto = {}


-------------------
-- Misc Functions --
--------------------
function inherit(superobj, obj) -- superobj first for cleaner syntax
	setmetatable(obj, superobj)
	superobj.__index = superobj
	return obj
end

-----------------
-- world_proto --
-----------------
world_proto.name = "world"

world_proto.pause_draw = false
world_proto.pause_update = false
world_proto.active_scene = {} -- currently active scene

world_proto.scene_ents = {} -- ents from the active scene will go in here
world_proto.pers_ents = {} --[[ put ents in here that should persist between scene
									   change these are added with an id as a key so we
                                can easily access them and check for existing
                                ones before adding an entity	]]--

function world_proto:new(o)
	o = o or {}
	setmetatable(o,self)
	self.__index = self
	o.active_scene = {}
	o.scene_ents = {}
	o.pers_ents = {}
	return o
end

function world_proto:new_named(n)
	o = {name = n}
	return world_proto:new(o)
end

function world_proto:start(starting_scene)
	self.scene_ents = {}
	self.pers_ents = {}
	self:set_active_scene(starting_scene)
end

function world_proto:set_active_scene(scene)
	self.active_scene = scene
	self.scene_ents = scene:create_ents()
	scene:_init(self)
	for i,ent in ipairs(self.scene_ents) do
		ent:_init()
		ent:init_behaviors()
	end
	debug:info("Loaded scene " .. scene.name)
end

function world_proto:reload_scene()
	self:set_active_scene(self.active_scene)
end

function world_proto:set_paused(v)
	self.pause_draw = v
	self.pause_update = v
end

function world_proto:add_pers_ent(id, ent)
	if ent == nil then
		debug:err("Tried to add_pers_ent with no ent")
		return
	end
	self.pers_ents[id] = ent
	ent:_init()
	ent:init_behaviors()
end

function world_proto:has_pers_ent(id)
	return self.pers_ents[id] ~= nil
end

function world_proto:get_pers_ent(id)
	return self.pers_ents[id]
end

function world_proto:pers(id)
	return self:get_pers_ent(id)
end

function world_proto:clear_pers()
	self.pers_ents = {}
end

function world_proto:_draw()
	if self.pause_draw then return end
	self.active_scene:_draw()
	for i,ent in ipairs(self.scene_ents) do
		ent:_draw()
		ent:draw_behaviors()
	end
	for i,ent in pairs(self.pers_ents) do
		ent:_draw()
		ent:draw_behaviors()
	end
end

function world_proto:_update()
	if self.pause_update then return end
	self.active_scene:_update()
	for i,ent in ipairs(self.scene_ents) do
		ent:_update()
		ent:update_behaviors()
	end
	for i,ent in pairs(self.pers_ents)	 do
		ent:_update()
		ent:update_behaviors()
	end
end


-----------------
-- scene_proto --
-----------------
scene_proto.id = ""
scene_proto.name = ""

function scene_proto.new(self, o)
	o = o or {}
	setmetatable(o,self)
	self.__index = self
	return o
end

function scene_proto.quick(self, i, n)
	o = {id = i, name = n}
	return scene_proto:new(o)
end

-- should be overriden to return the default state of entities in this scene
function scene_proto.create_ents()
	return {}
end

function scene_proto._init(self, w)
end

function scene_proto._draw(self)
end

function scene_proto._update(self)
end

--[[
In prototypes we define functions with . instead of : bc defining with : prevents us
from overriding the self argument by calling with . notation
We want to be able to override the self argument for a prototypes methods so we can
call the 'super' version of a function in the overriding function if necessary

Basically
- defined with : = only callable with :
- define with . = callable with both : and .
]]--


------------------
-- entity_proto --
------------------
entity_proto.behaviors = {}
-- dont need to use :new() because behaviors never store values -- TODO change this
-- so new can setup necessary variables in parent entity

entity_proto.x = 0
entity_proto.y = 0
entity_proto.vx = 0
entity_proto.vy = 0
entity_proto.ax = 0
entity_proto.ay = 0

entity_proto.flip = {
	x = false,
	y = false,
}

function entity_proto.new(self, o)
	o = o or {}
	setmetatable(o,self)
	self.__index = self
	return o
end

function entity_proto._init(self)
end

-- override to tell the entity what to save
function entity_proto._save(self)

end

-- override to tell the entity what to load
function entity_proto._load(self)

end

-- do NOT override
function entity_proto.init_behaviors(self)
	for i,beh in ipairs(self.behaviors) do
		beh:_init(self) -- pass in self as parent
	end
end
	
function entity_proto._draw(self)
end

-- do NOT override
function entity_proto.draw_behaviors(self)
	for i,beh in ipairs(self.behaviors) do
		beh:_draw(self) -- pass in self as parent
	end
end

function entity_proto._update(self)
end

-- do NOT override
function entity_proto.update_behaviors(self)
	for i,beh in ipairs(self.behaviors) do
		beh:_update(self) -- pass in self as parent
	end
end


--------------------
-- behavior_proto --
--------------------
--[[
Behaviors should NEVER have per-entity values stored within them, they should
get data from their parent if the parent has it.
If the parent NEEDS data for the behavior to work properly, you can initialize that
data in the behavior's _init.
The only values that can be stored on the component are 'static' ones that you
understand will be shared for that behavior across all entities that utilize it.
]]--
function behavior_proto.new(self, o)
	o = o or {}
	setmetatable(o,self)
	self.__index = self
	return o
end

-- can be overriden to initialize variables in parent
-- this function is used when adding behaviors to an entity
-- this allows it to run before additional variables are set on the entity
function behavior_proto.setup(self, parent)
	return self
end

function behavior_proto._init(self, parent)
end

function behavior_proto._draw(self, parent)
end

function behavior_proto._update(self,parent)
end


:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTI5IDIwOjI4OjE1Iixtb2RpZmllZD0iMjAyNC0w
NS0xMyAyMzo0ODo1OSIscnVudGltZT03LHdvcmtzcGFjZXM9e3tsb2NhdGlvbj0ibWFpbi5sdWEj
NyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iY29udGVudC9iZWhhdmlvcnMubHVhIzEy
MyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iY29udGVudC9lbnRpdGllcy5sdWEjMzQi
LHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImNvbnRlbnQvc2NlbmVzLmx1YSMzOCIsd29y
a3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ibGliL2RpYWxvZ3VlLmx1YSMxNCIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0icHJvdG9zLmx1YSMxMTEiLHdvcmtzcGFjZV9pbmRleD0xfSx7
bG9jYXRpb249ImxpYi9zYXZlbG9hZC5sdWEjMTM1Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0
aW9uPSJsaWIvZGVidWcubHVhIzEzMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Z4
LzAuZ2Z4Iix3b3Jrc3BhY2VfaW5kZXg9Mn0se2xvY2F0aW9uPSJnZngvY2hhcmFjdGVycy5nZngi
LHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1hcC8wLm1hcCIsd29ya3NwYWNlX2luZGV4
PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2VfaW5kZXg9NH19XV1sejQABAAAAAMA
AAAwbmls
:: [eoc]
